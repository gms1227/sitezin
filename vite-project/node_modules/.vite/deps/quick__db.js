import {
  __commonJS,
  __publicField,
  __require
} from "./chunk-TCX6KGKM.js";

// node_modules/lodash/lodash.js
var require_lodash = __commonJS({
  "node_modules/lodash/lodash.js"(exports2, module2) {
    (function() {
      var undefined2;
      var VERSION = "4.17.21";
      var LARGE_ARRAY_SIZE = 200;
      var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      var MAX_MEMOIZE_SIZE = 500;
      var PLACEHOLDER = "__lodash_placeholder__";
      var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
      var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
      var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
      var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
      var HOT_COUNT = 800, HOT_SPAN = 16;
      var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
      var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
      var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
      var wrapFlags = [
        ["ary", WRAP_ARY_FLAG],
        ["bind", WRAP_BIND_FLAG],
        ["bindKey", WRAP_BIND_KEY_FLAG],
        ["curry", WRAP_CURRY_FLAG],
        ["curryRight", WRAP_CURRY_RIGHT_FLAG],
        ["flip", WRAP_FLIP_FLAG],
        ["partial", WRAP_PARTIAL_FLAG],
        ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
        ["rearg", WRAP_REARG_FLAG]
      ];
      var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
      var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
      var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
      var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
      var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
      var reTrimStart = /^\s+/;
      var reWhitespace = /\s/;
      var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
      var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
      var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
      var reEscapeChar = /\\(\\)?/g;
      var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
      var reFlags = /\w*$/;
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary = /^0b[01]+$/i;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var reIsOctal = /^0o[0-7]+$/i;
      var reIsUint = /^(?:0|[1-9]\d*)$/;
      var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
      var reNoMatch = /($^)/;
      var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
      var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
      var rsApos = "['’]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
      var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
      var reApos = RegExp(rsApos, "g");
      var reComboMark = RegExp(rsCombo, "g");
      var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
      var reUnicodeWord = RegExp([
        rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
        rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
        rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
        rsUpper + "+" + rsOptContrUpper,
        rsOrdUpper,
        rsOrdLower,
        rsDigits,
        rsEmoji
      ].join("|"), "g");
      var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
      var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
      var contextProps = [
        "Array",
        "Buffer",
        "DataView",
        "Date",
        "Error",
        "Float32Array",
        "Float64Array",
        "Function",
        "Int8Array",
        "Int16Array",
        "Int32Array",
        "Map",
        "Math",
        "Object",
        "Promise",
        "RegExp",
        "Set",
        "String",
        "Symbol",
        "TypeError",
        "Uint8Array",
        "Uint8ClampedArray",
        "Uint16Array",
        "Uint32Array",
        "WeakMap",
        "_",
        "clearTimeout",
        "isFinite",
        "parseInt",
        "setTimeout"
      ];
      var templateCounter = -1;
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
      var cloneableTags = {};
      cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
      cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
      var deburredLetters = {
        // Latin-1 Supplement block.
        "À": "A",
        "Á": "A",
        "Â": "A",
        "Ã": "A",
        "Ä": "A",
        "Å": "A",
        "à": "a",
        "á": "a",
        "â": "a",
        "ã": "a",
        "ä": "a",
        "å": "a",
        "Ç": "C",
        "ç": "c",
        "Ð": "D",
        "ð": "d",
        "È": "E",
        "É": "E",
        "Ê": "E",
        "Ë": "E",
        "è": "e",
        "é": "e",
        "ê": "e",
        "ë": "e",
        "Ì": "I",
        "Í": "I",
        "Î": "I",
        "Ï": "I",
        "ì": "i",
        "í": "i",
        "î": "i",
        "ï": "i",
        "Ñ": "N",
        "ñ": "n",
        "Ò": "O",
        "Ó": "O",
        "Ô": "O",
        "Õ": "O",
        "Ö": "O",
        "Ø": "O",
        "ò": "o",
        "ó": "o",
        "ô": "o",
        "õ": "o",
        "ö": "o",
        "ø": "o",
        "Ù": "U",
        "Ú": "U",
        "Û": "U",
        "Ü": "U",
        "ù": "u",
        "ú": "u",
        "û": "u",
        "ü": "u",
        "Ý": "Y",
        "ý": "y",
        "ÿ": "y",
        "Æ": "Ae",
        "æ": "ae",
        "Þ": "Th",
        "þ": "th",
        "ß": "ss",
        // Latin Extended-A block.
        "Ā": "A",
        "Ă": "A",
        "Ą": "A",
        "ā": "a",
        "ă": "a",
        "ą": "a",
        "Ć": "C",
        "Ĉ": "C",
        "Ċ": "C",
        "Č": "C",
        "ć": "c",
        "ĉ": "c",
        "ċ": "c",
        "č": "c",
        "Ď": "D",
        "Đ": "D",
        "ď": "d",
        "đ": "d",
        "Ē": "E",
        "Ĕ": "E",
        "Ė": "E",
        "Ę": "E",
        "Ě": "E",
        "ē": "e",
        "ĕ": "e",
        "ė": "e",
        "ę": "e",
        "ě": "e",
        "Ĝ": "G",
        "Ğ": "G",
        "Ġ": "G",
        "Ģ": "G",
        "ĝ": "g",
        "ğ": "g",
        "ġ": "g",
        "ģ": "g",
        "Ĥ": "H",
        "Ħ": "H",
        "ĥ": "h",
        "ħ": "h",
        "Ĩ": "I",
        "Ī": "I",
        "Ĭ": "I",
        "Į": "I",
        "İ": "I",
        "ĩ": "i",
        "ī": "i",
        "ĭ": "i",
        "į": "i",
        "ı": "i",
        "Ĵ": "J",
        "ĵ": "j",
        "Ķ": "K",
        "ķ": "k",
        "ĸ": "k",
        "Ĺ": "L",
        "Ļ": "L",
        "Ľ": "L",
        "Ŀ": "L",
        "Ł": "L",
        "ĺ": "l",
        "ļ": "l",
        "ľ": "l",
        "ŀ": "l",
        "ł": "l",
        "Ń": "N",
        "Ņ": "N",
        "Ň": "N",
        "Ŋ": "N",
        "ń": "n",
        "ņ": "n",
        "ň": "n",
        "ŋ": "n",
        "Ō": "O",
        "Ŏ": "O",
        "Ő": "O",
        "ō": "o",
        "ŏ": "o",
        "ő": "o",
        "Ŕ": "R",
        "Ŗ": "R",
        "Ř": "R",
        "ŕ": "r",
        "ŗ": "r",
        "ř": "r",
        "Ś": "S",
        "Ŝ": "S",
        "Ş": "S",
        "Š": "S",
        "ś": "s",
        "ŝ": "s",
        "ş": "s",
        "š": "s",
        "Ţ": "T",
        "Ť": "T",
        "Ŧ": "T",
        "ţ": "t",
        "ť": "t",
        "ŧ": "t",
        "Ũ": "U",
        "Ū": "U",
        "Ŭ": "U",
        "Ů": "U",
        "Ű": "U",
        "Ų": "U",
        "ũ": "u",
        "ū": "u",
        "ŭ": "u",
        "ů": "u",
        "ű": "u",
        "ų": "u",
        "Ŵ": "W",
        "ŵ": "w",
        "Ŷ": "Y",
        "ŷ": "y",
        "Ÿ": "Y",
        "Ź": "Z",
        "Ż": "Z",
        "Ž": "Z",
        "ź": "z",
        "ż": "z",
        "ž": "z",
        "Ĳ": "IJ",
        "ĳ": "ij",
        "Œ": "Oe",
        "œ": "oe",
        "ŉ": "'n",
        "ſ": "s"
      };
      var htmlEscapes = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;"
      };
      var htmlUnescapes = {
        "&amp;": "&",
        "&lt;": "<",
        "&gt;": ">",
        "&quot;": '"',
        "&#39;": "'"
      };
      var stringEscapes = {
        "\\": "\\",
        "'": "'",
        "\n": "n",
        "\r": "r",
        "\u2028": "u2028",
        "\u2029": "u2029"
      };
      var freeParseFloat = parseFloat, freeParseInt = parseInt;
      var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal || freeSelf || Function("return this")();
      var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
      var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var freeProcess = moduleExports && freeGlobal.process;
      var nodeUtil = function() {
        try {
          var types = freeModule && freeModule.require && freeModule.require("util").types;
          if (types) {
            return types;
          }
          return freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch (e) {
        }
      }();
      var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
      function apply(func, thisArg, args) {
        switch (args.length) {
          case 0:
            return func.call(thisArg);
          case 1:
            return func.call(thisArg, args[0]);
          case 2:
            return func.call(thisArg, args[0], args[1]);
          case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
      }
      function arrayAggregator(array, setter, iteratee, accumulator) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          var value = array[index];
          setter(accumulator, value, iteratee(value), array);
        }
        return accumulator;
      }
      function arrayEach(array, iteratee) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (iteratee(array[index], index, array) === false) {
            break;
          }
        }
        return array;
      }
      function arrayEachRight(array, iteratee) {
        var length = array == null ? 0 : array.length;
        while (length--) {
          if (iteratee(array[length], length, array) === false) {
            break;
          }
        }
        return array;
      }
      function arrayEvery(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (!predicate(array[index], index, array)) {
            return false;
          }
        }
        return true;
      }
      function arrayFilter(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
        while (++index < length) {
          var value = array[index];
          if (predicate(value, index, array)) {
            result[resIndex++] = value;
          }
        }
        return result;
      }
      function arrayIncludes(array, value) {
        var length = array == null ? 0 : array.length;
        return !!length && baseIndexOf(array, value, 0) > -1;
      }
      function arrayIncludesWith(array, value, comparator) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (comparator(value, array[index])) {
            return true;
          }
        }
        return false;
      }
      function arrayMap(array, iteratee) {
        var index = -1, length = array == null ? 0 : array.length, result = Array(length);
        while (++index < length) {
          result[index] = iteratee(array[index], index, array);
        }
        return result;
      }
      function arrayPush(array, values) {
        var index = -1, length = values.length, offset = array.length;
        while (++index < length) {
          array[offset + index] = values[index];
        }
        return array;
      }
      function arrayReduce(array, iteratee, accumulator, initAccum) {
        var index = -1, length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[++index];
        }
        while (++index < length) {
          accumulator = iteratee(accumulator, array[index], index, array);
        }
        return accumulator;
      }
      function arrayReduceRight(array, iteratee, accumulator, initAccum) {
        var length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[--length];
        }
        while (length--) {
          accumulator = iteratee(accumulator, array[length], length, array);
        }
        return accumulator;
      }
      function arraySome(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (predicate(array[index], index, array)) {
            return true;
          }
        }
        return false;
      }
      var asciiSize = baseProperty("length");
      function asciiToArray(string) {
        return string.split("");
      }
      function asciiWords(string) {
        return string.match(reAsciiWord) || [];
      }
      function baseFindKey(collection, predicate, eachFunc) {
        var result;
        eachFunc(collection, function(value, key, collection2) {
          if (predicate(value, key, collection2)) {
            result = key;
            return false;
          }
        });
        return result;
      }
      function baseFindIndex(array, predicate, fromIndex, fromRight) {
        var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
        while (fromRight ? index-- : ++index < length) {
          if (predicate(array[index], index, array)) {
            return index;
          }
        }
        return -1;
      }
      function baseIndexOf(array, value, fromIndex) {
        return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
      }
      function baseIndexOfWith(array, value, fromIndex, comparator) {
        var index = fromIndex - 1, length = array.length;
        while (++index < length) {
          if (comparator(array[index], value)) {
            return index;
          }
        }
        return -1;
      }
      function baseIsNaN(value) {
        return value !== value;
      }
      function baseMean(array, iteratee) {
        var length = array == null ? 0 : array.length;
        return length ? baseSum(array, iteratee) / length : NAN;
      }
      function baseProperty(key) {
        return function(object) {
          return object == null ? undefined2 : object[key];
        };
      }
      function basePropertyOf(object) {
        return function(key) {
          return object == null ? undefined2 : object[key];
        };
      }
      function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
        eachFunc(collection, function(value, index, collection2) {
          accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
        });
        return accumulator;
      }
      function baseSortBy(array, comparer) {
        var length = array.length;
        array.sort(comparer);
        while (length--) {
          array[length] = array[length].value;
        }
        return array;
      }
      function baseSum(array, iteratee) {
        var result, index = -1, length = array.length;
        while (++index < length) {
          var current = iteratee(array[index]);
          if (current !== undefined2) {
            result = result === undefined2 ? current : result + current;
          }
        }
        return result;
      }
      function baseTimes(n, iteratee) {
        var index = -1, result = Array(n);
        while (++index < n) {
          result[index] = iteratee(index);
        }
        return result;
      }
      function baseToPairs(object, props) {
        return arrayMap(props, function(key) {
          return [key, object[key]];
        });
      }
      function baseTrim(string) {
        return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
      }
      function baseUnary(func) {
        return function(value) {
          return func(value);
        };
      }
      function baseValues(object, props) {
        return arrayMap(props, function(key) {
          return object[key];
        });
      }
      function cacheHas(cache, key) {
        return cache.has(key);
      }
      function charsStartIndex(strSymbols, chrSymbols) {
        var index = -1, length = strSymbols.length;
        while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
        }
        return index;
      }
      function charsEndIndex(strSymbols, chrSymbols) {
        var index = strSymbols.length;
        while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
        }
        return index;
      }
      function countHolders(array, placeholder) {
        var length = array.length, result = 0;
        while (length--) {
          if (array[length] === placeholder) {
            ++result;
          }
        }
        return result;
      }
      var deburrLetter = basePropertyOf(deburredLetters);
      var escapeHtmlChar = basePropertyOf(htmlEscapes);
      function escapeStringChar(chr) {
        return "\\" + stringEscapes[chr];
      }
      function getValue(object, key) {
        return object == null ? undefined2 : object[key];
      }
      function hasUnicode(string) {
        return reHasUnicode.test(string);
      }
      function hasUnicodeWord(string) {
        return reHasUnicodeWord.test(string);
      }
      function iteratorToArray(iterator) {
        var data, result = [];
        while (!(data = iterator.next()).done) {
          result.push(data.value);
        }
        return result;
      }
      function mapToArray(map) {
        var index = -1, result = Array(map.size);
        map.forEach(function(value, key) {
          result[++index] = [key, value];
        });
        return result;
      }
      function overArg(func, transform) {
        return function(arg) {
          return func(transform(arg));
        };
      }
      function replaceHolders(array, placeholder) {
        var index = -1, length = array.length, resIndex = 0, result = [];
        while (++index < length) {
          var value = array[index];
          if (value === placeholder || value === PLACEHOLDER) {
            array[index] = PLACEHOLDER;
            result[resIndex++] = index;
          }
        }
        return result;
      }
      function setToArray(set) {
        var index = -1, result = Array(set.size);
        set.forEach(function(value) {
          result[++index] = value;
        });
        return result;
      }
      function setToPairs(set) {
        var index = -1, result = Array(set.size);
        set.forEach(function(value) {
          result[++index] = [value, value];
        });
        return result;
      }
      function strictIndexOf(array, value, fromIndex) {
        var index = fromIndex - 1, length = array.length;
        while (++index < length) {
          if (array[index] === value) {
            return index;
          }
        }
        return -1;
      }
      function strictLastIndexOf(array, value, fromIndex) {
        var index = fromIndex + 1;
        while (index--) {
          if (array[index] === value) {
            return index;
          }
        }
        return index;
      }
      function stringSize(string) {
        return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
      }
      function stringToArray(string) {
        return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
      }
      function trimmedEndIndex(string) {
        var index = string.length;
        while (index-- && reWhitespace.test(string.charAt(index))) {
        }
        return index;
      }
      var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
      function unicodeSize(string) {
        var result = reUnicode.lastIndex = 0;
        while (reUnicode.test(string)) {
          ++result;
        }
        return result;
      }
      function unicodeToArray(string) {
        return string.match(reUnicode) || [];
      }
      function unicodeWords(string) {
        return string.match(reUnicodeWord) || [];
      }
      var runInContext = function runInContext2(context) {
        context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));
        var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
        var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
        var coreJsData = context["__core-js_shared__"];
        var funcToString = funcProto.toString;
        var hasOwnProperty = objectProto.hasOwnProperty;
        var idCounter = 0;
        var maskSrcKey = function() {
          var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
          return uid ? "Symbol(src)_1." + uid : "";
        }();
        var nativeObjectToString = objectProto.toString;
        var objectCtorString = funcToString.call(Object2);
        var oldDash = root._;
        var reIsNative = RegExp2(
          "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
        );
        var Buffer2 = moduleExports ? context.Buffer : undefined2, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined2, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined2, symIterator = Symbol2 ? Symbol2.iterator : undefined2, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined2;
        var defineProperty = function() {
          try {
            var func = getNative(Object2, "defineProperty");
            func({}, "", {});
            return func;
          } catch (e) {
          }
        }();
        var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
        var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined2, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
        var DataView = getNative(context, "DataView"), Map2 = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set2 = getNative(context, "Set"), WeakMap2 = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
        var metaMap = WeakMap2 && new WeakMap2();
        var realNames = {};
        var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
        var symbolProto = Symbol2 ? Symbol2.prototype : undefined2, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined2, symbolToString = symbolProto ? symbolProto.toString : undefined2;
        function lodash(value) {
          if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
            if (value instanceof LodashWrapper) {
              return value;
            }
            if (hasOwnProperty.call(value, "__wrapped__")) {
              return wrapperClone(value);
            }
          }
          return new LodashWrapper(value);
        }
        var baseCreate = function() {
          function object() {
          }
          return function(proto) {
            if (!isObject2(proto)) {
              return {};
            }
            if (objectCreate) {
              return objectCreate(proto);
            }
            object.prototype = proto;
            var result2 = new object();
            object.prototype = undefined2;
            return result2;
          };
        }();
        function baseLodash() {
        }
        function LodashWrapper(value, chainAll) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__chain__ = !!chainAll;
          this.__index__ = 0;
          this.__values__ = undefined2;
        }
        lodash.templateSettings = {
          /**
           * Used to detect `data` property values to be HTML-escaped.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "escape": reEscape,
          /**
           * Used to detect code to be evaluated.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "evaluate": reEvaluate,
          /**
           * Used to detect `data` property values to inject.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "interpolate": reInterpolate,
          /**
           * Used to reference the data object in the template text.
           *
           * @memberOf _.templateSettings
           * @type {string}
           */
          "variable": "",
          /**
           * Used to import variables into the compiled template.
           *
           * @memberOf _.templateSettings
           * @type {Object}
           */
          "imports": {
            /**
             * A reference to the `lodash` function.
             *
             * @memberOf _.templateSettings.imports
             * @type {Function}
             */
            "_": lodash
          }
        };
        lodash.prototype = baseLodash.prototype;
        lodash.prototype.constructor = lodash;
        LodashWrapper.prototype = baseCreate(baseLodash.prototype);
        LodashWrapper.prototype.constructor = LodashWrapper;
        function LazyWrapper(value) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__dir__ = 1;
          this.__filtered__ = false;
          this.__iteratees__ = [];
          this.__takeCount__ = MAX_ARRAY_LENGTH;
          this.__views__ = [];
        }
        function lazyClone() {
          var result2 = new LazyWrapper(this.__wrapped__);
          result2.__actions__ = copyArray(this.__actions__);
          result2.__dir__ = this.__dir__;
          result2.__filtered__ = this.__filtered__;
          result2.__iteratees__ = copyArray(this.__iteratees__);
          result2.__takeCount__ = this.__takeCount__;
          result2.__views__ = copyArray(this.__views__);
          return result2;
        }
        function lazyReverse() {
          if (this.__filtered__) {
            var result2 = new LazyWrapper(this);
            result2.__dir__ = -1;
            result2.__filtered__ = true;
          } else {
            result2 = this.clone();
            result2.__dir__ *= -1;
          }
          return result2;
        }
        function lazyValue() {
          var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
          if (!isArr || !isRight && arrLength == length && takeCount == length) {
            return baseWrapperValue(array, this.__actions__);
          }
          var result2 = [];
          outer:
            while (length-- && resIndex < takeCount) {
              index += dir;
              var iterIndex = -1, value = array[index];
              while (++iterIndex < iterLength) {
                var data = iteratees[iterIndex], iteratee2 = data.iteratee, type = data.type, computed = iteratee2(value);
                if (type == LAZY_MAP_FLAG) {
                  value = computed;
                } else if (!computed) {
                  if (type == LAZY_FILTER_FLAG) {
                    continue outer;
                  } else {
                    break outer;
                  }
                }
              }
              result2[resIndex++] = value;
            }
          return result2;
        }
        LazyWrapper.prototype = baseCreate(baseLodash.prototype);
        LazyWrapper.prototype.constructor = LazyWrapper;
        function Hash(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function hashClear() {
          this.__data__ = nativeCreate ? nativeCreate(null) : {};
          this.size = 0;
        }
        function hashDelete(key) {
          var result2 = this.has(key) && delete this.__data__[key];
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function hashGet(key) {
          var data = this.__data__;
          if (nativeCreate) {
            var result2 = data[key];
            return result2 === HASH_UNDEFINED ? undefined2 : result2;
          }
          return hasOwnProperty.call(data, key) ? data[key] : undefined2;
        }
        function hashHas(key) {
          var data = this.__data__;
          return nativeCreate ? data[key] !== undefined2 : hasOwnProperty.call(data, key);
        }
        function hashSet(key, value) {
          var data = this.__data__;
          this.size += this.has(key) ? 0 : 1;
          data[key] = nativeCreate && value === undefined2 ? HASH_UNDEFINED : value;
          return this;
        }
        Hash.prototype.clear = hashClear;
        Hash.prototype["delete"] = hashDelete;
        Hash.prototype.get = hashGet;
        Hash.prototype.has = hashHas;
        Hash.prototype.set = hashSet;
        function ListCache(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function listCacheClear() {
          this.__data__ = [];
          this.size = 0;
        }
        function listCacheDelete(key) {
          var data = this.__data__, index = assocIndexOf(data, key);
          if (index < 0) {
            return false;
          }
          var lastIndex = data.length - 1;
          if (index == lastIndex) {
            data.pop();
          } else {
            splice.call(data, index, 1);
          }
          --this.size;
          return true;
        }
        function listCacheGet(key) {
          var data = this.__data__, index = assocIndexOf(data, key);
          return index < 0 ? undefined2 : data[index][1];
        }
        function listCacheHas(key) {
          return assocIndexOf(this.__data__, key) > -1;
        }
        function listCacheSet(key, value) {
          var data = this.__data__, index = assocIndexOf(data, key);
          if (index < 0) {
            ++this.size;
            data.push([key, value]);
          } else {
            data[index][1] = value;
          }
          return this;
        }
        ListCache.prototype.clear = listCacheClear;
        ListCache.prototype["delete"] = listCacheDelete;
        ListCache.prototype.get = listCacheGet;
        ListCache.prototype.has = listCacheHas;
        ListCache.prototype.set = listCacheSet;
        function MapCache(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function mapCacheClear() {
          this.size = 0;
          this.__data__ = {
            "hash": new Hash(),
            "map": new (Map2 || ListCache)(),
            "string": new Hash()
          };
        }
        function mapCacheDelete(key) {
          var result2 = getMapData(this, key)["delete"](key);
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function mapCacheGet(key) {
          return getMapData(this, key).get(key);
        }
        function mapCacheHas(key) {
          return getMapData(this, key).has(key);
        }
        function mapCacheSet(key, value) {
          var data = getMapData(this, key), size2 = data.size;
          data.set(key, value);
          this.size += data.size == size2 ? 0 : 1;
          return this;
        }
        MapCache.prototype.clear = mapCacheClear;
        MapCache.prototype["delete"] = mapCacheDelete;
        MapCache.prototype.get = mapCacheGet;
        MapCache.prototype.has = mapCacheHas;
        MapCache.prototype.set = mapCacheSet;
        function SetCache(values2) {
          var index = -1, length = values2 == null ? 0 : values2.length;
          this.__data__ = new MapCache();
          while (++index < length) {
            this.add(values2[index]);
          }
        }
        function setCacheAdd(value) {
          this.__data__.set(value, HASH_UNDEFINED);
          return this;
        }
        function setCacheHas(value) {
          return this.__data__.has(value);
        }
        SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
        SetCache.prototype.has = setCacheHas;
        function Stack(entries) {
          var data = this.__data__ = new ListCache(entries);
          this.size = data.size;
        }
        function stackClear() {
          this.__data__ = new ListCache();
          this.size = 0;
        }
        function stackDelete(key) {
          var data = this.__data__, result2 = data["delete"](key);
          this.size = data.size;
          return result2;
        }
        function stackGet(key) {
          return this.__data__.get(key);
        }
        function stackHas(key) {
          return this.__data__.has(key);
        }
        function stackSet(key, value) {
          var data = this.__data__;
          if (data instanceof ListCache) {
            var pairs = data.__data__;
            if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
              pairs.push([key, value]);
              this.size = ++data.size;
              return this;
            }
            data = this.__data__ = new MapCache(pairs);
          }
          data.set(key, value);
          this.size = data.size;
          return this;
        }
        Stack.prototype.clear = stackClear;
        Stack.prototype["delete"] = stackDelete;
        Stack.prototype.get = stackGet;
        Stack.prototype.has = stackHas;
        Stack.prototype.set = stackSet;
        function arrayLikeKeys(value, inherited) {
          var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length = result2.length;
          for (var key in value) {
            if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
            (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
            isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
            isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
            isIndex(key, length)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function arraySample(array) {
          var length = array.length;
          return length ? array[baseRandom(0, length - 1)] : undefined2;
        }
        function arraySampleSize(array, n) {
          return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
        }
        function arrayShuffle(array) {
          return shuffleSelf(copyArray(array));
        }
        function assignMergeValue(object, key, value) {
          if (value !== undefined2 && !eq(object[key], value) || value === undefined2 && !(key in object)) {
            baseAssignValue(object, key, value);
          }
        }
        function assignValue(object, key, value) {
          var objValue = object[key];
          if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined2 && !(key in object)) {
            baseAssignValue(object, key, value);
          }
        }
        function assocIndexOf(array, key) {
          var length = array.length;
          while (length--) {
            if (eq(array[length][0], key)) {
              return length;
            }
          }
          return -1;
        }
        function baseAggregator(collection, setter, iteratee2, accumulator) {
          baseEach(collection, function(value, key, collection2) {
            setter(accumulator, value, iteratee2(value), collection2);
          });
          return accumulator;
        }
        function baseAssign(object, source) {
          return object && copyObject(source, keys(source), object);
        }
        function baseAssignIn(object, source) {
          return object && copyObject(source, keysIn(source), object);
        }
        function baseAssignValue(object, key, value) {
          if (key == "__proto__" && defineProperty) {
            defineProperty(object, key, {
              "configurable": true,
              "enumerable": true,
              "value": value,
              "writable": true
            });
          } else {
            object[key] = value;
          }
        }
        function baseAt(object, paths) {
          var index = -1, length = paths.length, result2 = Array2(length), skip = object == null;
          while (++index < length) {
            result2[index] = skip ? undefined2 : get(object, paths[index]);
          }
          return result2;
        }
        function baseClamp(number, lower, upper) {
          if (number === number) {
            if (upper !== undefined2) {
              number = number <= upper ? number : upper;
            }
            if (lower !== undefined2) {
              number = number >= lower ? number : lower;
            }
          }
          return number;
        }
        function baseClone(value, bitmask, customizer, key, object, stack) {
          var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
          if (customizer) {
            result2 = object ? customizer(value, key, object, stack) : customizer(value);
          }
          if (result2 !== undefined2) {
            return result2;
          }
          if (!isObject2(value)) {
            return value;
          }
          var isArr = isArray(value);
          if (isArr) {
            result2 = initCloneArray(value);
            if (!isDeep) {
              return copyArray(value, result2);
            }
          } else {
            var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
            if (isBuffer(value)) {
              return cloneBuffer(value, isDeep);
            }
            if (tag == objectTag || tag == argsTag || isFunc && !object) {
              result2 = isFlat || isFunc ? {} : initCloneObject(value);
              if (!isDeep) {
                return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
              }
            } else {
              if (!cloneableTags[tag]) {
                return object ? value : {};
              }
              result2 = initCloneByTag(value, tag, isDeep);
            }
          }
          stack || (stack = new Stack());
          var stacked = stack.get(value);
          if (stacked) {
            return stacked;
          }
          stack.set(value, result2);
          if (isSet(value)) {
            value.forEach(function(subValue) {
              result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
            });
          } else if (isMap(value)) {
            value.forEach(function(subValue, key2) {
              result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
            });
          }
          var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
          var props = isArr ? undefined2 : keysFunc(value);
          arrayEach(props || value, function(subValue, key2) {
            if (props) {
              key2 = subValue;
              subValue = value[key2];
            }
            assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
          });
          return result2;
        }
        function baseConforms(source) {
          var props = keys(source);
          return function(object) {
            return baseConformsTo(object, source, props);
          };
        }
        function baseConformsTo(object, source, props) {
          var length = props.length;
          if (object == null) {
            return !length;
          }
          object = Object2(object);
          while (length--) {
            var key = props[length], predicate = source[key], value = object[key];
            if (value === undefined2 && !(key in object) || !predicate(value)) {
              return false;
            }
          }
          return true;
        }
        function baseDelay(func, wait, args) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return setTimeout2(function() {
            func.apply(undefined2, args);
          }, wait);
        }
        function baseDifference(array, values2, iteratee2, comparator) {
          var index = -1, includes2 = arrayIncludes, isCommon = true, length = array.length, result2 = [], valuesLength = values2.length;
          if (!length) {
            return result2;
          }
          if (iteratee2) {
            values2 = arrayMap(values2, baseUnary(iteratee2));
          }
          if (comparator) {
            includes2 = arrayIncludesWith;
            isCommon = false;
          } else if (values2.length >= LARGE_ARRAY_SIZE) {
            includes2 = cacheHas;
            isCommon = false;
            values2 = new SetCache(values2);
          }
          outer:
            while (++index < length) {
              var value = array[index], computed = iteratee2 == null ? value : iteratee2(value);
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var valuesIndex = valuesLength;
                while (valuesIndex--) {
                  if (values2[valuesIndex] === computed) {
                    continue outer;
                  }
                }
                result2.push(value);
              } else if (!includes2(values2, computed, comparator)) {
                result2.push(value);
              }
            }
          return result2;
        }
        var baseEach = createBaseEach(baseForOwn);
        var baseEachRight = createBaseEach(baseForOwnRight, true);
        function baseEvery(collection, predicate) {
          var result2 = true;
          baseEach(collection, function(value, index, collection2) {
            result2 = !!predicate(value, index, collection2);
            return result2;
          });
          return result2;
        }
        function baseExtremum(array, iteratee2, comparator) {
          var index = -1, length = array.length;
          while (++index < length) {
            var value = array[index], current = iteratee2(value);
            if (current != null && (computed === undefined2 ? current === current && !isSymbol(current) : comparator(current, computed))) {
              var computed = current, result2 = value;
            }
          }
          return result2;
        }
        function baseFill(array, value, start, end) {
          var length = array.length;
          start = toInteger(start);
          if (start < 0) {
            start = -start > length ? 0 : length + start;
          }
          end = end === undefined2 || end > length ? length : toInteger(end);
          if (end < 0) {
            end += length;
          }
          end = start > end ? 0 : toLength(end);
          while (start < end) {
            array[start++] = value;
          }
          return array;
        }
        function baseFilter(collection, predicate) {
          var result2 = [];
          baseEach(collection, function(value, index, collection2) {
            if (predicate(value, index, collection2)) {
              result2.push(value);
            }
          });
          return result2;
        }
        function baseFlatten(array, depth, predicate, isStrict, result2) {
          var index = -1, length = array.length;
          predicate || (predicate = isFlattenable);
          result2 || (result2 = []);
          while (++index < length) {
            var value = array[index];
            if (depth > 0 && predicate(value)) {
              if (depth > 1) {
                baseFlatten(value, depth - 1, predicate, isStrict, result2);
              } else {
                arrayPush(result2, value);
              }
            } else if (!isStrict) {
              result2[result2.length] = value;
            }
          }
          return result2;
        }
        var baseFor = createBaseFor();
        var baseForRight = createBaseFor(true);
        function baseForOwn(object, iteratee2) {
          return object && baseFor(object, iteratee2, keys);
        }
        function baseForOwnRight(object, iteratee2) {
          return object && baseForRight(object, iteratee2, keys);
        }
        function baseFunctions(object, props) {
          return arrayFilter(props, function(key) {
            return isFunction(object[key]);
          });
        }
        function baseGet(object, path) {
          path = castPath(path, object);
          var index = 0, length = path.length;
          while (object != null && index < length) {
            object = object[toKey(path[index++])];
          }
          return index && index == length ? object : undefined2;
        }
        function baseGetAllKeys(object, keysFunc, symbolsFunc) {
          var result2 = keysFunc(object);
          return isArray(object) ? result2 : arrayPush(result2, symbolsFunc(object));
        }
        function baseGetTag(value) {
          if (value == null) {
            return value === undefined2 ? undefinedTag : nullTag;
          }
          return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);
        }
        function baseGt(value, other) {
          return value > other;
        }
        function baseHas(object, key) {
          return object != null && hasOwnProperty.call(object, key);
        }
        function baseHasIn(object, key) {
          return object != null && key in Object2(object);
        }
        function baseInRange(number, start, end) {
          return number >= nativeMin(start, end) && number < nativeMax(start, end);
        }
        function baseIntersection(arrays, iteratee2, comparator) {
          var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
          while (othIndex--) {
            var array = arrays[othIndex];
            if (othIndex && iteratee2) {
              array = arrayMap(array, baseUnary(iteratee2));
            }
            maxLength = nativeMin(array.length, maxLength);
            caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined2;
          }
          array = arrays[0];
          var index = -1, seen = caches[0];
          outer:
            while (++index < length && result2.length < maxLength) {
              var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (!(seen ? cacheHas(seen, computed) : includes2(result2, computed, comparator))) {
                othIndex = othLength;
                while (--othIndex) {
                  var cache = caches[othIndex];
                  if (!(cache ? cacheHas(cache, computed) : includes2(arrays[othIndex], computed, comparator))) {
                    continue outer;
                  }
                }
                if (seen) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseInverter(object, setter, iteratee2, accumulator) {
          baseForOwn(object, function(value, key, object2) {
            setter(accumulator, iteratee2(value), key, object2);
          });
          return accumulator;
        }
        function baseInvoke(object, path, args) {
          path = castPath(path, object);
          object = parent(object, path);
          var func = object == null ? object : object[toKey(last(path))];
          return func == null ? undefined2 : apply(func, object, args);
        }
        function baseIsArguments(value) {
          return isObjectLike(value) && baseGetTag(value) == argsTag;
        }
        function baseIsArrayBuffer(value) {
          return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
        }
        function baseIsDate(value) {
          return isObjectLike(value) && baseGetTag(value) == dateTag;
        }
        function baseIsEqual(value, other, bitmask, customizer, stack) {
          if (value === other) {
            return true;
          }
          if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
            return value !== value && other !== other;
          }
          return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
        }
        function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
          var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
          objTag = objTag == argsTag ? objectTag : objTag;
          othTag = othTag == argsTag ? objectTag : othTag;
          var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
          if (isSameTag && isBuffer(object)) {
            if (!isBuffer(other)) {
              return false;
            }
            objIsArr = true;
            objIsObj = false;
          }
          if (isSameTag && !objIsObj) {
            stack || (stack = new Stack());
            return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
          }
          if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
            var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
            if (objIsWrapped || othIsWrapped) {
              var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
              stack || (stack = new Stack());
              return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
            }
          }
          if (!isSameTag) {
            return false;
          }
          stack || (stack = new Stack());
          return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
        }
        function baseIsMap(value) {
          return isObjectLike(value) && getTag(value) == mapTag;
        }
        function baseIsMatch(object, source, matchData, customizer) {
          var index = matchData.length, length = index, noCustomizer = !customizer;
          if (object == null) {
            return !length;
          }
          object = Object2(object);
          while (index--) {
            var data = matchData[index];
            if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
              return false;
            }
          }
          while (++index < length) {
            data = matchData[index];
            var key = data[0], objValue = object[key], srcValue = data[1];
            if (noCustomizer && data[2]) {
              if (objValue === undefined2 && !(key in object)) {
                return false;
              }
            } else {
              var stack = new Stack();
              if (customizer) {
                var result2 = customizer(objValue, srcValue, key, object, source, stack);
              }
              if (!(result2 === undefined2 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
                return false;
              }
            }
          }
          return true;
        }
        function baseIsNative(value) {
          if (!isObject2(value) || isMasked(value)) {
            return false;
          }
          var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
          return pattern.test(toSource(value));
        }
        function baseIsRegExp(value) {
          return isObjectLike(value) && baseGetTag(value) == regexpTag;
        }
        function baseIsSet(value) {
          return isObjectLike(value) && getTag(value) == setTag;
        }
        function baseIsTypedArray(value) {
          return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
        }
        function baseIteratee(value) {
          if (typeof value == "function") {
            return value;
          }
          if (value == null) {
            return identity;
          }
          if (typeof value == "object") {
            return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
          }
          return property(value);
        }
        function baseKeys(object) {
          if (!isPrototype(object)) {
            return nativeKeys(object);
          }
          var result2 = [];
          for (var key in Object2(object)) {
            if (hasOwnProperty.call(object, key) && key != "constructor") {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseKeysIn(object) {
          if (!isObject2(object)) {
            return nativeKeysIn(object);
          }
          var isProto = isPrototype(object), result2 = [];
          for (var key in object) {
            if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseLt(value, other) {
          return value < other;
        }
        function baseMap(collection, iteratee2) {
          var index = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value, key, collection2) {
            result2[++index] = iteratee2(value, key, collection2);
          });
          return result2;
        }
        function baseMatches(source) {
          var matchData = getMatchData(source);
          if (matchData.length == 1 && matchData[0][2]) {
            return matchesStrictComparable(matchData[0][0], matchData[0][1]);
          }
          return function(object) {
            return object === source || baseIsMatch(object, source, matchData);
          };
        }
        function baseMatchesProperty(path, srcValue) {
          if (isKey(path) && isStrictComparable(srcValue)) {
            return matchesStrictComparable(toKey(path), srcValue);
          }
          return function(object) {
            var objValue = get(object, path);
            return objValue === undefined2 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
          };
        }
        function baseMerge(object, source, srcIndex, customizer, stack) {
          if (object === source) {
            return;
          }
          baseFor(source, function(srcValue, key) {
            stack || (stack = new Stack());
            if (isObject2(srcValue)) {
              baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
            } else {
              var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined2;
              if (newValue === undefined2) {
                newValue = srcValue;
              }
              assignMergeValue(object, key, newValue);
            }
          }, keysIn);
        }
        function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
          var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
          if (stacked) {
            assignMergeValue(object, key, stacked);
            return;
          }
          var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined2;
          var isCommon = newValue === undefined2;
          if (isCommon) {
            var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
            newValue = srcValue;
            if (isArr || isBuff || isTyped) {
              if (isArray(objValue)) {
                newValue = objValue;
              } else if (isArrayLikeObject(objValue)) {
                newValue = copyArray(objValue);
              } else if (isBuff) {
                isCommon = false;
                newValue = cloneBuffer(srcValue, true);
              } else if (isTyped) {
                isCommon = false;
                newValue = cloneTypedArray(srcValue, true);
              } else {
                newValue = [];
              }
            } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
              newValue = objValue;
              if (isArguments(objValue)) {
                newValue = toPlainObject(objValue);
              } else if (!isObject2(objValue) || isFunction(objValue)) {
                newValue = initCloneObject(srcValue);
              }
            } else {
              isCommon = false;
            }
          }
          if (isCommon) {
            stack.set(srcValue, newValue);
            mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
            stack["delete"](srcValue);
          }
          assignMergeValue(object, key, newValue);
        }
        function baseNth(array, n) {
          var length = array.length;
          if (!length) {
            return;
          }
          n += n < 0 ? length : 0;
          return isIndex(n, length) ? array[n] : undefined2;
        }
        function baseOrderBy(collection, iteratees, orders) {
          if (iteratees.length) {
            iteratees = arrayMap(iteratees, function(iteratee2) {
              if (isArray(iteratee2)) {
                return function(value) {
                  return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
                };
              }
              return iteratee2;
            });
          } else {
            iteratees = [identity];
          }
          var index = -1;
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
          var result2 = baseMap(collection, function(value, key, collection2) {
            var criteria = arrayMap(iteratees, function(iteratee2) {
              return iteratee2(value);
            });
            return { "criteria": criteria, "index": ++index, "value": value };
          });
          return baseSortBy(result2, function(object, other) {
            return compareMultiple(object, other, orders);
          });
        }
        function basePick(object, paths) {
          return basePickBy(object, paths, function(value, path) {
            return hasIn(object, path);
          });
        }
        function basePickBy(object, paths, predicate) {
          var index = -1, length = paths.length, result2 = {};
          while (++index < length) {
            var path = paths[index], value = baseGet(object, path);
            if (predicate(value, path)) {
              baseSet(result2, castPath(path, object), value);
            }
          }
          return result2;
        }
        function basePropertyDeep(path) {
          return function(object) {
            return baseGet(object, path);
          };
        }
        function basePullAll(array, values2, iteratee2, comparator) {
          var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values2.length, seen = array;
          if (array === values2) {
            values2 = copyArray(values2);
          }
          if (iteratee2) {
            seen = arrayMap(array, baseUnary(iteratee2));
          }
          while (++index < length) {
            var fromIndex = 0, value = values2[index], computed = iteratee2 ? iteratee2(value) : value;
            while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
              if (seen !== array) {
                splice.call(seen, fromIndex, 1);
              }
              splice.call(array, fromIndex, 1);
            }
          }
          return array;
        }
        function basePullAt(array, indexes) {
          var length = array ? indexes.length : 0, lastIndex = length - 1;
          while (length--) {
            var index = indexes[length];
            if (length == lastIndex || index !== previous) {
              var previous = index;
              if (isIndex(index)) {
                splice.call(array, index, 1);
              } else {
                baseUnset(array, index);
              }
            }
          }
          return array;
        }
        function baseRandom(lower, upper) {
          return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
        }
        function baseRange(start, end, step, fromRight) {
          var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result2 = Array2(length);
          while (length--) {
            result2[fromRight ? length : ++index] = start;
            start += step;
          }
          return result2;
        }
        function baseRepeat(string, n) {
          var result2 = "";
          if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
            return result2;
          }
          do {
            if (n % 2) {
              result2 += string;
            }
            n = nativeFloor(n / 2);
            if (n) {
              string += string;
            }
          } while (n);
          return result2;
        }
        function baseRest(func, start) {
          return setToString(overRest(func, start, identity), func + "");
        }
        function baseSample(collection) {
          return arraySample(values(collection));
        }
        function baseSampleSize(collection, n) {
          var array = values(collection);
          return shuffleSelf(array, baseClamp(n, 0, array.length));
        }
        function baseSet(object, path, value, customizer) {
          if (!isObject2(object)) {
            return object;
          }
          path = castPath(path, object);
          var index = -1, length = path.length, lastIndex = length - 1, nested = object;
          while (nested != null && ++index < length) {
            var key = toKey(path[index]), newValue = value;
            if (key === "__proto__" || key === "constructor" || key === "prototype") {
              return object;
            }
            if (index != lastIndex) {
              var objValue = nested[key];
              newValue = customizer ? customizer(objValue, key, nested) : undefined2;
              if (newValue === undefined2) {
                newValue = isObject2(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
              }
            }
            assignValue(nested, key, newValue);
            nested = nested[key];
          }
          return object;
        }
        var baseSetData = !metaMap ? identity : function(func, data) {
          metaMap.set(func, data);
          return func;
        };
        var baseSetToString = !defineProperty ? identity : function(func, string) {
          return defineProperty(func, "toString", {
            "configurable": true,
            "enumerable": false,
            "value": constant(string),
            "writable": true
          });
        };
        function baseShuffle(collection) {
          return shuffleSelf(values(collection));
        }
        function baseSlice(array, start, end) {
          var index = -1, length = array.length;
          if (start < 0) {
            start = -start > length ? 0 : length + start;
          }
          end = end > length ? length : end;
          if (end < 0) {
            end += length;
          }
          length = start > end ? 0 : end - start >>> 0;
          start >>>= 0;
          var result2 = Array2(length);
          while (++index < length) {
            result2[index] = array[index + start];
          }
          return result2;
        }
        function baseSome(collection, predicate) {
          var result2;
          baseEach(collection, function(value, index, collection2) {
            result2 = predicate(value, index, collection2);
            return !result2;
          });
          return !!result2;
        }
        function baseSortedIndex(array, value, retHighest) {
          var low = 0, high = array == null ? low : array.length;
          if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
            while (low < high) {
              var mid = low + high >>> 1, computed = array[mid];
              if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return high;
          }
          return baseSortedIndexBy(array, value, identity, retHighest);
        }
        function baseSortedIndexBy(array, value, iteratee2, retHighest) {
          var low = 0, high = array == null ? 0 : array.length;
          if (high === 0) {
            return 0;
          }
          value = iteratee2(value);
          var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined2;
          while (low < high) {
            var mid = nativeFloor((low + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== undefined2, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
            if (valIsNaN) {
              var setLow = retHighest || othIsReflexive;
            } else if (valIsUndefined) {
              setLow = othIsReflexive && (retHighest || othIsDefined);
            } else if (valIsNull) {
              setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
            } else if (valIsSymbol) {
              setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
            } else if (othIsNull || othIsSymbol) {
              setLow = false;
            } else {
              setLow = retHighest ? computed <= value : computed < value;
            }
            if (setLow) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return nativeMin(high, MAX_ARRAY_INDEX);
        }
        function baseSortedUniq(array, iteratee2) {
          var index = -1, length = array.length, resIndex = 0, result2 = [];
          while (++index < length) {
            var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
            if (!index || !eq(computed, seen)) {
              var seen = computed;
              result2[resIndex++] = value === 0 ? 0 : value;
            }
          }
          return result2;
        }
        function baseToNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          return +value;
        }
        function baseToString(value) {
          if (typeof value == "string") {
            return value;
          }
          if (isArray(value)) {
            return arrayMap(value, baseToString) + "";
          }
          if (isSymbol(value)) {
            return symbolToString ? symbolToString.call(value) : "";
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function baseUniq(array, iteratee2, comparator) {
          var index = -1, includes2 = arrayIncludes, length = array.length, isCommon = true, result2 = [], seen = result2;
          if (comparator) {
            isCommon = false;
            includes2 = arrayIncludesWith;
          } else if (length >= LARGE_ARRAY_SIZE) {
            var set2 = iteratee2 ? null : createSet(array);
            if (set2) {
              return setToArray(set2);
            }
            isCommon = false;
            includes2 = cacheHas;
            seen = new SetCache();
          } else {
            seen = iteratee2 ? [] : result2;
          }
          outer:
            while (++index < length) {
              var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var seenIndex = seen.length;
                while (seenIndex--) {
                  if (seen[seenIndex] === computed) {
                    continue outer;
                  }
                }
                if (iteratee2) {
                  seen.push(computed);
                }
                result2.push(value);
              } else if (!includes2(seen, computed, comparator)) {
                if (seen !== result2) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseUnset(object, path) {
          path = castPath(path, object);
          object = parent(object, path);
          return object == null || delete object[toKey(last(path))];
        }
        function baseUpdate(object, path, updater, customizer) {
          return baseSet(object, path, updater(baseGet(object, path)), customizer);
        }
        function baseWhile(array, predicate, isDrop, fromRight) {
          var length = array.length, index = fromRight ? length : -1;
          while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {
          }
          return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index);
        }
        function baseWrapperValue(value, actions) {
          var result2 = value;
          if (result2 instanceof LazyWrapper) {
            result2 = result2.value();
          }
          return arrayReduce(actions, function(result3, action) {
            return action.func.apply(action.thisArg, arrayPush([result3], action.args));
          }, result2);
        }
        function baseXor(arrays, iteratee2, comparator) {
          var length = arrays.length;
          if (length < 2) {
            return length ? baseUniq(arrays[0]) : [];
          }
          var index = -1, result2 = Array2(length);
          while (++index < length) {
            var array = arrays[index], othIndex = -1;
            while (++othIndex < length) {
              if (othIndex != index) {
                result2[index] = baseDifference(result2[index] || array, arrays[othIndex], iteratee2, comparator);
              }
            }
          }
          return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
        }
        function baseZipObject(props, values2, assignFunc) {
          var index = -1, length = props.length, valsLength = values2.length, result2 = {};
          while (++index < length) {
            var value = index < valsLength ? values2[index] : undefined2;
            assignFunc(result2, props[index], value);
          }
          return result2;
        }
        function castArrayLikeObject(value) {
          return isArrayLikeObject(value) ? value : [];
        }
        function castFunction(value) {
          return typeof value == "function" ? value : identity;
        }
        function castPath(value, object) {
          if (isArray(value)) {
            return value;
          }
          return isKey(value, object) ? [value] : stringToPath(toString(value));
        }
        var castRest = baseRest;
        function castSlice(array, start, end) {
          var length = array.length;
          end = end === undefined2 ? length : end;
          return !start && end >= length ? array : baseSlice(array, start, end);
        }
        var clearTimeout2 = ctxClearTimeout || function(id) {
          return root.clearTimeout(id);
        };
        function cloneBuffer(buffer, isDeep) {
          if (isDeep) {
            return buffer.slice();
          }
          var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
          buffer.copy(result2);
          return result2;
        }
        function cloneArrayBuffer(arrayBuffer) {
          var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
          new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
          return result2;
        }
        function cloneDataView(dataView, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
          return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
        }
        function cloneRegExp(regexp) {
          var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
          result2.lastIndex = regexp.lastIndex;
          return result2;
        }
        function cloneSymbol(symbol) {
          return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
        }
        function cloneTypedArray(typedArray, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
          return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
        }
        function compareAscending(value, other) {
          if (value !== other) {
            var valIsDefined = value !== undefined2, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
            var othIsDefined = other !== undefined2, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
            if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
              return 1;
            }
            if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
              return -1;
            }
          }
          return 0;
        }
        function compareMultiple(object, other, orders) {
          var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
          while (++index < length) {
            var result2 = compareAscending(objCriteria[index], othCriteria[index]);
            if (result2) {
              if (index >= ordersLength) {
                return result2;
              }
              var order = orders[index];
              return result2 * (order == "desc" ? -1 : 1);
            }
          }
          return object.index - other.index;
        }
        function composeArgs(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
          while (++leftIndex < leftLength) {
            result2[leftIndex] = partials[leftIndex];
          }
          while (++argsIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[holders[argsIndex]] = args[argsIndex];
            }
          }
          while (rangeLength--) {
            result2[leftIndex++] = args[argsIndex++];
          }
          return result2;
        }
        function composeArgsRight(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
          while (++argsIndex < rangeLength) {
            result2[argsIndex] = args[argsIndex];
          }
          var offset = argsIndex;
          while (++rightIndex < rightLength) {
            result2[offset + rightIndex] = partials[rightIndex];
          }
          while (++holdersIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[offset + holders[holdersIndex]] = args[argsIndex++];
            }
          }
          return result2;
        }
        function copyArray(source, array) {
          var index = -1, length = source.length;
          array || (array = Array2(length));
          while (++index < length) {
            array[index] = source[index];
          }
          return array;
        }
        function copyObject(source, props, object, customizer) {
          var isNew = !object;
          object || (object = {});
          var index = -1, length = props.length;
          while (++index < length) {
            var key = props[index];
            var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined2;
            if (newValue === undefined2) {
              newValue = source[key];
            }
            if (isNew) {
              baseAssignValue(object, key, newValue);
            } else {
              assignValue(object, key, newValue);
            }
          }
          return object;
        }
        function copySymbols(source, object) {
          return copyObject(source, getSymbols(source), object);
        }
        function copySymbolsIn(source, object) {
          return copyObject(source, getSymbolsIn(source), object);
        }
        function createAggregator(setter, initializer) {
          return function(collection, iteratee2) {
            var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
            return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
          };
        }
        function createAssigner(assigner) {
          return baseRest(function(object, sources) {
            var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined2, guard = length > 2 ? sources[2] : undefined2;
            customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined2;
            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              customizer = length < 3 ? undefined2 : customizer;
              length = 1;
            }
            object = Object2(object);
            while (++index < length) {
              var source = sources[index];
              if (source) {
                assigner(object, source, index, customizer);
              }
            }
            return object;
          });
        }
        function createBaseEach(eachFunc, fromRight) {
          return function(collection, iteratee2) {
            if (collection == null) {
              return collection;
            }
            if (!isArrayLike(collection)) {
              return eachFunc(collection, iteratee2);
            }
            var length = collection.length, index = fromRight ? length : -1, iterable = Object2(collection);
            while (fromRight ? index-- : ++index < length) {
              if (iteratee2(iterable[index], index, iterable) === false) {
                break;
              }
            }
            return collection;
          };
        }
        function createBaseFor(fromRight) {
          return function(object, iteratee2, keysFunc) {
            var index = -1, iterable = Object2(object), props = keysFunc(object), length = props.length;
            while (length--) {
              var key = props[fromRight ? length : ++index];
              if (iteratee2(iterable[key], key, iterable) === false) {
                break;
              }
            }
            return object;
          };
        }
        function createBind(func, bitmask, thisArg) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            return fn.apply(isBind ? thisArg : this, arguments);
          }
          return wrapper;
        }
        function createCaseFirst(methodName) {
          return function(string) {
            string = toString(string);
            var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined2;
            var chr = strSymbols ? strSymbols[0] : string.charAt(0);
            var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
            return chr[methodName]() + trailing;
          };
        }
        function createCompounder(callback) {
          return function(string) {
            return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
          };
        }
        function createCtor(Ctor) {
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return new Ctor();
              case 1:
                return new Ctor(args[0]);
              case 2:
                return new Ctor(args[0], args[1]);
              case 3:
                return new Ctor(args[0], args[1], args[2]);
              case 4:
                return new Ctor(args[0], args[1], args[2], args[3]);
              case 5:
                return new Ctor(args[0], args[1], args[2], args[3], args[4]);
              case 6:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
              case 7:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
            }
            var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
            return isObject2(result2) ? result2 : thisBinding;
          };
        }
        function createCurry(func, bitmask, arity) {
          var Ctor = createCtor(func);
          function wrapper() {
            var length = arguments.length, args = Array2(length), index = length, placeholder = getHolder(wrapper);
            while (index--) {
              args[index] = arguments[index];
            }
            var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
            length -= holders.length;
            if (length < arity) {
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                undefined2,
                args,
                holders,
                undefined2,
                undefined2,
                arity - length
              );
            }
            var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            return apply(fn, this, args);
          }
          return wrapper;
        }
        function createFind(findIndexFunc) {
          return function(collection, predicate, fromIndex) {
            var iterable = Object2(collection);
            if (!isArrayLike(collection)) {
              var iteratee2 = getIteratee(predicate, 3);
              collection = keys(collection);
              predicate = function(key) {
                return iteratee2(iterable[key], key, iterable);
              };
            }
            var index = findIndexFunc(collection, predicate, fromIndex);
            return index > -1 ? iterable[iteratee2 ? collection[index] : index] : undefined2;
          };
        }
        function createFlow(fromRight) {
          return flatRest(function(funcs) {
            var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
            if (fromRight) {
              funcs.reverse();
            }
            while (index--) {
              var func = funcs[index];
              if (typeof func != "function") {
                throw new TypeError2(FUNC_ERROR_TEXT);
              }
              if (prereq && !wrapper && getFuncName(func) == "wrapper") {
                var wrapper = new LodashWrapper([], true);
              }
            }
            index = wrapper ? index : length;
            while (++index < length) {
              func = funcs[index];
              var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined2;
              if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
                wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
              } else {
                wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
              }
            }
            return function() {
              var args = arguments, value = args[0];
              if (wrapper && args.length == 1 && isArray(value)) {
                return wrapper.plant(value).value();
              }
              var index2 = 0, result2 = length ? funcs[index2].apply(this, args) : value;
              while (++index2 < length) {
                result2 = funcs[index2].call(this, result2);
              }
              return result2;
            };
          });
        }
        function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
          var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined2 : createCtor(func);
          function wrapper() {
            var length = arguments.length, args = Array2(length), index = length;
            while (index--) {
              args[index] = arguments[index];
            }
            if (isCurried) {
              var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
            }
            if (partials) {
              args = composeArgs(args, partials, holders, isCurried);
            }
            if (partialsRight) {
              args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
            }
            length -= holdersCount;
            if (isCurried && length < arity) {
              var newHolders = replaceHolders(args, placeholder);
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                thisArg,
                args,
                newHolders,
                argPos,
                ary2,
                arity - length
              );
            }
            var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
            length = args.length;
            if (argPos) {
              args = reorder(args, argPos);
            } else if (isFlip && length > 1) {
              args.reverse();
            }
            if (isAry && ary2 < length) {
              args.length = ary2;
            }
            if (this && this !== root && this instanceof wrapper) {
              fn = Ctor || createCtor(fn);
            }
            return fn.apply(thisBinding, args);
          }
          return wrapper;
        }
        function createInverter(setter, toIteratee) {
          return function(object, iteratee2) {
            return baseInverter(object, setter, toIteratee(iteratee2), {});
          };
        }
        function createMathOperation(operator, defaultValue) {
          return function(value, other) {
            var result2;
            if (value === undefined2 && other === undefined2) {
              return defaultValue;
            }
            if (value !== undefined2) {
              result2 = value;
            }
            if (other !== undefined2) {
              if (result2 === undefined2) {
                return other;
              }
              if (typeof value == "string" || typeof other == "string") {
                value = baseToString(value);
                other = baseToString(other);
              } else {
                value = baseToNumber(value);
                other = baseToNumber(other);
              }
              result2 = operator(value, other);
            }
            return result2;
          };
        }
        function createOver(arrayFunc) {
          return flatRest(function(iteratees) {
            iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
            return baseRest(function(args) {
              var thisArg = this;
              return arrayFunc(iteratees, function(iteratee2) {
                return apply(iteratee2, thisArg, args);
              });
            });
          });
        }
        function createPadding(length, chars) {
          chars = chars === undefined2 ? " " : baseToString(chars);
          var charsLength = chars.length;
          if (charsLength < 2) {
            return charsLength ? baseRepeat(chars, length) : chars;
          }
          var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
          return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
        }
        function createPartial(func, bitmask, thisArg, partials) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            while (++leftIndex < leftLength) {
              args[leftIndex] = partials[leftIndex];
            }
            while (argsLength--) {
              args[leftIndex++] = arguments[++argsIndex];
            }
            return apply(fn, isBind ? thisArg : this, args);
          }
          return wrapper;
        }
        function createRange(fromRight) {
          return function(start, end, step) {
            if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
              end = step = undefined2;
            }
            start = toFinite(start);
            if (end === undefined2) {
              end = start;
              start = 0;
            } else {
              end = toFinite(end);
            }
            step = step === undefined2 ? start < end ? 1 : -1 : toFinite(step);
            return baseRange(start, end, step, fromRight);
          };
        }
        function createRelationalOperation(operator) {
          return function(value, other) {
            if (!(typeof value == "string" && typeof other == "string")) {
              value = toNumber(value);
              other = toNumber(other);
            }
            return operator(value, other);
          };
        }
        function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
          var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined2, newHoldersRight = isCurry ? undefined2 : holders, newPartials = isCurry ? partials : undefined2, newPartialsRight = isCurry ? undefined2 : partials;
          bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
          bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
          if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
            bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
          }
          var newData = [
            func,
            bitmask,
            thisArg,
            newPartials,
            newHolders,
            newPartialsRight,
            newHoldersRight,
            argPos,
            ary2,
            arity
          ];
          var result2 = wrapFunc.apply(undefined2, newData);
          if (isLaziable(func)) {
            setData(result2, newData);
          }
          result2.placeholder = placeholder;
          return setWrapToString(result2, func, bitmask);
        }
        function createRound(methodName) {
          var func = Math2[methodName];
          return function(number, precision) {
            number = toNumber(number);
            precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
            if (precision && nativeIsFinite(number)) {
              var pair = (toString(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
              pair = (toString(value) + "e").split("e");
              return +(pair[0] + "e" + (+pair[1] - precision));
            }
            return func(number);
          };
        }
        var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop : function(values2) {
          return new Set2(values2);
        };
        function createToPairs(keysFunc) {
          return function(object) {
            var tag = getTag(object);
            if (tag == mapTag) {
              return mapToArray(object);
            }
            if (tag == setTag) {
              return setToPairs(object);
            }
            return baseToPairs(object, keysFunc(object));
          };
        }
        function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
          var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
          if (!isBindKey && typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var length = partials ? partials.length : 0;
          if (!length) {
            bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
            partials = holders = undefined2;
          }
          ary2 = ary2 === undefined2 ? ary2 : nativeMax(toInteger(ary2), 0);
          arity = arity === undefined2 ? arity : toInteger(arity);
          length -= holders ? holders.length : 0;
          if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
            var partialsRight = partials, holdersRight = holders;
            partials = holders = undefined2;
          }
          var data = isBindKey ? undefined2 : getData(func);
          var newData = [
            func,
            bitmask,
            thisArg,
            partials,
            holders,
            partialsRight,
            holdersRight,
            argPos,
            ary2,
            arity
          ];
          if (data) {
            mergeData(newData, data);
          }
          func = newData[0];
          bitmask = newData[1];
          thisArg = newData[2];
          partials = newData[3];
          holders = newData[4];
          arity = newData[9] = newData[9] === undefined2 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
          if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
            bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
          }
          if (!bitmask || bitmask == WRAP_BIND_FLAG) {
            var result2 = createBind(func, bitmask, thisArg);
          } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
            result2 = createCurry(func, bitmask, arity);
          } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
            result2 = createPartial(func, bitmask, thisArg, partials);
          } else {
            result2 = createHybrid.apply(undefined2, newData);
          }
          var setter = data ? baseSetData : setData;
          return setWrapToString(setter(result2, newData), func, bitmask);
        }
        function customDefaultsAssignIn(objValue, srcValue, key, object) {
          if (objValue === undefined2 || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) {
            return srcValue;
          }
          return objValue;
        }
        function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
          if (isObject2(objValue) && isObject2(srcValue)) {
            stack.set(srcValue, objValue);
            baseMerge(objValue, srcValue, undefined2, customDefaultsMerge, stack);
            stack["delete"](srcValue);
          }
          return objValue;
        }
        function customOmitClone(value) {
          return isPlainObject(value) ? undefined2 : value;
        }
        function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
          if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
            return false;
          }
          var arrStacked = stack.get(array);
          var othStacked = stack.get(other);
          if (arrStacked && othStacked) {
            return arrStacked == other && othStacked == array;
          }
          var index = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined2;
          stack.set(array, other);
          stack.set(other, array);
          while (++index < arrLength) {
            var arrValue = array[index], othValue = other[index];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
            }
            if (compared !== undefined2) {
              if (compared) {
                continue;
              }
              result2 = false;
              break;
            }
            if (seen) {
              if (!arraySome(other, function(othValue2, othIndex) {
                if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
                result2 = false;
                break;
              }
            } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              result2 = false;
              break;
            }
          }
          stack["delete"](array);
          stack["delete"](other);
          return result2;
        }
        function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
          switch (tag) {
            case dataViewTag:
              if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                return false;
              }
              object = object.buffer;
              other = other.buffer;
            case arrayBufferTag:
              if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
                return false;
              }
              return true;
            case boolTag:
            case dateTag:
            case numberTag:
              return eq(+object, +other);
            case errorTag:
              return object.name == other.name && object.message == other.message;
            case regexpTag:
            case stringTag:
              return object == other + "";
            case mapTag:
              var convert = mapToArray;
            case setTag:
              var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
              convert || (convert = setToArray);
              if (object.size != other.size && !isPartial) {
                return false;
              }
              var stacked = stack.get(object);
              if (stacked) {
                return stacked == other;
              }
              bitmask |= COMPARE_UNORDERED_FLAG;
              stack.set(object, other);
              var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
              stack["delete"](object);
              return result2;
            case symbolTag:
              if (symbolValueOf) {
                return symbolValueOf.call(object) == symbolValueOf.call(other);
              }
          }
          return false;
        }
        function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
          if (objLength != othLength && !isPartial) {
            return false;
          }
          var index = objLength;
          while (index--) {
            var key = objProps[index];
            if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
              return false;
            }
          }
          var objStacked = stack.get(object);
          var othStacked = stack.get(other);
          if (objStacked && othStacked) {
            return objStacked == other && othStacked == object;
          }
          var result2 = true;
          stack.set(object, other);
          stack.set(other, object);
          var skipCtor = isPartial;
          while (++index < objLength) {
            key = objProps[index];
            var objValue = object[key], othValue = other[key];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
            }
            if (!(compared === undefined2 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
              result2 = false;
              break;
            }
            skipCtor || (skipCtor = key == "constructor");
          }
          if (result2 && !skipCtor) {
            var objCtor = object.constructor, othCtor = other.constructor;
            if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
              result2 = false;
            }
          }
          stack["delete"](object);
          stack["delete"](other);
          return result2;
        }
        function flatRest(func) {
          return setToString(overRest(func, undefined2, flatten), func + "");
        }
        function getAllKeys(object) {
          return baseGetAllKeys(object, keys, getSymbols);
        }
        function getAllKeysIn(object) {
          return baseGetAllKeys(object, keysIn, getSymbolsIn);
        }
        var getData = !metaMap ? noop : function(func) {
          return metaMap.get(func);
        };
        function getFuncName(func) {
          var result2 = func.name + "", array = realNames[result2], length = hasOwnProperty.call(realNames, result2) ? array.length : 0;
          while (length--) {
            var data = array[length], otherFunc = data.func;
            if (otherFunc == null || otherFunc == func) {
              return data.name;
            }
          }
          return result2;
        }
        function getHolder(func) {
          var object = hasOwnProperty.call(lodash, "placeholder") ? lodash : func;
          return object.placeholder;
        }
        function getIteratee() {
          var result2 = lodash.iteratee || iteratee;
          result2 = result2 === iteratee ? baseIteratee : result2;
          return arguments.length ? result2(arguments[0], arguments[1]) : result2;
        }
        function getMapData(map2, key) {
          var data = map2.__data__;
          return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
        }
        function getMatchData(object) {
          var result2 = keys(object), length = result2.length;
          while (length--) {
            var key = result2[length], value = object[key];
            result2[length] = [key, value, isStrictComparable(value)];
          }
          return result2;
        }
        function getNative(object, key) {
          var value = getValue(object, key);
          return baseIsNative(value) ? value : undefined2;
        }
        function getRawTag(value) {
          var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
          try {
            value[symToStringTag] = undefined2;
            var unmasked = true;
          } catch (e) {
          }
          var result2 = nativeObjectToString.call(value);
          if (unmasked) {
            if (isOwn) {
              value[symToStringTag] = tag;
            } else {
              delete value[symToStringTag];
            }
          }
          return result2;
        }
        var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
          if (object == null) {
            return [];
          }
          object = Object2(object);
          return arrayFilter(nativeGetSymbols(object), function(symbol) {
            return propertyIsEnumerable.call(object, symbol);
          });
        };
        var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
          var result2 = [];
          while (object) {
            arrayPush(result2, getSymbols(object));
            object = getPrototype(object);
          }
          return result2;
        };
        var getTag = baseGetTag;
        if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
          getTag = function(value) {
            var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined2, ctorString = Ctor ? toSource(Ctor) : "";
            if (ctorString) {
              switch (ctorString) {
                case dataViewCtorString:
                  return dataViewTag;
                case mapCtorString:
                  return mapTag;
                case promiseCtorString:
                  return promiseTag;
                case setCtorString:
                  return setTag;
                case weakMapCtorString:
                  return weakMapTag;
              }
            }
            return result2;
          };
        }
        function getView(start, end, transforms) {
          var index = -1, length = transforms.length;
          while (++index < length) {
            var data = transforms[index], size2 = data.size;
            switch (data.type) {
              case "drop":
                start += size2;
                break;
              case "dropRight":
                end -= size2;
                break;
              case "take":
                end = nativeMin(end, start + size2);
                break;
              case "takeRight":
                start = nativeMax(start, end - size2);
                break;
            }
          }
          return { "start": start, "end": end };
        }
        function getWrapDetails(source) {
          var match = source.match(reWrapDetails);
          return match ? match[1].split(reSplitDetails) : [];
        }
        function hasPath(object, path, hasFunc) {
          path = castPath(path, object);
          var index = -1, length = path.length, result2 = false;
          while (++index < length) {
            var key = toKey(path[index]);
            if (!(result2 = object != null && hasFunc(object, key))) {
              break;
            }
            object = object[key];
          }
          if (result2 || ++index != length) {
            return result2;
          }
          length = object == null ? 0 : object.length;
          return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
        }
        function initCloneArray(array) {
          var length = array.length, result2 = new array.constructor(length);
          if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
            result2.index = array.index;
            result2.input = array.input;
          }
          return result2;
        }
        function initCloneObject(object) {
          return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
        }
        function initCloneByTag(object, tag, isDeep) {
          var Ctor = object.constructor;
          switch (tag) {
            case arrayBufferTag:
              return cloneArrayBuffer(object);
            case boolTag:
            case dateTag:
              return new Ctor(+object);
            case dataViewTag:
              return cloneDataView(object, isDeep);
            case float32Tag:
            case float64Tag:
            case int8Tag:
            case int16Tag:
            case int32Tag:
            case uint8Tag:
            case uint8ClampedTag:
            case uint16Tag:
            case uint32Tag:
              return cloneTypedArray(object, isDeep);
            case mapTag:
              return new Ctor();
            case numberTag:
            case stringTag:
              return new Ctor(object);
            case regexpTag:
              return cloneRegExp(object);
            case setTag:
              return new Ctor();
            case symbolTag:
              return cloneSymbol(object);
          }
        }
        function insertWrapDetails(source, details) {
          var length = details.length;
          if (!length) {
            return source;
          }
          var lastIndex = length - 1;
          details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
          details = details.join(length > 2 ? ", " : " ");
          return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
        }
        function isFlattenable(value) {
          return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
        }
        function isIndex(value, length) {
          var type = typeof value;
          length = length == null ? MAX_SAFE_INTEGER : length;
          return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
        }
        function isIterateeCall(value, index, object) {
          if (!isObject2(object)) {
            return false;
          }
          var type = typeof index;
          if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
            return eq(object[index], value);
          }
          return false;
        }
        function isKey(value, object) {
          if (isArray(value)) {
            return false;
          }
          var type = typeof value;
          if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
            return true;
          }
          return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
        }
        function isKeyable(value) {
          var type = typeof value;
          return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
        }
        function isLaziable(func) {
          var funcName = getFuncName(func), other = lodash[funcName];
          if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
            return false;
          }
          if (func === other) {
            return true;
          }
          var data = getData(other);
          return !!data && func === data[0];
        }
        function isMasked(func) {
          return !!maskSrcKey && maskSrcKey in func;
        }
        var isMaskable = coreJsData ? isFunction : stubFalse;
        function isPrototype(value) {
          var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
          return value === proto;
        }
        function isStrictComparable(value) {
          return value === value && !isObject2(value);
        }
        function matchesStrictComparable(key, srcValue) {
          return function(object) {
            if (object == null) {
              return false;
            }
            return object[key] === srcValue && (srcValue !== undefined2 || key in Object2(object));
          };
        }
        function memoizeCapped(func) {
          var result2 = memoize(func, function(key) {
            if (cache.size === MAX_MEMOIZE_SIZE) {
              cache.clear();
            }
            return key;
          });
          var cache = result2.cache;
          return result2;
        }
        function mergeData(data, source) {
          var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
          var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
          if (!(isCommon || isCombo)) {
            return data;
          }
          if (srcBitmask & WRAP_BIND_FLAG) {
            data[2] = source[2];
            newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
          }
          var value = source[3];
          if (value) {
            var partials = data[3];
            data[3] = partials ? composeArgs(partials, value, source[4]) : value;
            data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
          }
          value = source[5];
          if (value) {
            partials = data[5];
            data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
            data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
          }
          value = source[7];
          if (value) {
            data[7] = value;
          }
          if (srcBitmask & WRAP_ARY_FLAG) {
            data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
          }
          if (data[9] == null) {
            data[9] = source[9];
          }
          data[0] = source[0];
          data[1] = newBitmask;
          return data;
        }
        function nativeKeysIn(object) {
          var result2 = [];
          if (object != null) {
            for (var key in Object2(object)) {
              result2.push(key);
            }
          }
          return result2;
        }
        function objectToString(value) {
          return nativeObjectToString.call(value);
        }
        function overRest(func, start, transform2) {
          start = nativeMax(start === undefined2 ? func.length - 1 : start, 0);
          return function() {
            var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array2(length);
            while (++index < length) {
              array[index] = args[start + index];
            }
            index = -1;
            var otherArgs = Array2(start + 1);
            while (++index < start) {
              otherArgs[index] = args[index];
            }
            otherArgs[start] = transform2(array);
            return apply(func, this, otherArgs);
          };
        }
        function parent(object, path) {
          return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
        }
        function reorder(array, indexes) {
          var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
          while (length--) {
            var index = indexes[length];
            array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined2;
          }
          return array;
        }
        function safeGet(object, key) {
          if (key === "constructor" && typeof object[key] === "function") {
            return;
          }
          if (key == "__proto__") {
            return;
          }
          return object[key];
        }
        var setData = shortOut(baseSetData);
        var setTimeout2 = ctxSetTimeout || function(func, wait) {
          return root.setTimeout(func, wait);
        };
        var setToString = shortOut(baseSetToString);
        function setWrapToString(wrapper, reference, bitmask) {
          var source = reference + "";
          return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
        }
        function shortOut(func) {
          var count = 0, lastCalled = 0;
          return function() {
            var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
            lastCalled = stamp;
            if (remaining > 0) {
              if (++count >= HOT_COUNT) {
                return arguments[0];
              }
            } else {
              count = 0;
            }
            return func.apply(undefined2, arguments);
          };
        }
        function shuffleSelf(array, size2) {
          var index = -1, length = array.length, lastIndex = length - 1;
          size2 = size2 === undefined2 ? length : size2;
          while (++index < size2) {
            var rand = baseRandom(index, lastIndex), value = array[rand];
            array[rand] = array[index];
            array[index] = value;
          }
          array.length = size2;
          return array;
        }
        var stringToPath = memoizeCapped(function(string) {
          var result2 = [];
          if (string.charCodeAt(0) === 46) {
            result2.push("");
          }
          string.replace(rePropName, function(match, number, quote, subString) {
            result2.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
          });
          return result2;
        });
        function toKey(value) {
          if (typeof value == "string" || isSymbol(value)) {
            return value;
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function toSource(func) {
          if (func != null) {
            try {
              return funcToString.call(func);
            } catch (e) {
            }
            try {
              return func + "";
            } catch (e) {
            }
          }
          return "";
        }
        function updateWrapDetails(details, bitmask) {
          arrayEach(wrapFlags, function(pair) {
            var value = "_." + pair[0];
            if (bitmask & pair[1] && !arrayIncludes(details, value)) {
              details.push(value);
            }
          });
          return details.sort();
        }
        function wrapperClone(wrapper) {
          if (wrapper instanceof LazyWrapper) {
            return wrapper.clone();
          }
          var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
          result2.__actions__ = copyArray(wrapper.__actions__);
          result2.__index__ = wrapper.__index__;
          result2.__values__ = wrapper.__values__;
          return result2;
        }
        function chunk(array, size2, guard) {
          if (guard ? isIterateeCall(array, size2, guard) : size2 === undefined2) {
            size2 = 1;
          } else {
            size2 = nativeMax(toInteger(size2), 0);
          }
          var length = array == null ? 0 : array.length;
          if (!length || size2 < 1) {
            return [];
          }
          var index = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size2));
          while (index < length) {
            result2[resIndex++] = baseSlice(array, index, index += size2);
          }
          return result2;
        }
        function compact(array) {
          var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
          while (++index < length) {
            var value = array[index];
            if (value) {
              result2[resIndex++] = value;
            }
          }
          return result2;
        }
        function concat() {
          var length = arguments.length;
          if (!length) {
            return [];
          }
          var args = Array2(length - 1), array = arguments[0], index = length;
          while (index--) {
            args[index - 1] = arguments[index];
          }
          return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
        }
        var difference = baseRest(function(array, values2) {
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
        });
        var differenceBy = baseRest(function(array, values2) {
          var iteratee2 = last(values2);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
        });
        var differenceWith = baseRest(function(array, values2) {
          var comparator = last(values2);
          if (isArrayLikeObject(comparator)) {
            comparator = undefined2;
          }
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), undefined2, comparator) : [];
        });
        function drop(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          return baseSlice(array, n < 0 ? 0 : n, length);
        }
        function dropRight(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          n = length - n;
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        function dropRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
        }
        function dropWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
        }
        function fill(array, value, start, end) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (start && typeof start != "number" && isIterateeCall(array, value, start)) {
            start = 0;
            end = length;
          }
          return baseFill(array, value, start, end);
        }
        function findIndex(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index < 0) {
            index = nativeMax(length + index, 0);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index);
        }
        function findLastIndex(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = length - 1;
          if (fromIndex !== undefined2) {
            index = toInteger(fromIndex);
            index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index, true);
        }
        function flatten(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, 1) : [];
        }
        function flattenDeep(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, INFINITY) : [];
        }
        function flattenDepth(array, depth) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          depth = depth === undefined2 ? 1 : toInteger(depth);
          return baseFlatten(array, depth);
        }
        function fromPairs(pairs) {
          var index = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
          while (++index < length) {
            var pair = pairs[index];
            result2[pair[0]] = pair[1];
          }
          return result2;
        }
        function head(array) {
          return array && array.length ? array[0] : undefined2;
        }
        function indexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index < 0) {
            index = nativeMax(length + index, 0);
          }
          return baseIndexOf(array, value, index);
        }
        function initial(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 0, -1) : [];
        }
        var intersection = baseRest(function(arrays) {
          var mapped = arrayMap(arrays, castArrayLikeObject);
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
        });
        var intersectionBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          if (iteratee2 === last(mapped)) {
            iteratee2 = undefined2;
          } else {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
        });
        var intersectionWith = baseRest(function(arrays) {
          var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          if (comparator) {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined2, comparator) : [];
        });
        function join(array, separator) {
          return array == null ? "" : nativeJoin.call(array, separator);
        }
        function last(array) {
          var length = array == null ? 0 : array.length;
          return length ? array[length - 1] : undefined2;
        }
        function lastIndexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = length;
          if (fromIndex !== undefined2) {
            index = toInteger(fromIndex);
            index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
          }
          return value === value ? strictLastIndexOf(array, value, index) : baseFindIndex(array, baseIsNaN, index, true);
        }
        function nth(array, n) {
          return array && array.length ? baseNth(array, toInteger(n)) : undefined2;
        }
        var pull = baseRest(pullAll);
        function pullAll(array, values2) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2) : array;
        }
        function pullAllBy(array, values2, iteratee2) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2, getIteratee(iteratee2, 2)) : array;
        }
        function pullAllWith(array, values2, comparator) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2, undefined2, comparator) : array;
        }
        var pullAt = flatRest(function(array, indexes) {
          var length = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
          basePullAt(array, arrayMap(indexes, function(index) {
            return isIndex(index, length) ? +index : index;
          }).sort(compareAscending));
          return result2;
        });
        function remove(array, predicate) {
          var result2 = [];
          if (!(array && array.length)) {
            return result2;
          }
          var index = -1, indexes = [], length = array.length;
          predicate = getIteratee(predicate, 3);
          while (++index < length) {
            var value = array[index];
            if (predicate(value, index, array)) {
              result2.push(value);
              indexes.push(index);
            }
          }
          basePullAt(array, indexes);
          return result2;
        }
        function reverse(array) {
          return array == null ? array : nativeReverse.call(array);
        }
        function slice(array, start, end) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (end && typeof end != "number" && isIterateeCall(array, start, end)) {
            start = 0;
            end = length;
          } else {
            start = start == null ? 0 : toInteger(start);
            end = end === undefined2 ? length : toInteger(end);
          }
          return baseSlice(array, start, end);
        }
        function sortedIndex(array, value) {
          return baseSortedIndex(array, value);
        }
        function sortedIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
        }
        function sortedIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index = baseSortedIndex(array, value);
            if (index < length && eq(array[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function sortedLastIndex(array, value) {
          return baseSortedIndex(array, value, true);
        }
        function sortedLastIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
        }
        function sortedLastIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index = baseSortedIndex(array, value, true) - 1;
            if (eq(array[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function sortedUniq(array) {
          return array && array.length ? baseSortedUniq(array) : [];
        }
        function sortedUniqBy(array, iteratee2) {
          return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
        }
        function tail(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 1, length) : [];
        }
        function take(array, n, guard) {
          if (!(array && array.length)) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        function takeRight(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          n = length - n;
          return baseSlice(array, n < 0 ? 0 : n, length);
        }
        function takeRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
        }
        function takeWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
        }
        var union = baseRest(function(arrays) {
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
        });
        var unionBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
        });
        var unionWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined2, comparator);
        });
        function uniq(array) {
          return array && array.length ? baseUniq(array) : [];
        }
        function uniqBy(array, iteratee2) {
          return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
        }
        function uniqWith(array, comparator) {
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return array && array.length ? baseUniq(array, undefined2, comparator) : [];
        }
        function unzip(array) {
          if (!(array && array.length)) {
            return [];
          }
          var length = 0;
          array = arrayFilter(array, function(group) {
            if (isArrayLikeObject(group)) {
              length = nativeMax(group.length, length);
              return true;
            }
          });
          return baseTimes(length, function(index) {
            return arrayMap(array, baseProperty(index));
          });
        }
        function unzipWith(array, iteratee2) {
          if (!(array && array.length)) {
            return [];
          }
          var result2 = unzip(array);
          if (iteratee2 == null) {
            return result2;
          }
          return arrayMap(result2, function(group) {
            return apply(iteratee2, undefined2, group);
          });
        }
        var without = baseRest(function(array, values2) {
          return isArrayLikeObject(array) ? baseDifference(array, values2) : [];
        });
        var xor = baseRest(function(arrays) {
          return baseXor(arrayFilter(arrays, isArrayLikeObject));
        });
        var xorBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
        });
        var xorWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined2, comparator);
        });
        var zip = baseRest(unzip);
        function zipObject(props, values2) {
          return baseZipObject(props || [], values2 || [], assignValue);
        }
        function zipObjectDeep(props, values2) {
          return baseZipObject(props || [], values2 || [], baseSet);
        }
        var zipWith = baseRest(function(arrays) {
          var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined2;
          iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined2;
          return unzipWith(arrays, iteratee2);
        });
        function chain(value) {
          var result2 = lodash(value);
          result2.__chain__ = true;
          return result2;
        }
        function tap(value, interceptor) {
          interceptor(value);
          return value;
        }
        function thru(value, interceptor) {
          return interceptor(value);
        }
        var wrapperAt = flatRest(function(paths) {
          var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
            return baseAt(object, paths);
          };
          if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
            return this.thru(interceptor);
          }
          value = value.slice(start, +start + (length ? 1 : 0));
          value.__actions__.push({
            "func": thru,
            "args": [interceptor],
            "thisArg": undefined2
          });
          return new LodashWrapper(value, this.__chain__).thru(function(array) {
            if (length && !array.length) {
              array.push(undefined2);
            }
            return array;
          });
        });
        function wrapperChain() {
          return chain(this);
        }
        function wrapperCommit() {
          return new LodashWrapper(this.value(), this.__chain__);
        }
        function wrapperNext() {
          if (this.__values__ === undefined2) {
            this.__values__ = toArray(this.value());
          }
          var done = this.__index__ >= this.__values__.length, value = done ? undefined2 : this.__values__[this.__index__++];
          return { "done": done, "value": value };
        }
        function wrapperToIterator() {
          return this;
        }
        function wrapperPlant(value) {
          var result2, parent2 = this;
          while (parent2 instanceof baseLodash) {
            var clone2 = wrapperClone(parent2);
            clone2.__index__ = 0;
            clone2.__values__ = undefined2;
            if (result2) {
              previous.__wrapped__ = clone2;
            } else {
              result2 = clone2;
            }
            var previous = clone2;
            parent2 = parent2.__wrapped__;
          }
          previous.__wrapped__ = value;
          return result2;
        }
        function wrapperReverse() {
          var value = this.__wrapped__;
          if (value instanceof LazyWrapper) {
            var wrapped = value;
            if (this.__actions__.length) {
              wrapped = new LazyWrapper(this);
            }
            wrapped = wrapped.reverse();
            wrapped.__actions__.push({
              "func": thru,
              "args": [reverse],
              "thisArg": undefined2
            });
            return new LodashWrapper(wrapped, this.__chain__);
          }
          return this.thru(reverse);
        }
        function wrapperValue() {
          return baseWrapperValue(this.__wrapped__, this.__actions__);
        }
        var countBy = createAggregator(function(result2, value, key) {
          if (hasOwnProperty.call(result2, key)) {
            ++result2[key];
          } else {
            baseAssignValue(result2, key, 1);
          }
        });
        function every(collection, predicate, guard) {
          var func = isArray(collection) ? arrayEvery : baseEvery;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined2;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        function filter(collection, predicate) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          return func(collection, getIteratee(predicate, 3));
        }
        var find = createFind(findIndex);
        var findLast = createFind(findLastIndex);
        function flatMap(collection, iteratee2) {
          return baseFlatten(map(collection, iteratee2), 1);
        }
        function flatMapDeep(collection, iteratee2) {
          return baseFlatten(map(collection, iteratee2), INFINITY);
        }
        function flatMapDepth(collection, iteratee2, depth) {
          depth = depth === undefined2 ? 1 : toInteger(depth);
          return baseFlatten(map(collection, iteratee2), depth);
        }
        function forEach(collection, iteratee2) {
          var func = isArray(collection) ? arrayEach : baseEach;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function forEachRight(collection, iteratee2) {
          var func = isArray(collection) ? arrayEachRight : baseEachRight;
          return func(collection, getIteratee(iteratee2, 3));
        }
        var groupBy = createAggregator(function(result2, value, key) {
          if (hasOwnProperty.call(result2, key)) {
            result2[key].push(value);
          } else {
            baseAssignValue(result2, key, [value]);
          }
        });
        function includes(collection, value, fromIndex, guard) {
          collection = isArrayLike(collection) ? collection : values(collection);
          fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
          var length = collection.length;
          if (fromIndex < 0) {
            fromIndex = nativeMax(length + fromIndex, 0);
          }
          return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
        }
        var invokeMap = baseRest(function(collection, path, args) {
          var index = -1, isFunc = typeof path == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value) {
            result2[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
          });
          return result2;
        });
        var keyBy = createAggregator(function(result2, value, key) {
          baseAssignValue(result2, key, value);
        });
        function map(collection, iteratee2) {
          var func = isArray(collection) ? arrayMap : baseMap;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function orderBy(collection, iteratees, orders, guard) {
          if (collection == null) {
            return [];
          }
          if (!isArray(iteratees)) {
            iteratees = iteratees == null ? [] : [iteratees];
          }
          orders = guard ? undefined2 : orders;
          if (!isArray(orders)) {
            orders = orders == null ? [] : [orders];
          }
          return baseOrderBy(collection, iteratees, orders);
        }
        var partition = createAggregator(function(result2, value, key) {
          result2[key ? 0 : 1].push(value);
        }, function() {
          return [[], []];
        });
        function reduce(collection, iteratee2, accumulator) {
          var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
        }
        function reduceRight(collection, iteratee2, accumulator) {
          var func = isArray(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
        }
        function reject(collection, predicate) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          return func(collection, negate(getIteratee(predicate, 3)));
        }
        function sample(collection) {
          var func = isArray(collection) ? arraySample : baseSample;
          return func(collection);
        }
        function sampleSize(collection, n, guard) {
          if (guard ? isIterateeCall(collection, n, guard) : n === undefined2) {
            n = 1;
          } else {
            n = toInteger(n);
          }
          var func = isArray(collection) ? arraySampleSize : baseSampleSize;
          return func(collection, n);
        }
        function shuffle(collection) {
          var func = isArray(collection) ? arrayShuffle : baseShuffle;
          return func(collection);
        }
        function size(collection) {
          if (collection == null) {
            return 0;
          }
          if (isArrayLike(collection)) {
            return isString(collection) ? stringSize(collection) : collection.length;
          }
          var tag = getTag(collection);
          if (tag == mapTag || tag == setTag) {
            return collection.size;
          }
          return baseKeys(collection).length;
        }
        function some(collection, predicate, guard) {
          var func = isArray(collection) ? arraySome : baseSome;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined2;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        var sortBy = baseRest(function(collection, iteratees) {
          if (collection == null) {
            return [];
          }
          var length = iteratees.length;
          if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
            iteratees = [];
          } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
            iteratees = [iteratees[0]];
          }
          return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
        });
        var now = ctxNow || function() {
          return root.Date.now();
        };
        function after(n, func) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n = toInteger(n);
          return function() {
            if (--n < 1) {
              return func.apply(this, arguments);
            }
          };
        }
        function ary(func, n, guard) {
          n = guard ? undefined2 : n;
          n = func && n == null ? func.length : n;
          return createWrap(func, WRAP_ARY_FLAG, undefined2, undefined2, undefined2, undefined2, n);
        }
        function before(n, func) {
          var result2;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n = toInteger(n);
          return function() {
            if (--n > 0) {
              result2 = func.apply(this, arguments);
            }
            if (n <= 1) {
              func = undefined2;
            }
            return result2;
          };
        }
        var bind = baseRest(function(func, thisArg, partials) {
          var bitmask = WRAP_BIND_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bind));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(func, bitmask, thisArg, partials, holders);
        });
        var bindKey = baseRest(function(object, key, partials) {
          var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bindKey));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(key, bitmask, object, partials, holders);
        });
        function curry(func, arity, guard) {
          arity = guard ? undefined2 : arity;
          var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
          result2.placeholder = curry.placeholder;
          return result2;
        }
        function curryRight(func, arity, guard) {
          arity = guard ? undefined2 : arity;
          var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
          result2.placeholder = curryRight.placeholder;
          return result2;
        }
        function debounce(func, wait, options) {
          var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          wait = toNumber(wait) || 0;
          if (isObject2(options)) {
            leading = !!options.leading;
            maxing = "maxWait" in options;
            maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          function invokeFunc(time) {
            var args = lastArgs, thisArg = lastThis;
            lastArgs = lastThis = undefined2;
            lastInvokeTime = time;
            result2 = func.apply(thisArg, args);
            return result2;
          }
          function leadingEdge(time) {
            lastInvokeTime = time;
            timerId = setTimeout2(timerExpired, wait);
            return leading ? invokeFunc(time) : result2;
          }
          function remainingWait(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
            return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
          }
          function shouldInvoke(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
            return lastCallTime === undefined2 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
          }
          function timerExpired() {
            var time = now();
            if (shouldInvoke(time)) {
              return trailingEdge(time);
            }
            timerId = setTimeout2(timerExpired, remainingWait(time));
          }
          function trailingEdge(time) {
            timerId = undefined2;
            if (trailing && lastArgs) {
              return invokeFunc(time);
            }
            lastArgs = lastThis = undefined2;
            return result2;
          }
          function cancel() {
            if (timerId !== undefined2) {
              clearTimeout2(timerId);
            }
            lastInvokeTime = 0;
            lastArgs = lastCallTime = lastThis = timerId = undefined2;
          }
          function flush() {
            return timerId === undefined2 ? result2 : trailingEdge(now());
          }
          function debounced() {
            var time = now(), isInvoking = shouldInvoke(time);
            lastArgs = arguments;
            lastThis = this;
            lastCallTime = time;
            if (isInvoking) {
              if (timerId === undefined2) {
                return leadingEdge(lastCallTime);
              }
              if (maxing) {
                clearTimeout2(timerId);
                timerId = setTimeout2(timerExpired, wait);
                return invokeFunc(lastCallTime);
              }
            }
            if (timerId === undefined2) {
              timerId = setTimeout2(timerExpired, wait);
            }
            return result2;
          }
          debounced.cancel = cancel;
          debounced.flush = flush;
          return debounced;
        }
        var defer = baseRest(function(func, args) {
          return baseDelay(func, 1, args);
        });
        var delay = baseRest(function(func, wait, args) {
          return baseDelay(func, toNumber(wait) || 0, args);
        });
        function flip(func) {
          return createWrap(func, WRAP_FLIP_FLAG);
        }
        function memoize(func, resolver) {
          if (typeof func != "function" || resolver != null && typeof resolver != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var memoized = function() {
            var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
            if (cache.has(key)) {
              return cache.get(key);
            }
            var result2 = func.apply(this, args);
            memoized.cache = cache.set(key, result2) || cache;
            return result2;
          };
          memoized.cache = new (memoize.Cache || MapCache)();
          return memoized;
        }
        memoize.Cache = MapCache;
        function negate(predicate) {
          if (typeof predicate != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return !predicate.call(this);
              case 1:
                return !predicate.call(this, args[0]);
              case 2:
                return !predicate.call(this, args[0], args[1]);
              case 3:
                return !predicate.call(this, args[0], args[1], args[2]);
            }
            return !predicate.apply(this, args);
          };
        }
        function once(func) {
          return before(2, func);
        }
        var overArgs = castRest(function(func, transforms) {
          transforms = transforms.length == 1 && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
          var funcsLength = transforms.length;
          return baseRest(function(args) {
            var index = -1, length = nativeMin(args.length, funcsLength);
            while (++index < length) {
              args[index] = transforms[index].call(this, args[index]);
            }
            return apply(func, this, args);
          });
        });
        var partial = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partial));
          return createWrap(func, WRAP_PARTIAL_FLAG, undefined2, partials, holders);
        });
        var partialRight = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partialRight));
          return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined2, partials, holders);
        });
        var rearg = flatRest(function(func, indexes) {
          return createWrap(func, WRAP_REARG_FLAG, undefined2, undefined2, undefined2, indexes);
        });
        function rest(func, start) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start === undefined2 ? start : toInteger(start);
          return baseRest(func, start);
        }
        function spread(func, start) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start == null ? 0 : nativeMax(toInteger(start), 0);
          return baseRest(function(args) {
            var array = args[start], otherArgs = castSlice(args, 0, start);
            if (array) {
              arrayPush(otherArgs, array);
            }
            return apply(func, this, otherArgs);
          });
        }
        function throttle(func, wait, options) {
          var leading = true, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          if (isObject2(options)) {
            leading = "leading" in options ? !!options.leading : leading;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          return debounce(func, wait, {
            "leading": leading,
            "maxWait": wait,
            "trailing": trailing
          });
        }
        function unary(func) {
          return ary(func, 1);
        }
        function wrap(value, wrapper) {
          return partial(castFunction(wrapper), value);
        }
        function castArray() {
          if (!arguments.length) {
            return [];
          }
          var value = arguments[0];
          return isArray(value) ? value : [value];
        }
        function clone(value) {
          return baseClone(value, CLONE_SYMBOLS_FLAG);
        }
        function cloneWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
        }
        function cloneDeep(value) {
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
        }
        function cloneDeepWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
        }
        function conformsTo(object, source) {
          return source == null || baseConformsTo(object, source, keys(source));
        }
        function eq(value, other) {
          return value === other || value !== value && other !== other;
        }
        var gt = createRelationalOperation(baseGt);
        var gte = createRelationalOperation(function(value, other) {
          return value >= other;
        });
        var isArguments = baseIsArguments(function() {
          return arguments;
        }()) ? baseIsArguments : function(value) {
          return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
        };
        var isArray = Array2.isArray;
        var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
        function isArrayLike(value) {
          return value != null && isLength(value.length) && !isFunction(value);
        }
        function isArrayLikeObject(value) {
          return isObjectLike(value) && isArrayLike(value);
        }
        function isBoolean(value) {
          return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
        }
        var isBuffer = nativeIsBuffer || stubFalse;
        var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
        function isElement(value) {
          return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
        }
        function isEmpty(value) {
          if (value == null) {
            return true;
          }
          if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
            return !value.length;
          }
          var tag = getTag(value);
          if (tag == mapTag || tag == setTag) {
            return !value.size;
          }
          if (isPrototype(value)) {
            return !baseKeys(value).length;
          }
          for (var key in value) {
            if (hasOwnProperty.call(value, key)) {
              return false;
            }
          }
          return true;
        }
        function isEqual(value, other) {
          return baseIsEqual(value, other);
        }
        function isEqualWith(value, other, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          var result2 = customizer ? customizer(value, other) : undefined2;
          return result2 === undefined2 ? baseIsEqual(value, other, undefined2, customizer) : !!result2;
        }
        function isError2(value) {
          if (!isObjectLike(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject(value);
        }
        function isFinite2(value) {
          return typeof value == "number" && nativeIsFinite(value);
        }
        function isFunction(value) {
          if (!isObject2(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
        }
        function isInteger(value) {
          return typeof value == "number" && value == toInteger(value);
        }
        function isLength(value) {
          return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
        }
        function isObject2(value) {
          var type = typeof value;
          return value != null && (type == "object" || type == "function");
        }
        function isObjectLike(value) {
          return value != null && typeof value == "object";
        }
        var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
        function isMatch(object, source) {
          return object === source || baseIsMatch(object, source, getMatchData(source));
        }
        function isMatchWith(object, source, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseIsMatch(object, source, getMatchData(source), customizer);
        }
        function isNaN2(value) {
          return isNumber(value) && value != +value;
        }
        function isNative(value) {
          if (isMaskable(value)) {
            throw new Error2(CORE_ERROR_TEXT);
          }
          return baseIsNative(value);
        }
        function isNull(value) {
          return value === null;
        }
        function isNil(value) {
          return value == null;
        }
        function isNumber(value) {
          return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
        }
        function isPlainObject(value) {
          if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
            return false;
          }
          var proto = getPrototype(value);
          if (proto === null) {
            return true;
          }
          var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
          return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
        }
        var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
        function isSafeInteger(value) {
          return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
        }
        var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
        function isString(value) {
          return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
        }
        function isSymbol(value) {
          return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
        }
        var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
        function isUndefined(value) {
          return value === undefined2;
        }
        function isWeakMap(value) {
          return isObjectLike(value) && getTag(value) == weakMapTag;
        }
        function isWeakSet(value) {
          return isObjectLike(value) && baseGetTag(value) == weakSetTag;
        }
        var lt = createRelationalOperation(baseLt);
        var lte = createRelationalOperation(function(value, other) {
          return value <= other;
        });
        function toArray(value) {
          if (!value) {
            return [];
          }
          if (isArrayLike(value)) {
            return isString(value) ? stringToArray(value) : copyArray(value);
          }
          if (symIterator && value[symIterator]) {
            return iteratorToArray(value[symIterator]());
          }
          var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
          return func(value);
        }
        function toFinite(value) {
          if (!value) {
            return value === 0 ? value : 0;
          }
          value = toNumber(value);
          if (value === INFINITY || value === -INFINITY) {
            var sign = value < 0 ? -1 : 1;
            return sign * MAX_INTEGER;
          }
          return value === value ? value : 0;
        }
        function toInteger(value) {
          var result2 = toFinite(value), remainder = result2 % 1;
          return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
        }
        function toLength(value) {
          return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
        }
        function toNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          if (isObject2(value)) {
            var other = typeof value.valueOf == "function" ? value.valueOf() : value;
            value = isObject2(other) ? other + "" : other;
          }
          if (typeof value != "string") {
            return value === 0 ? value : +value;
          }
          value = baseTrim(value);
          var isBinary = reIsBinary.test(value);
          return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
        }
        function toPlainObject(value) {
          return copyObject(value, keysIn(value));
        }
        function toSafeInteger(value) {
          return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
        }
        function toString(value) {
          return value == null ? "" : baseToString(value);
        }
        var assign = createAssigner(function(object, source) {
          if (isPrototype(source) || isArrayLike(source)) {
            copyObject(source, keys(source), object);
            return;
          }
          for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
              assignValue(object, key, source[key]);
            }
          }
        });
        var assignIn = createAssigner(function(object, source) {
          copyObject(source, keysIn(source), object);
        });
        var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keysIn(source), object, customizer);
        });
        var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keys(source), object, customizer);
        });
        var at = flatRest(baseAt);
        function create(prototype, properties) {
          var result2 = baseCreate(prototype);
          return properties == null ? result2 : baseAssign(result2, properties);
        }
        var defaults = baseRest(function(object, sources) {
          object = Object2(object);
          var index = -1;
          var length = sources.length;
          var guard = length > 2 ? sources[2] : undefined2;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            length = 1;
          }
          while (++index < length) {
            var source = sources[index];
            var props = keysIn(source);
            var propsIndex = -1;
            var propsLength = props.length;
            while (++propsIndex < propsLength) {
              var key = props[propsIndex];
              var value = object[key];
              if (value === undefined2 || eq(value, objectProto[key]) && !hasOwnProperty.call(object, key)) {
                object[key] = source[key];
              }
            }
          }
          return object;
        });
        var defaultsDeep = baseRest(function(args) {
          args.push(undefined2, customDefaultsMerge);
          return apply(mergeWith, undefined2, args);
        });
        function findKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
        }
        function findLastKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
        }
        function forIn(object, iteratee2) {
          return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
        }
        function forInRight(object, iteratee2) {
          return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
        }
        function forOwn(object, iteratee2) {
          return object && baseForOwn(object, getIteratee(iteratee2, 3));
        }
        function forOwnRight(object, iteratee2) {
          return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
        }
        function functions(object) {
          return object == null ? [] : baseFunctions(object, keys(object));
        }
        function functionsIn(object) {
          return object == null ? [] : baseFunctions(object, keysIn(object));
        }
        function get(object, path, defaultValue) {
          var result2 = object == null ? undefined2 : baseGet(object, path);
          return result2 === undefined2 ? defaultValue : result2;
        }
        function has(object, path) {
          return object != null && hasPath(object, path, baseHas);
        }
        function hasIn(object, path) {
          return object != null && hasPath(object, path, baseHasIn);
        }
        var invert = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          result2[value] = key;
        }, constant(identity));
        var invertBy = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          if (hasOwnProperty.call(result2, value)) {
            result2[value].push(key);
          } else {
            result2[value] = [key];
          }
        }, getIteratee);
        var invoke = baseRest(baseInvoke);
        function keys(object) {
          return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
        }
        function keysIn(object) {
          return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
        }
        function mapKeys(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function(value, key, object2) {
            baseAssignValue(result2, iteratee2(value, key, object2), value);
          });
          return result2;
        }
        function mapValues(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function(value, key, object2) {
            baseAssignValue(result2, key, iteratee2(value, key, object2));
          });
          return result2;
        }
        var merge = createAssigner(function(object, source, srcIndex) {
          baseMerge(object, source, srcIndex);
        });
        var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
          baseMerge(object, source, srcIndex, customizer);
        });
        var omit = flatRest(function(object, paths) {
          var result2 = {};
          if (object == null) {
            return result2;
          }
          var isDeep = false;
          paths = arrayMap(paths, function(path) {
            path = castPath(path, object);
            isDeep || (isDeep = path.length > 1);
            return path;
          });
          copyObject(object, getAllKeysIn(object), result2);
          if (isDeep) {
            result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
          }
          var length = paths.length;
          while (length--) {
            baseUnset(result2, paths[length]);
          }
          return result2;
        });
        function omitBy(object, predicate) {
          return pickBy(object, negate(getIteratee(predicate)));
        }
        var pick = flatRest(function(object, paths) {
          return object == null ? {} : basePick(object, paths);
        });
        function pickBy(object, predicate) {
          if (object == null) {
            return {};
          }
          var props = arrayMap(getAllKeysIn(object), function(prop) {
            return [prop];
          });
          predicate = getIteratee(predicate);
          return basePickBy(object, props, function(value, path) {
            return predicate(value, path[0]);
          });
        }
        function result(object, path, defaultValue) {
          path = castPath(path, object);
          var index = -1, length = path.length;
          if (!length) {
            length = 1;
            object = undefined2;
          }
          while (++index < length) {
            var value = object == null ? undefined2 : object[toKey(path[index])];
            if (value === undefined2) {
              index = length;
              value = defaultValue;
            }
            object = isFunction(value) ? value.call(object) : value;
          }
          return object;
        }
        function set(object, path, value) {
          return object == null ? object : baseSet(object, path, value);
        }
        function setWith(object, path, value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return object == null ? object : baseSet(object, path, value, customizer);
        }
        var toPairs = createToPairs(keys);
        var toPairsIn = createToPairs(keysIn);
        function transform(object, iteratee2, accumulator) {
          var isArr = isArray(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
          iteratee2 = getIteratee(iteratee2, 4);
          if (accumulator == null) {
            var Ctor = object && object.constructor;
            if (isArrLike) {
              accumulator = isArr ? new Ctor() : [];
            } else if (isObject2(object)) {
              accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
            } else {
              accumulator = {};
            }
          }
          (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object2) {
            return iteratee2(accumulator, value, index, object2);
          });
          return accumulator;
        }
        function unset(object, path) {
          return object == null ? true : baseUnset(object, path);
        }
        function update(object, path, updater) {
          return object == null ? object : baseUpdate(object, path, castFunction(updater));
        }
        function updateWith(object, path, updater, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
        }
        function values(object) {
          return object == null ? [] : baseValues(object, keys(object));
        }
        function valuesIn(object) {
          return object == null ? [] : baseValues(object, keysIn(object));
        }
        function clamp(number, lower, upper) {
          if (upper === undefined2) {
            upper = lower;
            lower = undefined2;
          }
          if (upper !== undefined2) {
            upper = toNumber(upper);
            upper = upper === upper ? upper : 0;
          }
          if (lower !== undefined2) {
            lower = toNumber(lower);
            lower = lower === lower ? lower : 0;
          }
          return baseClamp(toNumber(number), lower, upper);
        }
        function inRange(number, start, end) {
          start = toFinite(start);
          if (end === undefined2) {
            end = start;
            start = 0;
          } else {
            end = toFinite(end);
          }
          number = toNumber(number);
          return baseInRange(number, start, end);
        }
        function random(lower, upper, floating) {
          if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
            upper = floating = undefined2;
          }
          if (floating === undefined2) {
            if (typeof upper == "boolean") {
              floating = upper;
              upper = undefined2;
            } else if (typeof lower == "boolean") {
              floating = lower;
              lower = undefined2;
            }
          }
          if (lower === undefined2 && upper === undefined2) {
            lower = 0;
            upper = 1;
          } else {
            lower = toFinite(lower);
            if (upper === undefined2) {
              upper = lower;
              lower = 0;
            } else {
              upper = toFinite(upper);
            }
          }
          if (lower > upper) {
            var temp = lower;
            lower = upper;
            upper = temp;
          }
          if (floating || lower % 1 || upper % 1) {
            var rand = nativeRandom();
            return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
          }
          return baseRandom(lower, upper);
        }
        var camelCase = createCompounder(function(result2, word, index) {
          word = word.toLowerCase();
          return result2 + (index ? capitalize(word) : word);
        });
        function capitalize(string) {
          return upperFirst(toString(string).toLowerCase());
        }
        function deburr(string) {
          string = toString(string);
          return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
        }
        function endsWith(string, target, position) {
          string = toString(string);
          target = baseToString(target);
          var length = string.length;
          position = position === undefined2 ? length : baseClamp(toInteger(position), 0, length);
          var end = position;
          position -= target.length;
          return position >= 0 && string.slice(position, end) == target;
        }
        function escape(string) {
          string = toString(string);
          return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
        }
        function escapeRegExp(string) {
          string = toString(string);
          return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
        }
        var kebabCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? "-" : "") + word.toLowerCase();
        });
        var lowerCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + word.toLowerCase();
        });
        var lowerFirst = createCaseFirst("toLowerCase");
        function pad(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          if (!length || strLength >= length) {
            return string;
          }
          var mid = (length - strLength) / 2;
          return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
        }
        function padEnd(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
        }
        function padStart(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
        }
        function parseInt2(string, radix, guard) {
          if (guard || radix == null) {
            radix = 0;
          } else if (radix) {
            radix = +radix;
          }
          return nativeParseInt(toString(string).replace(reTrimStart, ""), radix || 0);
        }
        function repeat(string, n, guard) {
          if (guard ? isIterateeCall(string, n, guard) : n === undefined2) {
            n = 1;
          } else {
            n = toInteger(n);
          }
          return baseRepeat(toString(string), n);
        }
        function replace() {
          var args = arguments, string = toString(args[0]);
          return args.length < 3 ? string : string.replace(args[1], args[2]);
        }
        var snakeCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? "_" : "") + word.toLowerCase();
        });
        function split(string, separator, limit) {
          if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) {
            separator = limit = undefined2;
          }
          limit = limit === undefined2 ? MAX_ARRAY_LENGTH : limit >>> 0;
          if (!limit) {
            return [];
          }
          string = toString(string);
          if (string && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
            separator = baseToString(separator);
            if (!separator && hasUnicode(string)) {
              return castSlice(stringToArray(string), 0, limit);
            }
          }
          return string.split(separator, limit);
        }
        var startCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + upperFirst(word);
        });
        function startsWith(string, target, position) {
          string = toString(string);
          position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
          target = baseToString(target);
          return string.slice(position, position + target.length) == target;
        }
        function template(string, options, guard) {
          var settings = lodash.templateSettings;
          if (guard && isIterateeCall(string, options, guard)) {
            options = undefined2;
          }
          string = toString(string);
          options = assignInWith({}, options, settings, customDefaultsAssignIn);
          var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
          var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
          var reDelimiters = RegExp2(
            (options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
            "g"
          );
          var sourceURL = "//# sourceURL=" + (hasOwnProperty.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
          string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
            interpolateValue || (interpolateValue = esTemplateValue);
            source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
            if (escapeValue) {
              isEscaping = true;
              source += "' +\n__e(" + escapeValue + ") +\n'";
            }
            if (evaluateValue) {
              isEvaluating = true;
              source += "';\n" + evaluateValue + ";\n__p += '";
            }
            if (interpolateValue) {
              source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
            }
            index = offset + match.length;
            return match;
          });
          source += "';\n";
          var variable = hasOwnProperty.call(options, "variable") && options.variable;
          if (!variable) {
            source = "with (obj) {\n" + source + "\n}\n";
          } else if (reForbiddenIdentifierChars.test(variable)) {
            throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
          }
          source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
          source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
          var result2 = attempt(function() {
            return Function2(importsKeys, sourceURL + "return " + source).apply(undefined2, importsValues);
          });
          result2.source = source;
          if (isError2(result2)) {
            throw result2;
          }
          return result2;
        }
        function toLower(value) {
          return toString(value).toLowerCase();
        }
        function toUpper(value) {
          return toString(value).toUpperCase();
        }
        function trim(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined2)) {
            return baseTrim(string);
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
          return castSlice(strSymbols, start, end).join("");
        }
        function trimEnd(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined2)) {
            return string.slice(0, trimmedEndIndex(string) + 1);
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
          return castSlice(strSymbols, 0, end).join("");
        }
        function trimStart(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined2)) {
            return string.replace(reTrimStart, "");
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars));
          return castSlice(strSymbols, start).join("");
        }
        function truncate(string, options) {
          var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
          if (isObject2(options)) {
            var separator = "separator" in options ? options.separator : separator;
            length = "length" in options ? toInteger(options.length) : length;
            omission = "omission" in options ? baseToString(options.omission) : omission;
          }
          string = toString(string);
          var strLength = string.length;
          if (hasUnicode(string)) {
            var strSymbols = stringToArray(string);
            strLength = strSymbols.length;
          }
          if (length >= strLength) {
            return string;
          }
          var end = length - stringSize(omission);
          if (end < 1) {
            return omission;
          }
          var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
          if (separator === undefined2) {
            return result2 + omission;
          }
          if (strSymbols) {
            end += result2.length - end;
          }
          if (isRegExp(separator)) {
            if (string.slice(end).search(separator)) {
              var match, substring = result2;
              if (!separator.global) {
                separator = RegExp2(separator.source, toString(reFlags.exec(separator)) + "g");
              }
              separator.lastIndex = 0;
              while (match = separator.exec(substring)) {
                var newEnd = match.index;
              }
              result2 = result2.slice(0, newEnd === undefined2 ? end : newEnd);
            }
          } else if (string.indexOf(baseToString(separator), end) != end) {
            var index = result2.lastIndexOf(separator);
            if (index > -1) {
              result2 = result2.slice(0, index);
            }
          }
          return result2 + omission;
        }
        function unescape(string) {
          string = toString(string);
          return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
        }
        var upperCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + word.toUpperCase();
        });
        var upperFirst = createCaseFirst("toUpperCase");
        function words(string, pattern, guard) {
          string = toString(string);
          pattern = guard ? undefined2 : pattern;
          if (pattern === undefined2) {
            return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
          }
          return string.match(pattern) || [];
        }
        var attempt = baseRest(function(func, args) {
          try {
            return apply(func, undefined2, args);
          } catch (e) {
            return isError2(e) ? e : new Error2(e);
          }
        });
        var bindAll = flatRest(function(object, methodNames) {
          arrayEach(methodNames, function(key) {
            key = toKey(key);
            baseAssignValue(object, key, bind(object[key], object));
          });
          return object;
        });
        function cond(pairs) {
          var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
          pairs = !length ? [] : arrayMap(pairs, function(pair) {
            if (typeof pair[1] != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return [toIteratee(pair[0]), pair[1]];
          });
          return baseRest(function(args) {
            var index = -1;
            while (++index < length) {
              var pair = pairs[index];
              if (apply(pair[0], this, args)) {
                return apply(pair[1], this, args);
              }
            }
          });
        }
        function conforms(source) {
          return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
        }
        function constant(value) {
          return function() {
            return value;
          };
        }
        function defaultTo(value, defaultValue) {
          return value == null || value !== value ? defaultValue : value;
        }
        var flow = createFlow();
        var flowRight = createFlow(true);
        function identity(value) {
          return value;
        }
        function iteratee(func) {
          return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
        }
        function matches(source) {
          return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
        }
        function matchesProperty(path, srcValue) {
          return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
        }
        var method = baseRest(function(path, args) {
          return function(object) {
            return baseInvoke(object, path, args);
          };
        });
        var methodOf = baseRest(function(object, args) {
          return function(path) {
            return baseInvoke(object, path, args);
          };
        });
        function mixin(object, source, options) {
          var props = keys(source), methodNames = baseFunctions(source, props);
          if (options == null && !(isObject2(source) && (methodNames.length || !props.length))) {
            options = source;
            source = object;
            object = this;
            methodNames = baseFunctions(source, keys(source));
          }
          var chain2 = !(isObject2(options) && "chain" in options) || !!options.chain, isFunc = isFunction(object);
          arrayEach(methodNames, function(methodName) {
            var func = source[methodName];
            object[methodName] = func;
            if (isFunc) {
              object.prototype[methodName] = function() {
                var chainAll = this.__chain__;
                if (chain2 || chainAll) {
                  var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                  actions.push({ "func": func, "args": arguments, "thisArg": object });
                  result2.__chain__ = chainAll;
                  return result2;
                }
                return func.apply(object, arrayPush([this.value()], arguments));
              };
            }
          });
          return object;
        }
        function noConflict() {
          if (root._ === this) {
            root._ = oldDash;
          }
          return this;
        }
        function noop() {
        }
        function nthArg(n) {
          n = toInteger(n);
          return baseRest(function(args) {
            return baseNth(args, n);
          });
        }
        var over = createOver(arrayMap);
        var overEvery = createOver(arrayEvery);
        var overSome = createOver(arraySome);
        function property(path) {
          return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
        }
        function propertyOf(object) {
          return function(path) {
            return object == null ? undefined2 : baseGet(object, path);
          };
        }
        var range = createRange();
        var rangeRight = createRange(true);
        function stubArray() {
          return [];
        }
        function stubFalse() {
          return false;
        }
        function stubObject() {
          return {};
        }
        function stubString() {
          return "";
        }
        function stubTrue() {
          return true;
        }
        function times(n, iteratee2) {
          n = toInteger(n);
          if (n < 1 || n > MAX_SAFE_INTEGER) {
            return [];
          }
          var index = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);
          iteratee2 = getIteratee(iteratee2);
          n -= MAX_ARRAY_LENGTH;
          var result2 = baseTimes(length, iteratee2);
          while (++index < n) {
            iteratee2(index);
          }
          return result2;
        }
        function toPath(value) {
          if (isArray(value)) {
            return arrayMap(value, toKey);
          }
          return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
        }
        function uniqueId(prefix) {
          var id = ++idCounter;
          return toString(prefix) + id;
        }
        var add = createMathOperation(function(augend, addend) {
          return augend + addend;
        }, 0);
        var ceil = createRound("ceil");
        var divide = createMathOperation(function(dividend, divisor) {
          return dividend / divisor;
        }, 1);
        var floor = createRound("floor");
        function max(array) {
          return array && array.length ? baseExtremum(array, identity, baseGt) : undefined2;
        }
        function maxBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined2;
        }
        function mean(array) {
          return baseMean(array, identity);
        }
        function meanBy(array, iteratee2) {
          return baseMean(array, getIteratee(iteratee2, 2));
        }
        function min(array) {
          return array && array.length ? baseExtremum(array, identity, baseLt) : undefined2;
        }
        function minBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined2;
        }
        var multiply = createMathOperation(function(multiplier, multiplicand) {
          return multiplier * multiplicand;
        }, 1);
        var round = createRound("round");
        var subtract = createMathOperation(function(minuend, subtrahend) {
          return minuend - subtrahend;
        }, 0);
        function sum(array) {
          return array && array.length ? baseSum(array, identity) : 0;
        }
        function sumBy(array, iteratee2) {
          return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
        }
        lodash.after = after;
        lodash.ary = ary;
        lodash.assign = assign;
        lodash.assignIn = assignIn;
        lodash.assignInWith = assignInWith;
        lodash.assignWith = assignWith;
        lodash.at = at;
        lodash.before = before;
        lodash.bind = bind;
        lodash.bindAll = bindAll;
        lodash.bindKey = bindKey;
        lodash.castArray = castArray;
        lodash.chain = chain;
        lodash.chunk = chunk;
        lodash.compact = compact;
        lodash.concat = concat;
        lodash.cond = cond;
        lodash.conforms = conforms;
        lodash.constant = constant;
        lodash.countBy = countBy;
        lodash.create = create;
        lodash.curry = curry;
        lodash.curryRight = curryRight;
        lodash.debounce = debounce;
        lodash.defaults = defaults;
        lodash.defaultsDeep = defaultsDeep;
        lodash.defer = defer;
        lodash.delay = delay;
        lodash.difference = difference;
        lodash.differenceBy = differenceBy;
        lodash.differenceWith = differenceWith;
        lodash.drop = drop;
        lodash.dropRight = dropRight;
        lodash.dropRightWhile = dropRightWhile;
        lodash.dropWhile = dropWhile;
        lodash.fill = fill;
        lodash.filter = filter;
        lodash.flatMap = flatMap;
        lodash.flatMapDeep = flatMapDeep;
        lodash.flatMapDepth = flatMapDepth;
        lodash.flatten = flatten;
        lodash.flattenDeep = flattenDeep;
        lodash.flattenDepth = flattenDepth;
        lodash.flip = flip;
        lodash.flow = flow;
        lodash.flowRight = flowRight;
        lodash.fromPairs = fromPairs;
        lodash.functions = functions;
        lodash.functionsIn = functionsIn;
        lodash.groupBy = groupBy;
        lodash.initial = initial;
        lodash.intersection = intersection;
        lodash.intersectionBy = intersectionBy;
        lodash.intersectionWith = intersectionWith;
        lodash.invert = invert;
        lodash.invertBy = invertBy;
        lodash.invokeMap = invokeMap;
        lodash.iteratee = iteratee;
        lodash.keyBy = keyBy;
        lodash.keys = keys;
        lodash.keysIn = keysIn;
        lodash.map = map;
        lodash.mapKeys = mapKeys;
        lodash.mapValues = mapValues;
        lodash.matches = matches;
        lodash.matchesProperty = matchesProperty;
        lodash.memoize = memoize;
        lodash.merge = merge;
        lodash.mergeWith = mergeWith;
        lodash.method = method;
        lodash.methodOf = methodOf;
        lodash.mixin = mixin;
        lodash.negate = negate;
        lodash.nthArg = nthArg;
        lodash.omit = omit;
        lodash.omitBy = omitBy;
        lodash.once = once;
        lodash.orderBy = orderBy;
        lodash.over = over;
        lodash.overArgs = overArgs;
        lodash.overEvery = overEvery;
        lodash.overSome = overSome;
        lodash.partial = partial;
        lodash.partialRight = partialRight;
        lodash.partition = partition;
        lodash.pick = pick;
        lodash.pickBy = pickBy;
        lodash.property = property;
        lodash.propertyOf = propertyOf;
        lodash.pull = pull;
        lodash.pullAll = pullAll;
        lodash.pullAllBy = pullAllBy;
        lodash.pullAllWith = pullAllWith;
        lodash.pullAt = pullAt;
        lodash.range = range;
        lodash.rangeRight = rangeRight;
        lodash.rearg = rearg;
        lodash.reject = reject;
        lodash.remove = remove;
        lodash.rest = rest;
        lodash.reverse = reverse;
        lodash.sampleSize = sampleSize;
        lodash.set = set;
        lodash.setWith = setWith;
        lodash.shuffle = shuffle;
        lodash.slice = slice;
        lodash.sortBy = sortBy;
        lodash.sortedUniq = sortedUniq;
        lodash.sortedUniqBy = sortedUniqBy;
        lodash.split = split;
        lodash.spread = spread;
        lodash.tail = tail;
        lodash.take = take;
        lodash.takeRight = takeRight;
        lodash.takeRightWhile = takeRightWhile;
        lodash.takeWhile = takeWhile;
        lodash.tap = tap;
        lodash.throttle = throttle;
        lodash.thru = thru;
        lodash.toArray = toArray;
        lodash.toPairs = toPairs;
        lodash.toPairsIn = toPairsIn;
        lodash.toPath = toPath;
        lodash.toPlainObject = toPlainObject;
        lodash.transform = transform;
        lodash.unary = unary;
        lodash.union = union;
        lodash.unionBy = unionBy;
        lodash.unionWith = unionWith;
        lodash.uniq = uniq;
        lodash.uniqBy = uniqBy;
        lodash.uniqWith = uniqWith;
        lodash.unset = unset;
        lodash.unzip = unzip;
        lodash.unzipWith = unzipWith;
        lodash.update = update;
        lodash.updateWith = updateWith;
        lodash.values = values;
        lodash.valuesIn = valuesIn;
        lodash.without = without;
        lodash.words = words;
        lodash.wrap = wrap;
        lodash.xor = xor;
        lodash.xorBy = xorBy;
        lodash.xorWith = xorWith;
        lodash.zip = zip;
        lodash.zipObject = zipObject;
        lodash.zipObjectDeep = zipObjectDeep;
        lodash.zipWith = zipWith;
        lodash.entries = toPairs;
        lodash.entriesIn = toPairsIn;
        lodash.extend = assignIn;
        lodash.extendWith = assignInWith;
        mixin(lodash, lodash);
        lodash.add = add;
        lodash.attempt = attempt;
        lodash.camelCase = camelCase;
        lodash.capitalize = capitalize;
        lodash.ceil = ceil;
        lodash.clamp = clamp;
        lodash.clone = clone;
        lodash.cloneDeep = cloneDeep;
        lodash.cloneDeepWith = cloneDeepWith;
        lodash.cloneWith = cloneWith;
        lodash.conformsTo = conformsTo;
        lodash.deburr = deburr;
        lodash.defaultTo = defaultTo;
        lodash.divide = divide;
        lodash.endsWith = endsWith;
        lodash.eq = eq;
        lodash.escape = escape;
        lodash.escapeRegExp = escapeRegExp;
        lodash.every = every;
        lodash.find = find;
        lodash.findIndex = findIndex;
        lodash.findKey = findKey;
        lodash.findLast = findLast;
        lodash.findLastIndex = findLastIndex;
        lodash.findLastKey = findLastKey;
        lodash.floor = floor;
        lodash.forEach = forEach;
        lodash.forEachRight = forEachRight;
        lodash.forIn = forIn;
        lodash.forInRight = forInRight;
        lodash.forOwn = forOwn;
        lodash.forOwnRight = forOwnRight;
        lodash.get = get;
        lodash.gt = gt;
        lodash.gte = gte;
        lodash.has = has;
        lodash.hasIn = hasIn;
        lodash.head = head;
        lodash.identity = identity;
        lodash.includes = includes;
        lodash.indexOf = indexOf;
        lodash.inRange = inRange;
        lodash.invoke = invoke;
        lodash.isArguments = isArguments;
        lodash.isArray = isArray;
        lodash.isArrayBuffer = isArrayBuffer;
        lodash.isArrayLike = isArrayLike;
        lodash.isArrayLikeObject = isArrayLikeObject;
        lodash.isBoolean = isBoolean;
        lodash.isBuffer = isBuffer;
        lodash.isDate = isDate;
        lodash.isElement = isElement;
        lodash.isEmpty = isEmpty;
        lodash.isEqual = isEqual;
        lodash.isEqualWith = isEqualWith;
        lodash.isError = isError2;
        lodash.isFinite = isFinite2;
        lodash.isFunction = isFunction;
        lodash.isInteger = isInteger;
        lodash.isLength = isLength;
        lodash.isMap = isMap;
        lodash.isMatch = isMatch;
        lodash.isMatchWith = isMatchWith;
        lodash.isNaN = isNaN2;
        lodash.isNative = isNative;
        lodash.isNil = isNil;
        lodash.isNull = isNull;
        lodash.isNumber = isNumber;
        lodash.isObject = isObject2;
        lodash.isObjectLike = isObjectLike;
        lodash.isPlainObject = isPlainObject;
        lodash.isRegExp = isRegExp;
        lodash.isSafeInteger = isSafeInteger;
        lodash.isSet = isSet;
        lodash.isString = isString;
        lodash.isSymbol = isSymbol;
        lodash.isTypedArray = isTypedArray;
        lodash.isUndefined = isUndefined;
        lodash.isWeakMap = isWeakMap;
        lodash.isWeakSet = isWeakSet;
        lodash.join = join;
        lodash.kebabCase = kebabCase;
        lodash.last = last;
        lodash.lastIndexOf = lastIndexOf;
        lodash.lowerCase = lowerCase;
        lodash.lowerFirst = lowerFirst;
        lodash.lt = lt;
        lodash.lte = lte;
        lodash.max = max;
        lodash.maxBy = maxBy;
        lodash.mean = mean;
        lodash.meanBy = meanBy;
        lodash.min = min;
        lodash.minBy = minBy;
        lodash.stubArray = stubArray;
        lodash.stubFalse = stubFalse;
        lodash.stubObject = stubObject;
        lodash.stubString = stubString;
        lodash.stubTrue = stubTrue;
        lodash.multiply = multiply;
        lodash.nth = nth;
        lodash.noConflict = noConflict;
        lodash.noop = noop;
        lodash.now = now;
        lodash.pad = pad;
        lodash.padEnd = padEnd;
        lodash.padStart = padStart;
        lodash.parseInt = parseInt2;
        lodash.random = random;
        lodash.reduce = reduce;
        lodash.reduceRight = reduceRight;
        lodash.repeat = repeat;
        lodash.replace = replace;
        lodash.result = result;
        lodash.round = round;
        lodash.runInContext = runInContext2;
        lodash.sample = sample;
        lodash.size = size;
        lodash.snakeCase = snakeCase;
        lodash.some = some;
        lodash.sortedIndex = sortedIndex;
        lodash.sortedIndexBy = sortedIndexBy;
        lodash.sortedIndexOf = sortedIndexOf;
        lodash.sortedLastIndex = sortedLastIndex;
        lodash.sortedLastIndexBy = sortedLastIndexBy;
        lodash.sortedLastIndexOf = sortedLastIndexOf;
        lodash.startCase = startCase;
        lodash.startsWith = startsWith;
        lodash.subtract = subtract;
        lodash.sum = sum;
        lodash.sumBy = sumBy;
        lodash.template = template;
        lodash.times = times;
        lodash.toFinite = toFinite;
        lodash.toInteger = toInteger;
        lodash.toLength = toLength;
        lodash.toLower = toLower;
        lodash.toNumber = toNumber;
        lodash.toSafeInteger = toSafeInteger;
        lodash.toString = toString;
        lodash.toUpper = toUpper;
        lodash.trim = trim;
        lodash.trimEnd = trimEnd;
        lodash.trimStart = trimStart;
        lodash.truncate = truncate;
        lodash.unescape = unescape;
        lodash.uniqueId = uniqueId;
        lodash.upperCase = upperCase;
        lodash.upperFirst = upperFirst;
        lodash.each = forEach;
        lodash.eachRight = forEachRight;
        lodash.first = head;
        mixin(lodash, function() {
          var source = {};
          baseForOwn(lodash, function(func, methodName) {
            if (!hasOwnProperty.call(lodash.prototype, methodName)) {
              source[methodName] = func;
            }
          });
          return source;
        }(), { "chain": false });
        lodash.VERSION = VERSION;
        arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
          lodash[methodName].placeholder = lodash;
        });
        arrayEach(["drop", "take"], function(methodName, index) {
          LazyWrapper.prototype[methodName] = function(n) {
            n = n === undefined2 ? 1 : nativeMax(toInteger(n), 0);
            var result2 = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
            if (result2.__filtered__) {
              result2.__takeCount__ = nativeMin(n, result2.__takeCount__);
            } else {
              result2.__views__.push({
                "size": nativeMin(n, MAX_ARRAY_LENGTH),
                "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
              });
            }
            return result2;
          };
          LazyWrapper.prototype[methodName + "Right"] = function(n) {
            return this.reverse()[methodName](n).reverse();
          };
        });
        arrayEach(["filter", "map", "takeWhile"], function(methodName, index) {
          var type = index + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
          LazyWrapper.prototype[methodName] = function(iteratee2) {
            var result2 = this.clone();
            result2.__iteratees__.push({
              "iteratee": getIteratee(iteratee2, 3),
              "type": type
            });
            result2.__filtered__ = result2.__filtered__ || isFilter;
            return result2;
          };
        });
        arrayEach(["head", "last"], function(methodName, index) {
          var takeName = "take" + (index ? "Right" : "");
          LazyWrapper.prototype[methodName] = function() {
            return this[takeName](1).value()[0];
          };
        });
        arrayEach(["initial", "tail"], function(methodName, index) {
          var dropName = "drop" + (index ? "" : "Right");
          LazyWrapper.prototype[methodName] = function() {
            return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
          };
        });
        LazyWrapper.prototype.compact = function() {
          return this.filter(identity);
        };
        LazyWrapper.prototype.find = function(predicate) {
          return this.filter(predicate).head();
        };
        LazyWrapper.prototype.findLast = function(predicate) {
          return this.reverse().find(predicate);
        };
        LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
          if (typeof path == "function") {
            return new LazyWrapper(this);
          }
          return this.map(function(value) {
            return baseInvoke(value, path, args);
          });
        });
        LazyWrapper.prototype.reject = function(predicate) {
          return this.filter(negate(getIteratee(predicate)));
        };
        LazyWrapper.prototype.slice = function(start, end) {
          start = toInteger(start);
          var result2 = this;
          if (result2.__filtered__ && (start > 0 || end < 0)) {
            return new LazyWrapper(result2);
          }
          if (start < 0) {
            result2 = result2.takeRight(-start);
          } else if (start) {
            result2 = result2.drop(start);
          }
          if (end !== undefined2) {
            end = toInteger(end);
            result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
          }
          return result2;
        };
        LazyWrapper.prototype.takeRightWhile = function(predicate) {
          return this.reverse().takeWhile(predicate).reverse();
        };
        LazyWrapper.prototype.toArray = function() {
          return this.take(MAX_ARRAY_LENGTH);
        };
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
          if (!lodashFunc) {
            return;
          }
          lodash.prototype[methodName] = function() {
            var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray(value);
            var interceptor = function(value2) {
              var result3 = lodashFunc.apply(lodash, arrayPush([value2], args));
              return isTaker && chainAll ? result3[0] : result3;
            };
            if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
              isLazy = useLazy = false;
            }
            var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
            if (!retUnwrapped && useLazy) {
              value = onlyLazy ? value : new LazyWrapper(this);
              var result2 = func.apply(value, args);
              result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined2 });
              return new LodashWrapper(result2, chainAll);
            }
            if (isUnwrapped && onlyLazy) {
              return func.apply(this, args);
            }
            result2 = this.thru(interceptor);
            return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
          };
        });
        arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
          var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
          lodash.prototype[methodName] = function() {
            var args = arguments;
            if (retUnwrapped && !this.__chain__) {
              var value = this.value();
              return func.apply(isArray(value) ? value : [], args);
            }
            return this[chainName](function(value2) {
              return func.apply(isArray(value2) ? value2 : [], args);
            });
          };
        });
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var lodashFunc = lodash[methodName];
          if (lodashFunc) {
            var key = lodashFunc.name + "";
            if (!hasOwnProperty.call(realNames, key)) {
              realNames[key] = [];
            }
            realNames[key].push({ "name": methodName, "func": lodashFunc });
          }
        });
        realNames[createHybrid(undefined2, WRAP_BIND_KEY_FLAG).name] = [{
          "name": "wrapper",
          "func": undefined2
        }];
        LazyWrapper.prototype.clone = lazyClone;
        LazyWrapper.prototype.reverse = lazyReverse;
        LazyWrapper.prototype.value = lazyValue;
        lodash.prototype.at = wrapperAt;
        lodash.prototype.chain = wrapperChain;
        lodash.prototype.commit = wrapperCommit;
        lodash.prototype.next = wrapperNext;
        lodash.prototype.plant = wrapperPlant;
        lodash.prototype.reverse = wrapperReverse;
        lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
        lodash.prototype.first = lodash.prototype.head;
        if (symIterator) {
          lodash.prototype[symIterator] = wrapperToIterator;
        }
        return lodash;
      };
      var _ = runInContext();
      if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
        root._ = _;
        define(function() {
          return _;
        });
      } else if (freeModule) {
        (freeModule.exports = _)._ = _;
        freeExports._ = _;
      } else {
        root._ = _;
      }
    }).call(exports2);
  }
});

// browser-external:fs
var require_fs = __commonJS({
  "browser-external:fs"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "fs" has been externalized for browser compatibility. Cannot access "fs.${key}" in client code.`);
        }
      }
    }));
  }
});

// browser-external:path
var require_path = __commonJS({
  "browser-external:path"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "path" has been externalized for browser compatibility. Cannot access "path.${key}" in client code.`);
        }
      }
    }));
  }
});

// node_modules/better-sqlite3/lib/util.js
var require_util = __commonJS({
  "node_modules/better-sqlite3/lib/util.js"(exports2) {
    "use strict";
    exports2.getBooleanOption = (options, key) => {
      let value = false;
      if (key in options && typeof (value = options[key]) !== "boolean") {
        throw new TypeError(`Expected the "${key}" option to be a boolean`);
      }
      return value;
    };
    exports2.cppdb = Symbol();
    exports2.inspect = Symbol.for("nodejs.util.inspect.custom");
  }
});

// node_modules/better-sqlite3/lib/sqlite-error.js
var require_sqlite_error = __commonJS({
  "node_modules/better-sqlite3/lib/sqlite-error.js"(exports2, module2) {
    "use strict";
    var descriptor = { value: "SqliteError", writable: true, enumerable: false, configurable: true };
    function SqliteError(message, code) {
      if (new.target !== SqliteError) {
        return new SqliteError(message, code);
      }
      if (typeof code !== "string") {
        throw new TypeError("Expected second argument to be a string");
      }
      Error.call(this, message);
      descriptor.value = "" + message;
      Object.defineProperty(this, "message", descriptor);
      Error.captureStackTrace(this, SqliteError);
      this.code = code;
    }
    Object.setPrototypeOf(SqliteError, Error);
    Object.setPrototypeOf(SqliteError.prototype, Error.prototype);
    Object.defineProperty(SqliteError.prototype, "name", descriptor);
    module2.exports = SqliteError;
  }
});

// node_modules/file-uri-to-path/index.js
var require_file_uri_to_path = __commonJS({
  "node_modules/file-uri-to-path/index.js"(exports2, module2) {
    var sep = require_path().sep || "/";
    module2.exports = fileUriToPath;
    function fileUriToPath(uri) {
      if ("string" != typeof uri || uri.length <= 7 || "file://" != uri.substring(0, 7)) {
        throw new TypeError("must pass in a file:// URI to convert to a file path");
      }
      var rest = decodeURI(uri.substring(7));
      var firstSlash = rest.indexOf("/");
      var host = rest.substring(0, firstSlash);
      var path = rest.substring(firstSlash + 1);
      if ("localhost" == host)
        host = "";
      if (host) {
        host = sep + sep + host;
      }
      path = path.replace(/^(.+)\|/, "$1:");
      if (sep == "\\") {
        path = path.replace(/\//g, "\\");
      }
      if (/^.+\:/.test(path)) {
      } else {
        path = sep + path;
      }
      return host + path;
    }
  }
});

// node_modules/bindings/bindings.js
var require_bindings = __commonJS({
  "node_modules/bindings/bindings.js"(exports2, module2) {
    var fs = require_fs();
    var path = require_path();
    var fileURLToPath = require_file_uri_to_path();
    var join = path.join;
    var dirname = path.dirname;
    var exists = fs.accessSync && function(path2) {
      try {
        fs.accessSync(path2);
      } catch (e) {
        return false;
      }
      return true;
    } || fs.existsSync || path.existsSync;
    var defaults = {
      arrow: process.env.NODE_BINDINGS_ARROW || " → ",
      compiled: process.env.NODE_BINDINGS_COMPILED_DIR || "compiled",
      platform: process.platform,
      arch: process.arch,
      nodePreGyp: "node-v" + process.versions.modules + "-" + process.platform + "-" + process.arch,
      version: process.versions.node,
      bindings: "bindings.node",
      try: [
        // node-gyp's linked version in the "build" dir
        ["module_root", "build", "bindings"],
        // node-waf and gyp_addon (a.k.a node-gyp)
        ["module_root", "build", "Debug", "bindings"],
        ["module_root", "build", "Release", "bindings"],
        // Debug files, for development (legacy behavior, remove for node v0.9)
        ["module_root", "out", "Debug", "bindings"],
        ["module_root", "Debug", "bindings"],
        // Release files, but manually compiled (legacy behavior, remove for node v0.9)
        ["module_root", "out", "Release", "bindings"],
        ["module_root", "Release", "bindings"],
        // Legacy from node-waf, node <= 0.4.x
        ["module_root", "build", "default", "bindings"],
        // Production "Release" buildtype binary (meh...)
        ["module_root", "compiled", "version", "platform", "arch", "bindings"],
        // node-qbs builds
        ["module_root", "addon-build", "release", "install-root", "bindings"],
        ["module_root", "addon-build", "debug", "install-root", "bindings"],
        ["module_root", "addon-build", "default", "install-root", "bindings"],
        // node-pre-gyp path ./lib/binding/{node_abi}-{platform}-{arch}
        ["module_root", "lib", "binding", "nodePreGyp", "bindings"]
      ]
    };
    function bindings(opts) {
      if (typeof opts == "string") {
        opts = { bindings: opts };
      } else if (!opts) {
        opts = {};
      }
      Object.keys(defaults).map(function(i2) {
        if (!(i2 in opts))
          opts[i2] = defaults[i2];
      });
      if (!opts.module_root) {
        opts.module_root = exports2.getRoot(exports2.getFileName());
      }
      if (path.extname(opts.bindings) != ".node") {
        opts.bindings += ".node";
      }
      var requireFunc = typeof __webpack_require__ === "function" ? __non_webpack_require__ : __require;
      var tries = [], i = 0, l = opts.try.length, n, b, err;
      for (; i < l; i++) {
        n = join.apply(
          null,
          opts.try[i].map(function(p) {
            return opts[p] || p;
          })
        );
        tries.push(n);
        try {
          b = opts.path ? requireFunc.resolve(n) : requireFunc(n);
          if (!opts.path) {
            b.path = n;
          }
          return b;
        } catch (e) {
          if (e.code !== "MODULE_NOT_FOUND" && e.code !== "QUALIFIED_PATH_RESOLUTION_FAILED" && !/not find/i.test(e.message)) {
            throw e;
          }
        }
      }
      err = new Error(
        "Could not locate the bindings file. Tried:\n" + tries.map(function(a) {
          return opts.arrow + a;
        }).join("\n")
      );
      err.tries = tries;
      throw err;
    }
    module2.exports = exports2 = bindings;
    exports2.getFileName = function getFileName(calling_file) {
      var origPST = Error.prepareStackTrace, origSTL = Error.stackTraceLimit, dummy = {}, fileName;
      Error.stackTraceLimit = 10;
      Error.prepareStackTrace = function(e, st) {
        for (var i = 0, l = st.length; i < l; i++) {
          fileName = st[i].getFileName();
          if (fileName !== __filename) {
            if (calling_file) {
              if (fileName !== calling_file) {
                return;
              }
            } else {
              return;
            }
          }
        }
      };
      Error.captureStackTrace(dummy);
      dummy.stack;
      Error.prepareStackTrace = origPST;
      Error.stackTraceLimit = origSTL;
      var fileSchema = "file://";
      if (fileName.indexOf(fileSchema) === 0) {
        fileName = fileURLToPath(fileName);
      }
      return fileName;
    };
    exports2.getRoot = function getRoot(file) {
      var dir = dirname(file), prev;
      while (true) {
        if (dir === ".") {
          dir = process.cwd();
        }
        if (exists(join(dir, "package.json")) || exists(join(dir, "node_modules"))) {
          return dir;
        }
        if (prev === dir) {
          throw new Error(
            'Could not find module root given file: "' + file + '". Do you have a `package.json` file? '
          );
        }
        prev = dir;
        dir = join(dir, "..");
      }
    };
  }
});

// node_modules/better-sqlite3/lib/methods/wrappers.js
var require_wrappers = __commonJS({
  "node_modules/better-sqlite3/lib/methods/wrappers.js"(exports2) {
    "use strict";
    var { cppdb } = require_util();
    exports2.prepare = function prepare(sql) {
      return this[cppdb].prepare(sql, this, false);
    };
    exports2.exec = function exec(sql) {
      this[cppdb].exec(sql);
      return this;
    };
    exports2.close = function close() {
      this[cppdb].close();
      return this;
    };
    exports2.loadExtension = function loadExtension(...args) {
      this[cppdb].loadExtension(...args);
      return this;
    };
    exports2.defaultSafeIntegers = function defaultSafeIntegers(...args) {
      this[cppdb].defaultSafeIntegers(...args);
      return this;
    };
    exports2.unsafeMode = function unsafeMode(...args) {
      this[cppdb].unsafeMode(...args);
      return this;
    };
    exports2.getters = {
      name: {
        get: function name() {
          return this[cppdb].name;
        },
        enumerable: true
      },
      open: {
        get: function open() {
          return this[cppdb].open;
        },
        enumerable: true
      },
      inTransaction: {
        get: function inTransaction() {
          return this[cppdb].inTransaction;
        },
        enumerable: true
      },
      readonly: {
        get: function readonly() {
          return this[cppdb].readonly;
        },
        enumerable: true
      },
      memory: {
        get: function memory() {
          return this[cppdb].memory;
        },
        enumerable: true
      }
    };
  }
});

// node_modules/better-sqlite3/lib/methods/transaction.js
var require_transaction = __commonJS({
  "node_modules/better-sqlite3/lib/methods/transaction.js"(exports2, module2) {
    "use strict";
    var { cppdb } = require_util();
    var controllers = /* @__PURE__ */ new WeakMap();
    module2.exports = function transaction(fn) {
      if (typeof fn !== "function")
        throw new TypeError("Expected first argument to be a function");
      const db = this[cppdb];
      const controller = getController(db, this);
      const { apply } = Function.prototype;
      const properties = {
        default: { value: wrapTransaction(apply, fn, db, controller.default) },
        deferred: { value: wrapTransaction(apply, fn, db, controller.deferred) },
        immediate: { value: wrapTransaction(apply, fn, db, controller.immediate) },
        exclusive: { value: wrapTransaction(apply, fn, db, controller.exclusive) },
        database: { value: this, enumerable: true }
      };
      Object.defineProperties(properties.default.value, properties);
      Object.defineProperties(properties.deferred.value, properties);
      Object.defineProperties(properties.immediate.value, properties);
      Object.defineProperties(properties.exclusive.value, properties);
      return properties.default.value;
    };
    var getController = (db, self2) => {
      let controller = controllers.get(db);
      if (!controller) {
        const shared = {
          commit: db.prepare("COMMIT", self2, false),
          rollback: db.prepare("ROLLBACK", self2, false),
          savepoint: db.prepare("SAVEPOINT `	_bs3.	`", self2, false),
          release: db.prepare("RELEASE `	_bs3.	`", self2, false),
          rollbackTo: db.prepare("ROLLBACK TO `	_bs3.	`", self2, false)
        };
        controllers.set(db, controller = {
          default: Object.assign({ begin: db.prepare("BEGIN", self2, false) }, shared),
          deferred: Object.assign({ begin: db.prepare("BEGIN DEFERRED", self2, false) }, shared),
          immediate: Object.assign({ begin: db.prepare("BEGIN IMMEDIATE", self2, false) }, shared),
          exclusive: Object.assign({ begin: db.prepare("BEGIN EXCLUSIVE", self2, false) }, shared)
        });
      }
      return controller;
    };
    var wrapTransaction = (apply, fn, db, { begin, commit, rollback, savepoint, release, rollbackTo }) => function sqliteTransaction() {
      let before, after, undo;
      if (db.inTransaction) {
        before = savepoint;
        after = release;
        undo = rollbackTo;
      } else {
        before = begin;
        after = commit;
        undo = rollback;
      }
      before.run();
      try {
        const result = apply.call(fn, this, arguments);
        after.run();
        return result;
      } catch (ex) {
        if (db.inTransaction) {
          undo.run();
          if (undo !== rollback)
            after.run();
        }
        throw ex;
      }
    };
  }
});

// node_modules/better-sqlite3/lib/methods/pragma.js
var require_pragma = __commonJS({
  "node_modules/better-sqlite3/lib/methods/pragma.js"(exports2, module2) {
    "use strict";
    var { getBooleanOption, cppdb } = require_util();
    module2.exports = function pragma(source, options) {
      if (options == null)
        options = {};
      if (typeof source !== "string")
        throw new TypeError("Expected first argument to be a string");
      if (typeof options !== "object")
        throw new TypeError("Expected second argument to be an options object");
      const simple = getBooleanOption(options, "simple");
      const stmt = this[cppdb].prepare(`PRAGMA ${source}`, this, true);
      return simple ? stmt.pluck().get() : stmt.all();
    };
  }
});

// browser-external:util
var require_util2 = __commonJS({
  "browser-external:util"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "util" has been externalized for browser compatibility. Cannot access "util.${key}" in client code.`);
        }
      }
    }));
  }
});

// node_modules/better-sqlite3/lib/methods/backup.js
var require_backup = __commonJS({
  "node_modules/better-sqlite3/lib/methods/backup.js"(exports2, module2) {
    "use strict";
    var fs = require_fs();
    var path = require_path();
    var { promisify } = require_util2();
    var { cppdb } = require_util();
    var fsAccess = promisify(fs.access);
    module2.exports = async function backup(filename, options) {
      if (options == null)
        options = {};
      if (typeof filename !== "string")
        throw new TypeError("Expected first argument to be a string");
      if (typeof options !== "object")
        throw new TypeError("Expected second argument to be an options object");
      filename = filename.trim();
      const attachedName = "attached" in options ? options.attached : "main";
      const handler = "progress" in options ? options.progress : null;
      if (!filename)
        throw new TypeError("Backup filename cannot be an empty string");
      if (filename === ":memory:")
        throw new TypeError('Invalid backup filename ":memory:"');
      if (typeof attachedName !== "string")
        throw new TypeError('Expected the "attached" option to be a string');
      if (!attachedName)
        throw new TypeError('The "attached" option cannot be an empty string');
      if (handler != null && typeof handler !== "function")
        throw new TypeError('Expected the "progress" option to be a function');
      await fsAccess(path.dirname(filename)).catch(() => {
        throw new TypeError("Cannot save backup because the directory does not exist");
      });
      const isNewFile = await fsAccess(filename).then(() => false, () => true);
      return runBackup(this[cppdb].backup(this, attachedName, filename, isNewFile), handler || null);
    };
    var runBackup = (backup, handler) => {
      let rate = 0;
      let useDefault = true;
      return new Promise((resolve, reject) => {
        setImmediate(function step() {
          try {
            const progress = backup.transfer(rate);
            if (!progress.remainingPages) {
              backup.close();
              resolve(progress);
              return;
            }
            if (useDefault) {
              useDefault = false;
              rate = 100;
            }
            if (handler) {
              const ret2 = handler(progress);
              if (ret2 !== void 0) {
                if (typeof ret2 === "number" && ret2 === ret2)
                  rate = Math.max(0, Math.min(2147483647, Math.round(ret2)));
                else
                  throw new TypeError("Expected progress callback to return a number or undefined");
              }
            }
            setImmediate(step);
          } catch (err) {
            backup.close();
            reject(err);
          }
        });
      });
    };
  }
});

// node_modules/better-sqlite3/lib/methods/serialize.js
var require_serialize = __commonJS({
  "node_modules/better-sqlite3/lib/methods/serialize.js"(exports2, module2) {
    "use strict";
    var { cppdb } = require_util();
    module2.exports = function serialize(options) {
      if (options == null)
        options = {};
      if (typeof options !== "object")
        throw new TypeError("Expected first argument to be an options object");
      const attachedName = "attached" in options ? options.attached : "main";
      if (typeof attachedName !== "string")
        throw new TypeError('Expected the "attached" option to be a string');
      if (!attachedName)
        throw new TypeError('The "attached" option cannot be an empty string');
      return this[cppdb].serialize(attachedName);
    };
  }
});

// node_modules/better-sqlite3/lib/methods/function.js
var require_function = __commonJS({
  "node_modules/better-sqlite3/lib/methods/function.js"(exports2, module2) {
    "use strict";
    var { getBooleanOption, cppdb } = require_util();
    module2.exports = function defineFunction(name, options, fn) {
      if (options == null)
        options = {};
      if (typeof options === "function") {
        fn = options;
        options = {};
      }
      if (typeof name !== "string")
        throw new TypeError("Expected first argument to be a string");
      if (typeof fn !== "function")
        throw new TypeError("Expected last argument to be a function");
      if (typeof options !== "object")
        throw new TypeError("Expected second argument to be an options object");
      if (!name)
        throw new TypeError("User-defined function name cannot be an empty string");
      const safeIntegers = "safeIntegers" in options ? +getBooleanOption(options, "safeIntegers") : 2;
      const deterministic = getBooleanOption(options, "deterministic");
      const directOnly = getBooleanOption(options, "directOnly");
      const varargs = getBooleanOption(options, "varargs");
      let argCount = -1;
      if (!varargs) {
        argCount = fn.length;
        if (!Number.isInteger(argCount) || argCount < 0)
          throw new TypeError("Expected function.length to be a positive integer");
        if (argCount > 100)
          throw new RangeError("User-defined functions cannot have more than 100 arguments");
      }
      this[cppdb].function(fn, name, argCount, safeIntegers, deterministic, directOnly);
      return this;
    };
  }
});

// node_modules/better-sqlite3/lib/methods/aggregate.js
var require_aggregate = __commonJS({
  "node_modules/better-sqlite3/lib/methods/aggregate.js"(exports2, module2) {
    "use strict";
    var { getBooleanOption, cppdb } = require_util();
    module2.exports = function defineAggregate(name, options) {
      if (typeof name !== "string")
        throw new TypeError("Expected first argument to be a string");
      if (typeof options !== "object" || options === null)
        throw new TypeError("Expected second argument to be an options object");
      if (!name)
        throw new TypeError("User-defined function name cannot be an empty string");
      const start = "start" in options ? options.start : null;
      const step = getFunctionOption(options, "step", true);
      const inverse = getFunctionOption(options, "inverse", false);
      const result = getFunctionOption(options, "result", false);
      const safeIntegers = "safeIntegers" in options ? +getBooleanOption(options, "safeIntegers") : 2;
      const deterministic = getBooleanOption(options, "deterministic");
      const directOnly = getBooleanOption(options, "directOnly");
      const varargs = getBooleanOption(options, "varargs");
      let argCount = -1;
      if (!varargs) {
        argCount = Math.max(getLength(step), inverse ? getLength(inverse) : 0);
        if (argCount > 0)
          argCount -= 1;
        if (argCount > 100)
          throw new RangeError("User-defined functions cannot have more than 100 arguments");
      }
      this[cppdb].aggregate(start, step, inverse, result, name, argCount, safeIntegers, deterministic, directOnly);
      return this;
    };
    var getFunctionOption = (options, key, required) => {
      const value = key in options ? options[key] : null;
      if (typeof value === "function")
        return value;
      if (value != null)
        throw new TypeError(`Expected the "${key}" option to be a function`);
      if (required)
        throw new TypeError(`Missing required option "${key}"`);
      return null;
    };
    var getLength = ({ length }) => {
      if (Number.isInteger(length) && length >= 0)
        return length;
      throw new TypeError("Expected function.length to be a positive integer");
    };
  }
});

// node_modules/better-sqlite3/lib/methods/table.js
var require_table = __commonJS({
  "node_modules/better-sqlite3/lib/methods/table.js"(exports2, module2) {
    "use strict";
    var { cppdb } = require_util();
    module2.exports = function defineTable(name, factory) {
      if (typeof name !== "string")
        throw new TypeError("Expected first argument to be a string");
      if (!name)
        throw new TypeError("Virtual table module name cannot be an empty string");
      let eponymous = false;
      if (typeof factory === "object" && factory !== null) {
        eponymous = true;
        factory = defer(parseTableDefinition(factory, "used", name));
      } else {
        if (typeof factory !== "function")
          throw new TypeError("Expected second argument to be a function or a table definition object");
        factory = wrapFactory(factory);
      }
      this[cppdb].table(factory, name, eponymous);
      return this;
    };
    function wrapFactory(factory) {
      return function virtualTableFactory(moduleName, databaseName, tableName, ...args) {
        const thisObject = {
          module: moduleName,
          database: databaseName,
          table: tableName
        };
        const def = apply.call(factory, thisObject, args);
        if (typeof def !== "object" || def === null) {
          throw new TypeError(`Virtual table module "${moduleName}" did not return a table definition object`);
        }
        return parseTableDefinition(def, "returned", moduleName);
      };
    }
    function parseTableDefinition(def, verb, moduleName) {
      if (!hasOwnProperty.call(def, "rows")) {
        throw new TypeError(`Virtual table module "${moduleName}" ${verb} a table definition without a "rows" property`);
      }
      if (!hasOwnProperty.call(def, "columns")) {
        throw new TypeError(`Virtual table module "${moduleName}" ${verb} a table definition without a "columns" property`);
      }
      const rows = def.rows;
      if (typeof rows !== "function" || Object.getPrototypeOf(rows) !== GeneratorFunctionPrototype) {
        throw new TypeError(`Virtual table module "${moduleName}" ${verb} a table definition with an invalid "rows" property (should be a generator function)`);
      }
      let columns = def.columns;
      if (!Array.isArray(columns) || !(columns = [...columns]).every((x) => typeof x === "string")) {
        throw new TypeError(`Virtual table module "${moduleName}" ${verb} a table definition with an invalid "columns" property (should be an array of strings)`);
      }
      if (columns.length !== new Set(columns).size) {
        throw new TypeError(`Virtual table module "${moduleName}" ${verb} a table definition with duplicate column names`);
      }
      if (!columns.length) {
        throw new RangeError(`Virtual table module "${moduleName}" ${verb} a table definition with zero columns`);
      }
      let parameters;
      if (hasOwnProperty.call(def, "parameters")) {
        parameters = def.parameters;
        if (!Array.isArray(parameters) || !(parameters = [...parameters]).every((x) => typeof x === "string")) {
          throw new TypeError(`Virtual table module "${moduleName}" ${verb} a table definition with an invalid "parameters" property (should be an array of strings)`);
        }
      } else {
        parameters = inferParameters(rows);
      }
      if (parameters.length !== new Set(parameters).size) {
        throw new TypeError(`Virtual table module "${moduleName}" ${verb} a table definition with duplicate parameter names`);
      }
      if (parameters.length > 32) {
        throw new RangeError(`Virtual table module "${moduleName}" ${verb} a table definition with more than the maximum number of 32 parameters`);
      }
      for (const parameter of parameters) {
        if (columns.includes(parameter)) {
          throw new TypeError(`Virtual table module "${moduleName}" ${verb} a table definition with column "${parameter}" which was ambiguously defined as both a column and parameter`);
        }
      }
      let safeIntegers = 2;
      if (hasOwnProperty.call(def, "safeIntegers")) {
        const bool = def.safeIntegers;
        if (typeof bool !== "boolean") {
          throw new TypeError(`Virtual table module "${moduleName}" ${verb} a table definition with an invalid "safeIntegers" property (should be a boolean)`);
        }
        safeIntegers = +bool;
      }
      let directOnly = false;
      if (hasOwnProperty.call(def, "directOnly")) {
        directOnly = def.directOnly;
        if (typeof directOnly !== "boolean") {
          throw new TypeError(`Virtual table module "${moduleName}" ${verb} a table definition with an invalid "directOnly" property (should be a boolean)`);
        }
      }
      const columnDefinitions = [
        ...parameters.map(identifier).map((str) => `${str} HIDDEN`),
        ...columns.map(identifier)
      ];
      return [
        `CREATE TABLE x(${columnDefinitions.join(", ")});`,
        wrapGenerator(rows, new Map(columns.map((x, i) => [x, parameters.length + i])), moduleName),
        parameters,
        safeIntegers,
        directOnly
      ];
    }
    function wrapGenerator(generator, columnMap, moduleName) {
      return function* virtualTable(...args) {
        const output = args.map((x) => Buffer.isBuffer(x) ? Buffer.from(x) : x);
        for (let i = 0; i < columnMap.size; ++i) {
          output.push(null);
        }
        for (const row of generator(...args)) {
          if (Array.isArray(row)) {
            extractRowArray(row, output, columnMap.size, moduleName);
            yield output;
          } else if (typeof row === "object" && row !== null) {
            extractRowObject(row, output, columnMap, moduleName);
            yield output;
          } else {
            throw new TypeError(`Virtual table module "${moduleName}" yielded something that isn't a valid row object`);
          }
        }
      };
    }
    function extractRowArray(row, output, columnCount, moduleName) {
      if (row.length !== columnCount) {
        throw new TypeError(`Virtual table module "${moduleName}" yielded a row with an incorrect number of columns`);
      }
      const offset = output.length - columnCount;
      for (let i = 0; i < columnCount; ++i) {
        output[i + offset] = row[i];
      }
    }
    function extractRowObject(row, output, columnMap, moduleName) {
      let count = 0;
      for (const key of Object.keys(row)) {
        const index = columnMap.get(key);
        if (index === void 0) {
          throw new TypeError(`Virtual table module "${moduleName}" yielded a row with an undeclared column "${key}"`);
        }
        output[index] = row[key];
        count += 1;
      }
      if (count !== columnMap.size) {
        throw new TypeError(`Virtual table module "${moduleName}" yielded a row with missing columns`);
      }
    }
    function inferParameters({ length }) {
      if (!Number.isInteger(length) || length < 0) {
        throw new TypeError("Expected function.length to be a positive integer");
      }
      const params = [];
      for (let i = 0; i < length; ++i) {
        params.push(`$${i + 1}`);
      }
      return params;
    }
    var { hasOwnProperty } = Object.prototype;
    var { apply } = Function.prototype;
    var GeneratorFunctionPrototype = Object.getPrototypeOf(function* () {
    });
    var identifier = (str) => `"${str.replace(/"/g, '""')}"`;
    var defer = (x) => () => x;
  }
});

// node_modules/better-sqlite3/lib/methods/inspect.js
var require_inspect = __commonJS({
  "node_modules/better-sqlite3/lib/methods/inspect.js"(exports2, module2) {
    "use strict";
    var DatabaseInspection = function Database() {
    };
    module2.exports = function inspect(depth, opts) {
      return Object.assign(new DatabaseInspection(), this);
    };
  }
});

// node_modules/better-sqlite3/lib/database.js
var require_database = __commonJS({
  "node_modules/better-sqlite3/lib/database.js"(exports2, module2) {
    "use strict";
    var fs = require_fs();
    var path = require_path();
    var util = require_util();
    var SqliteError = require_sqlite_error();
    var DEFAULT_ADDON;
    function Database(filenameGiven, options) {
      if (new.target == null) {
        return new Database(filenameGiven, options);
      }
      let buffer;
      if (Buffer.isBuffer(filenameGiven)) {
        buffer = filenameGiven;
        filenameGiven = ":memory:";
      }
      if (filenameGiven == null)
        filenameGiven = "";
      if (options == null)
        options = {};
      if (typeof filenameGiven !== "string")
        throw new TypeError("Expected first argument to be a string");
      if (typeof options !== "object")
        throw new TypeError("Expected second argument to be an options object");
      if ("readOnly" in options)
        throw new TypeError('Misspelled option "readOnly" should be "readonly"');
      if ("memory" in options)
        throw new TypeError('Option "memory" was removed in v7.0.0 (use ":memory:" filename instead)');
      const filename = filenameGiven.trim();
      const anonymous = filename === "" || filename === ":memory:";
      const readonly = util.getBooleanOption(options, "readonly");
      const fileMustExist = util.getBooleanOption(options, "fileMustExist");
      const timeout = "timeout" in options ? options.timeout : 5e3;
      const verbose = "verbose" in options ? options.verbose : null;
      const nativeBindingPath = "nativeBinding" in options ? options.nativeBinding : null;
      if (readonly && anonymous && !buffer)
        throw new TypeError("In-memory/temporary databases cannot be readonly");
      if (!Number.isInteger(timeout) || timeout < 0)
        throw new TypeError('Expected the "timeout" option to be a positive integer');
      if (timeout > 2147483647)
        throw new RangeError('Option "timeout" cannot be greater than 2147483647');
      if (verbose != null && typeof verbose !== "function")
        throw new TypeError('Expected the "verbose" option to be a function');
      if (nativeBindingPath != null && typeof nativeBindingPath !== "string")
        throw new TypeError('Expected the "nativeBinding" option to be a string');
      let addon;
      if (nativeBindingPath == null) {
        addon = DEFAULT_ADDON || (DEFAULT_ADDON = require_bindings()("better_sqlite3.node"));
      } else {
        addon = __require(path.resolve(nativeBindingPath).replace(/(\.node)?$/, ".node"));
      }
      if (!addon.isInitialized) {
        addon.setErrorConstructor(SqliteError);
        addon.isInitialized = true;
      }
      if (!anonymous && !fs.existsSync(path.dirname(filename))) {
        throw new TypeError("Cannot open database because the directory does not exist");
      }
      Object.defineProperties(this, {
        [util.cppdb]: { value: new addon.Database(filename, filenameGiven, anonymous, readonly, fileMustExist, timeout, verbose || null, buffer || null) },
        ...wrappers.getters
      });
    }
    var wrappers = require_wrappers();
    Database.prototype.prepare = wrappers.prepare;
    Database.prototype.transaction = require_transaction();
    Database.prototype.pragma = require_pragma();
    Database.prototype.backup = require_backup();
    Database.prototype.serialize = require_serialize();
    Database.prototype.function = require_function();
    Database.prototype.aggregate = require_aggregate();
    Database.prototype.table = require_table();
    Database.prototype.loadExtension = wrappers.loadExtension;
    Database.prototype.exec = wrappers.exec;
    Database.prototype.close = wrappers.close;
    Database.prototype.defaultSafeIntegers = wrappers.defaultSafeIntegers;
    Database.prototype.unsafeMode = wrappers.unsafeMode;
    Database.prototype[util.inspect] = require_inspect();
    module2.exports = Database;
  }
});

// node_modules/better-sqlite3/lib/index.js
var require_lib = __commonJS({
  "node_modules/better-sqlite3/lib/index.js"(exports2, module2) {
    "use strict";
    module2.exports = require_database();
    module2.exports.SqliteError = require_sqlite_error();
  }
});

// node_modules/quick.db/out/drivers/SqliteDriver.js
var require_SqliteDriver = __commonJS({
  "node_modules/quick.db/out/drivers/SqliteDriver.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SqliteDriver = void 0;
    var SqliteDriver = class {
      constructor(path) {
        __publicField(this, "database");
        const sqlite3 = require_lib();
        this.database = sqlite3(path);
      }
      async prepare(table) {
        this.database.prepare(`CREATE TABLE IF NOT EXISTS ${table} (ID TEXT, json TEXT)`).run();
      }
      async getAllRows(table) {
        const prep = this.database.prepare(`SELECT * FROM ${table}`);
        const data = [];
        for (const row of prep.iterate()) {
          data.push({
            id: row.ID,
            value: JSON.parse(row.json)
          });
        }
        return data;
      }
      async getRowByKey(table, key) {
        const value = await this.database.prepare(`SELECT json FROM ${table} WHERE ID = @key`).get({
          key
        });
        return value != null ? [JSON.parse(value.json), true] : [null, false];
      }
      async setRowByKey(table, key, value, update) {
        const stringifiedJson = JSON.stringify(value);
        if (update) {
          this.database.prepare(`UPDATE ${table} SET json = (?) WHERE ID = (?)`).run(stringifiedJson, key);
        } else {
          this.database.prepare(`INSERT INTO ${table} (ID,json) VALUES (?,?)`).run(key, stringifiedJson);
        }
        return value;
      }
      async deleteAllRows(table) {
        return this.database.prepare(`DELETE FROM ${table}`).run().changes;
      }
      async deleteRowByKey(table, key) {
        return this.database.prepare(`DELETE FROM ${table} WHERE ID=@key`).run({
          key
        }).changes;
      }
    };
    exports2.SqliteDriver = SqliteDriver;
  }
});

// node_modules/bluebird/js/browser/bluebird.js
var require_bluebird = __commonJS({
  "node_modules/bluebird/js/browser/bluebird.js"(exports, module) {
    !function(e) {
      if ("object" == typeof exports && "undefined" != typeof module)
        module.exports = e();
      else if ("function" == typeof define && define.amd)
        define([], e);
      else {
        var f;
        "undefined" != typeof window ? f = window : "undefined" != typeof global ? f = global : "undefined" != typeof self && (f = self), f.Promise = e();
      }
    }(function() {
      var define, module, exports;
      return function e(t, n, r) {
        function s(o2, u) {
          if (!n[o2]) {
            if (!t[o2]) {
              var a = typeof _dereq_ == "function" && _dereq_;
              if (!u && a)
                return a(o2, true);
              if (i)
                return i(o2, true);
              var f = new Error("Cannot find module '" + o2 + "'");
              throw f.code = "MODULE_NOT_FOUND", f;
            }
            var l = n[o2] = { exports: {} };
            t[o2][0].call(l.exports, function(e2) {
              var n2 = t[o2][1][e2];
              return s(n2 ? n2 : e2);
            }, l, l.exports, e, t, n, r);
          }
          return n[o2].exports;
        }
        var i = typeof _dereq_ == "function" && _dereq_;
        for (var o = 0; o < r.length; o++)
          s(r[o]);
        return s;
      }({ 1: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2) {
          var SomePromiseArray = Promise2._SomePromiseArray;
          function any(promises) {
            var ret2 = new SomePromiseArray(promises);
            var promise = ret2.promise();
            ret2.setHowMany(1);
            ret2.setUnwrap();
            ret2.init();
            return promise;
          }
          Promise2.any = function(promises) {
            return any(promises);
          };
          Promise2.prototype.any = function() {
            return any(this);
          };
        };
      }, {}], 2: [function(_dereq_2, module2, exports2) {
        "use strict";
        var firstLineError;
        try {
          throw new Error();
        } catch (e) {
          firstLineError = e;
        }
        var schedule = _dereq_2("./schedule");
        var Queue = _dereq_2("./queue");
        function Async() {
          this._customScheduler = false;
          this._isTickUsed = false;
          this._lateQueue = new Queue(16);
          this._normalQueue = new Queue(16);
          this._haveDrainedQueues = false;
          var self2 = this;
          this.drainQueues = function() {
            self2._drainQueues();
          };
          this._schedule = schedule;
        }
        Async.prototype.setScheduler = function(fn) {
          var prev = this._schedule;
          this._schedule = fn;
          this._customScheduler = true;
          return prev;
        };
        Async.prototype.hasCustomScheduler = function() {
          return this._customScheduler;
        };
        Async.prototype.haveItemsQueued = function() {
          return this._isTickUsed || this._haveDrainedQueues;
        };
        Async.prototype.fatalError = function(e, isNode2) {
          if (isNode2) {
            process.stderr.write("Fatal " + (e instanceof Error ? e.stack : e) + "\n");
            process.exit(2);
          } else {
            this.throwLater(e);
          }
        };
        Async.prototype.throwLater = function(fn, arg) {
          if (arguments.length === 1) {
            arg = fn;
            fn = function() {
              throw arg;
            };
          }
          if (typeof setTimeout !== "undefined") {
            setTimeout(function() {
              fn(arg);
            }, 0);
          } else
            try {
              this._schedule(function() {
                fn(arg);
              });
            } catch (e) {
              throw new Error("No async scheduler available\n\n    See http://goo.gl/MqrFmX\n");
            }
        };
        function AsyncInvokeLater(fn, receiver2, arg) {
          this._lateQueue.push(fn, receiver2, arg);
          this._queueTick();
        }
        function AsyncInvoke(fn, receiver2, arg) {
          this._normalQueue.push(fn, receiver2, arg);
          this._queueTick();
        }
        function AsyncSettlePromises(promise) {
          this._normalQueue._pushOne(promise);
          this._queueTick();
        }
        Async.prototype.invokeLater = AsyncInvokeLater;
        Async.prototype.invoke = AsyncInvoke;
        Async.prototype.settlePromises = AsyncSettlePromises;
        function _drainQueue(queue) {
          while (queue.length() > 0) {
            _drainQueueStep(queue);
          }
        }
        function _drainQueueStep(queue) {
          var fn = queue.shift();
          if (typeof fn !== "function") {
            fn._settlePromises();
          } else {
            var receiver2 = queue.shift();
            var arg = queue.shift();
            fn.call(receiver2, arg);
          }
        }
        Async.prototype._drainQueues = function() {
          _drainQueue(this._normalQueue);
          this._reset();
          this._haveDrainedQueues = true;
          _drainQueue(this._lateQueue);
        };
        Async.prototype._queueTick = function() {
          if (!this._isTickUsed) {
            this._isTickUsed = true;
            this._schedule(this.drainQueues);
          }
        };
        Async.prototype._reset = function() {
          this._isTickUsed = false;
        };
        module2.exports = Async;
        module2.exports.firstLineError = firstLineError;
      }, { "./queue": 26, "./schedule": 29 }], 3: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, INTERNAL, tryConvertToPromise, debug) {
          var calledBind = false;
          var rejectThis = function(_, e) {
            this._reject(e);
          };
          var targetRejected = function(e, context) {
            context.promiseRejectionQueued = true;
            context.bindingPromise._then(rejectThis, rejectThis, null, this, e);
          };
          var bindingResolved = function(thisArg, context) {
            if ((this._bitField & 50397184) === 0) {
              this._resolveCallback(context.target);
            }
          };
          var bindingRejected = function(e, context) {
            if (!context.promiseRejectionQueued)
              this._reject(e);
          };
          Promise2.prototype.bind = function(thisArg) {
            if (!calledBind) {
              calledBind = true;
              Promise2.prototype._propagateFrom = debug.propagateFromFunction();
              Promise2.prototype._boundValue = debug.boundValueFunction();
            }
            var maybePromise = tryConvertToPromise(thisArg);
            var ret2 = new Promise2(INTERNAL);
            ret2._propagateFrom(this, 1);
            var target = this._target();
            ret2._setBoundTo(maybePromise);
            if (maybePromise instanceof Promise2) {
              var context = {
                promiseRejectionQueued: false,
                promise: ret2,
                target,
                bindingPromise: maybePromise
              };
              target._then(INTERNAL, targetRejected, void 0, ret2, context);
              maybePromise._then(
                bindingResolved,
                bindingRejected,
                void 0,
                ret2,
                context
              );
              ret2._setOnCancel(maybePromise);
            } else {
              ret2._resolveCallback(target);
            }
            return ret2;
          };
          Promise2.prototype._setBoundTo = function(obj2) {
            if (obj2 !== void 0) {
              this._bitField = this._bitField | 2097152;
              this._boundTo = obj2;
            } else {
              this._bitField = this._bitField & ~2097152;
            }
          };
          Promise2.prototype._isBound = function() {
            return (this._bitField & 2097152) === 2097152;
          };
          Promise2.bind = function(thisArg, value) {
            return Promise2.resolve(value).bind(thisArg);
          };
        };
      }, {}], 4: [function(_dereq_2, module2, exports2) {
        "use strict";
        var old;
        if (typeof Promise !== "undefined")
          old = Promise;
        function noConflict() {
          try {
            if (Promise === bluebird)
              Promise = old;
          } catch (e) {
          }
          return bluebird;
        }
        var bluebird = _dereq_2("./promise")();
        bluebird.noConflict = noConflict;
        module2.exports = bluebird;
      }, { "./promise": 22 }], 5: [function(_dereq_2, module2, exports2) {
        "use strict";
        var cr = Object.create;
        if (cr) {
          var callerCache = cr(null);
          var getterCache = cr(null);
          callerCache[" size"] = getterCache[" size"] = 0;
        }
        module2.exports = function(Promise2) {
          var util = _dereq_2("./util");
          var canEvaluate2 = util.canEvaluate;
          var isIdentifier2 = util.isIdentifier;
          var getMethodCaller;
          var getGetter;
          if (false) {
            var makeMethodCaller = function(methodName) {
              return new Function("ensureMethod", "                                    \n        return function(obj) {                                               \n            'use strict'                                                     \n            var len = this.length;                                           \n            ensureMethod(obj, 'methodName');                                 \n            switch(len) {                                                    \n                case 1: return obj.methodName(this[0]);                      \n                case 2: return obj.methodName(this[0], this[1]);             \n                case 3: return obj.methodName(this[0], this[1], this[2]);    \n                case 0: return obj.methodName();                             \n                default:                                                     \n                    return obj.methodName.apply(obj, this);                  \n            }                                                                \n        };                                                                   \n        ".replace(/methodName/g, methodName))(ensureMethod);
            };
            var makeGetter = function(propertyName) {
              return new Function("obj", "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ".replace("propertyName", propertyName));
            };
            var getCompiled = function(name, compiler, cache) {
              var ret2 = cache[name];
              if (typeof ret2 !== "function") {
                if (!isIdentifier2(name)) {
                  return null;
                }
                ret2 = compiler(name);
                cache[name] = ret2;
                cache[" size"]++;
                if (cache[" size"] > 512) {
                  var keys = Object.keys(cache);
                  for (var i = 0; i < 256; ++i)
                    delete cache[keys[i]];
                  cache[" size"] = keys.length - 256;
                }
              }
              return ret2;
            };
            getMethodCaller = function(name) {
              return getCompiled(name, makeMethodCaller, callerCache);
            };
            getGetter = function(name) {
              return getCompiled(name, makeGetter, getterCache);
            };
          }
          function ensureMethod(obj2, methodName) {
            var fn;
            if (obj2 != null)
              fn = obj2[methodName];
            if (typeof fn !== "function") {
              var message = "Object " + util.classString(obj2) + " has no method '" + util.toString(methodName) + "'";
              throw new Promise2.TypeError(message);
            }
            return fn;
          }
          function caller(obj2) {
            var methodName = this.pop();
            var fn = ensureMethod(obj2, methodName);
            return fn.apply(obj2, this);
          }
          Promise2.prototype.call = function(methodName) {
            var args = [].slice.call(arguments, 1);
            ;
            if (false) {
              if (canEvaluate2) {
                var maybeCaller = getMethodCaller(methodName);
                if (maybeCaller !== null) {
                  return this._then(
                    maybeCaller,
                    void 0,
                    void 0,
                    args,
                    void 0
                  );
                }
              }
            }
            args.push(methodName);
            return this._then(caller, void 0, void 0, args, void 0);
          };
          function namedGetter(obj2) {
            return obj2[this];
          }
          function indexedGetter(obj2) {
            var index = +this;
            if (index < 0)
              index = Math.max(0, index + obj2.length);
            return obj2[index];
          }
          Promise2.prototype.get = function(propertyName) {
            var isIndex = typeof propertyName === "number";
            var getter;
            if (!isIndex) {
              if (canEvaluate2) {
                var maybeGetter = getGetter(propertyName);
                getter = maybeGetter !== null ? maybeGetter : namedGetter;
              } else {
                getter = namedGetter;
              }
            } else {
              getter = indexedGetter;
            }
            return this._then(getter, void 0, void 0, propertyName, void 0);
          };
        };
      }, { "./util": 36 }], 6: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, PromiseArray, apiRejection, debug) {
          var util = _dereq_2("./util");
          var tryCatch2 = util.tryCatch;
          var errorObj2 = util.errorObj;
          var async = Promise2._async;
          Promise2.prototype["break"] = Promise2.prototype.cancel = function() {
            if (!debug.cancellation())
              return this._warn("cancellation is disabled");
            var promise = this;
            var child = promise;
            while (promise._isCancellable()) {
              if (!promise._cancelBy(child)) {
                if (child._isFollowing()) {
                  child._followee().cancel();
                } else {
                  child._cancelBranched();
                }
                break;
              }
              var parent = promise._cancellationParent;
              if (parent == null || !parent._isCancellable()) {
                if (promise._isFollowing()) {
                  promise._followee().cancel();
                } else {
                  promise._cancelBranched();
                }
                break;
              } else {
                if (promise._isFollowing())
                  promise._followee().cancel();
                promise._setWillBeCancelled();
                child = promise;
                promise = parent;
              }
            }
          };
          Promise2.prototype._branchHasCancelled = function() {
            this._branchesRemainingToCancel--;
          };
          Promise2.prototype._enoughBranchesHaveCancelled = function() {
            return this._branchesRemainingToCancel === void 0 || this._branchesRemainingToCancel <= 0;
          };
          Promise2.prototype._cancelBy = function(canceller) {
            if (canceller === this) {
              this._branchesRemainingToCancel = 0;
              this._invokeOnCancel();
              return true;
            } else {
              this._branchHasCancelled();
              if (this._enoughBranchesHaveCancelled()) {
                this._invokeOnCancel();
                return true;
              }
            }
            return false;
          };
          Promise2.prototype._cancelBranched = function() {
            if (this._enoughBranchesHaveCancelled()) {
              this._cancel();
            }
          };
          Promise2.prototype._cancel = function() {
            if (!this._isCancellable())
              return;
            this._setCancelled();
            async.invoke(this._cancelPromises, this, void 0);
          };
          Promise2.prototype._cancelPromises = function() {
            if (this._length() > 0)
              this._settlePromises();
          };
          Promise2.prototype._unsetOnCancel = function() {
            this._onCancelField = void 0;
          };
          Promise2.prototype._isCancellable = function() {
            return this.isPending() && !this._isCancelled();
          };
          Promise2.prototype.isCancellable = function() {
            return this.isPending() && !this.isCancelled();
          };
          Promise2.prototype._doInvokeOnCancel = function(onCancelCallback, internalOnly) {
            if (util.isArray(onCancelCallback)) {
              for (var i = 0; i < onCancelCallback.length; ++i) {
                this._doInvokeOnCancel(onCancelCallback[i], internalOnly);
              }
            } else if (onCancelCallback !== void 0) {
              if (typeof onCancelCallback === "function") {
                if (!internalOnly) {
                  var e = tryCatch2(onCancelCallback).call(this._boundValue());
                  if (e === errorObj2) {
                    this._attachExtraTrace(e.e);
                    async.throwLater(e.e);
                  }
                }
              } else {
                onCancelCallback._resultCancelled(this);
              }
            }
          };
          Promise2.prototype._invokeOnCancel = function() {
            var onCancelCallback = this._onCancel();
            this._unsetOnCancel();
            async.invoke(this._doInvokeOnCancel, this, onCancelCallback);
          };
          Promise2.prototype._invokeInternalOnCancel = function() {
            if (this._isCancellable()) {
              this._doInvokeOnCancel(this._onCancel(), true);
              this._unsetOnCancel();
            }
          };
          Promise2.prototype._resultCancelled = function() {
            this.cancel();
          };
        };
      }, { "./util": 36 }], 7: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(NEXT_FILTER) {
          var util = _dereq_2("./util");
          var getKeys = _dereq_2("./es5").keys;
          var tryCatch2 = util.tryCatch;
          var errorObj2 = util.errorObj;
          function catchFilter(instances, cb, promise) {
            return function(e) {
              var boundTo = promise._boundValue();
              predicateLoop:
                for (var i = 0; i < instances.length; ++i) {
                  var item = instances[i];
                  if (item === Error || item != null && item.prototype instanceof Error) {
                    if (e instanceof item) {
                      return tryCatch2(cb).call(boundTo, e);
                    }
                  } else if (typeof item === "function") {
                    var matchesPredicate = tryCatch2(item).call(boundTo, e);
                    if (matchesPredicate === errorObj2) {
                      return matchesPredicate;
                    } else if (matchesPredicate) {
                      return tryCatch2(cb).call(boundTo, e);
                    }
                  } else if (util.isObject(e)) {
                    var keys = getKeys(item);
                    for (var j = 0; j < keys.length; ++j) {
                      var key = keys[j];
                      if (item[key] != e[key]) {
                        continue predicateLoop;
                      }
                    }
                    return tryCatch2(cb).call(boundTo, e);
                  }
                }
              return NEXT_FILTER;
            };
          }
          return catchFilter;
        };
      }, { "./es5": 13, "./util": 36 }], 8: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2) {
          var longStackTraces = false;
          var contextStack = [];
          Promise2.prototype._promiseCreated = function() {
          };
          Promise2.prototype._pushContext = function() {
          };
          Promise2.prototype._popContext = function() {
            return null;
          };
          Promise2._peekContext = Promise2.prototype._peekContext = function() {
          };
          function Context() {
            this._trace = new Context.CapturedTrace(peekContext());
          }
          Context.prototype._pushContext = function() {
            if (this._trace !== void 0) {
              this._trace._promiseCreated = null;
              contextStack.push(this._trace);
            }
          };
          Context.prototype._popContext = function() {
            if (this._trace !== void 0) {
              var trace = contextStack.pop();
              var ret2 = trace._promiseCreated;
              trace._promiseCreated = null;
              return ret2;
            }
            return null;
          };
          function createContext() {
            if (longStackTraces)
              return new Context();
          }
          function peekContext() {
            var lastIndex = contextStack.length - 1;
            if (lastIndex >= 0) {
              return contextStack[lastIndex];
            }
            return void 0;
          }
          Context.CapturedTrace = null;
          Context.create = createContext;
          Context.deactivateLongStackTraces = function() {
          };
          Context.activateLongStackTraces = function() {
            var Promise_pushContext = Promise2.prototype._pushContext;
            var Promise_popContext = Promise2.prototype._popContext;
            var Promise_PeekContext = Promise2._peekContext;
            var Promise_peekContext = Promise2.prototype._peekContext;
            var Promise_promiseCreated = Promise2.prototype._promiseCreated;
            Context.deactivateLongStackTraces = function() {
              Promise2.prototype._pushContext = Promise_pushContext;
              Promise2.prototype._popContext = Promise_popContext;
              Promise2._peekContext = Promise_PeekContext;
              Promise2.prototype._peekContext = Promise_peekContext;
              Promise2.prototype._promiseCreated = Promise_promiseCreated;
              longStackTraces = false;
            };
            longStackTraces = true;
            Promise2.prototype._pushContext = Context.prototype._pushContext;
            Promise2.prototype._popContext = Context.prototype._popContext;
            Promise2._peekContext = Promise2.prototype._peekContext = peekContext;
            Promise2.prototype._promiseCreated = function() {
              var ctx = this._peekContext();
              if (ctx && ctx._promiseCreated == null)
                ctx._promiseCreated = this;
            };
          };
          return Context;
        };
      }, {}], 9: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, Context, enableAsyncHooks, disableAsyncHooks) {
          var async = Promise2._async;
          var Warning = _dereq_2("./errors").Warning;
          var util = _dereq_2("./util");
          var es52 = _dereq_2("./es5");
          var canAttachTrace2 = util.canAttachTrace;
          var unhandledRejectionHandled;
          var possiblyUnhandledRejection;
          var bluebirdFramePattern = /[\\\/]bluebird[\\\/]js[\\\/](release|debug|instrumented)/;
          var nodeFramePattern = /\((?:timers\.js):\d+:\d+\)/;
          var parseLinePattern = /[\/<\(](.+?):(\d+):(\d+)\)?\s*$/;
          var stackFramePattern = null;
          var formatStack = null;
          var indentStackFrames = false;
          var printWarning;
          var debugging = !!(util.env("BLUEBIRD_DEBUG") != 0 && true);
          var warnings = !!(util.env("BLUEBIRD_WARNINGS") != 0 && (debugging || util.env("BLUEBIRD_WARNINGS")));
          var longStackTraces = !!(util.env("BLUEBIRD_LONG_STACK_TRACES") != 0 && (debugging || util.env("BLUEBIRD_LONG_STACK_TRACES")));
          var wForgottenReturn = util.env("BLUEBIRD_W_FORGOTTEN_RETURN") != 0 && (warnings || !!util.env("BLUEBIRD_W_FORGOTTEN_RETURN"));
          var deferUnhandledRejectionCheck;
          (function() {
            var promises = [];
            function unhandledRejectionCheck() {
              for (var i = 0; i < promises.length; ++i) {
                promises[i]._notifyUnhandledRejection();
              }
              unhandledRejectionClear();
            }
            function unhandledRejectionClear() {
              promises.length = 0;
            }
            deferUnhandledRejectionCheck = function(promise) {
              promises.push(promise);
              setTimeout(unhandledRejectionCheck, 1);
            };
            es52.defineProperty(Promise2, "_unhandledRejectionCheck", {
              value: unhandledRejectionCheck
            });
            es52.defineProperty(Promise2, "_unhandledRejectionClear", {
              value: unhandledRejectionClear
            });
          })();
          Promise2.prototype.suppressUnhandledRejections = function() {
            var target = this._target();
            target._bitField = target._bitField & ~1048576 | 524288;
          };
          Promise2.prototype._ensurePossibleRejectionHandled = function() {
            if ((this._bitField & 524288) !== 0)
              return;
            this._setRejectionIsUnhandled();
            deferUnhandledRejectionCheck(this);
          };
          Promise2.prototype._notifyUnhandledRejectionIsHandled = function() {
            fireRejectionEvent(
              "rejectionHandled",
              unhandledRejectionHandled,
              void 0,
              this
            );
          };
          Promise2.prototype._setReturnedNonUndefined = function() {
            this._bitField = this._bitField | 268435456;
          };
          Promise2.prototype._returnedNonUndefined = function() {
            return (this._bitField & 268435456) !== 0;
          };
          Promise2.prototype._notifyUnhandledRejection = function() {
            if (this._isRejectionUnhandled()) {
              var reason = this._settledValue();
              this._setUnhandledRejectionIsNotified();
              fireRejectionEvent(
                "unhandledRejection",
                possiblyUnhandledRejection,
                reason,
                this
              );
            }
          };
          Promise2.prototype._setUnhandledRejectionIsNotified = function() {
            this._bitField = this._bitField | 262144;
          };
          Promise2.prototype._unsetUnhandledRejectionIsNotified = function() {
            this._bitField = this._bitField & ~262144;
          };
          Promise2.prototype._isUnhandledRejectionNotified = function() {
            return (this._bitField & 262144) > 0;
          };
          Promise2.prototype._setRejectionIsUnhandled = function() {
            this._bitField = this._bitField | 1048576;
          };
          Promise2.prototype._unsetRejectionIsUnhandled = function() {
            this._bitField = this._bitField & ~1048576;
            if (this._isUnhandledRejectionNotified()) {
              this._unsetUnhandledRejectionIsNotified();
              this._notifyUnhandledRejectionIsHandled();
            }
          };
          Promise2.prototype._isRejectionUnhandled = function() {
            return (this._bitField & 1048576) > 0;
          };
          Promise2.prototype._warn = function(message, shouldUseOwnTrace, promise) {
            return warn(message, shouldUseOwnTrace, promise || this);
          };
          Promise2.onPossiblyUnhandledRejection = function(fn) {
            var context = Promise2._getContext();
            possiblyUnhandledRejection = util.contextBind(context, fn);
          };
          Promise2.onUnhandledRejectionHandled = function(fn) {
            var context = Promise2._getContext();
            unhandledRejectionHandled = util.contextBind(context, fn);
          };
          var disableLongStackTraces = function() {
          };
          Promise2.longStackTraces = function() {
            if (async.haveItemsQueued() && !config.longStackTraces) {
              throw new Error("cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n");
            }
            if (!config.longStackTraces && longStackTracesIsSupported()) {
              var Promise_captureStackTrace = Promise2.prototype._captureStackTrace;
              var Promise_attachExtraTrace = Promise2.prototype._attachExtraTrace;
              var Promise_dereferenceTrace = Promise2.prototype._dereferenceTrace;
              config.longStackTraces = true;
              disableLongStackTraces = function() {
                if (async.haveItemsQueued() && !config.longStackTraces) {
                  throw new Error("cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n");
                }
                Promise2.prototype._captureStackTrace = Promise_captureStackTrace;
                Promise2.prototype._attachExtraTrace = Promise_attachExtraTrace;
                Promise2.prototype._dereferenceTrace = Promise_dereferenceTrace;
                Context.deactivateLongStackTraces();
                config.longStackTraces = false;
              };
              Promise2.prototype._captureStackTrace = longStackTracesCaptureStackTrace;
              Promise2.prototype._attachExtraTrace = longStackTracesAttachExtraTrace;
              Promise2.prototype._dereferenceTrace = longStackTracesDereferenceTrace;
              Context.activateLongStackTraces();
            }
          };
          Promise2.hasLongStackTraces = function() {
            return config.longStackTraces && longStackTracesIsSupported();
          };
          var legacyHandlers = {
            unhandledrejection: {
              before: function() {
                var ret2 = util.global.onunhandledrejection;
                util.global.onunhandledrejection = null;
                return ret2;
              },
              after: function(fn) {
                util.global.onunhandledrejection = fn;
              }
            },
            rejectionhandled: {
              before: function() {
                var ret2 = util.global.onrejectionhandled;
                util.global.onrejectionhandled = null;
                return ret2;
              },
              after: function(fn) {
                util.global.onrejectionhandled = fn;
              }
            }
          };
          var fireDomEvent = function() {
            var dispatch = function(legacy, e) {
              if (legacy) {
                var fn;
                try {
                  fn = legacy.before();
                  return !util.global.dispatchEvent(e);
                } finally {
                  legacy.after(fn);
                }
              } else {
                return !util.global.dispatchEvent(e);
              }
            };
            try {
              if (typeof CustomEvent === "function") {
                var event = new CustomEvent("CustomEvent");
                util.global.dispatchEvent(event);
                return function(name, event2) {
                  name = name.toLowerCase();
                  var eventData = {
                    detail: event2,
                    cancelable: true
                  };
                  var domEvent = new CustomEvent(name, eventData);
                  es52.defineProperty(
                    domEvent,
                    "promise",
                    { value: event2.promise }
                  );
                  es52.defineProperty(
                    domEvent,
                    "reason",
                    { value: event2.reason }
                  );
                  return dispatch(legacyHandlers[name], domEvent);
                };
              } else if (typeof Event === "function") {
                var event = new Event("CustomEvent");
                util.global.dispatchEvent(event);
                return function(name, event2) {
                  name = name.toLowerCase();
                  var domEvent = new Event(name, {
                    cancelable: true
                  });
                  domEvent.detail = event2;
                  es52.defineProperty(domEvent, "promise", { value: event2.promise });
                  es52.defineProperty(domEvent, "reason", { value: event2.reason });
                  return dispatch(legacyHandlers[name], domEvent);
                };
              } else {
                var event = document.createEvent("CustomEvent");
                event.initCustomEvent("testingtheevent", false, true, {});
                util.global.dispatchEvent(event);
                return function(name, event2) {
                  name = name.toLowerCase();
                  var domEvent = document.createEvent("CustomEvent");
                  domEvent.initCustomEvent(
                    name,
                    false,
                    true,
                    event2
                  );
                  return dispatch(legacyHandlers[name], domEvent);
                };
              }
            } catch (e) {
            }
            return function() {
              return false;
            };
          }();
          var fireGlobalEvent = function() {
            if (util.isNode) {
              return function() {
                return process.emit.apply(process, arguments);
              };
            } else {
              if (!util.global) {
                return function() {
                  return false;
                };
              }
              return function(name) {
                var methodName = "on" + name.toLowerCase();
                var method = util.global[methodName];
                if (!method)
                  return false;
                method.apply(util.global, [].slice.call(arguments, 1));
                return true;
              };
            }
          }();
          function generatePromiseLifecycleEventObject(name, promise) {
            return { promise };
          }
          var eventToObjectGenerator = {
            promiseCreated: generatePromiseLifecycleEventObject,
            promiseFulfilled: generatePromiseLifecycleEventObject,
            promiseRejected: generatePromiseLifecycleEventObject,
            promiseResolved: generatePromiseLifecycleEventObject,
            promiseCancelled: generatePromiseLifecycleEventObject,
            promiseChained: function(name, promise, child) {
              return { promise, child };
            },
            warning: function(name, warning) {
              return { warning };
            },
            unhandledRejection: function(name, reason, promise) {
              return { reason, promise };
            },
            rejectionHandled: generatePromiseLifecycleEventObject
          };
          var activeFireEvent = function(name) {
            var globalEventFired = false;
            try {
              globalEventFired = fireGlobalEvent.apply(null, arguments);
            } catch (e) {
              async.throwLater(e);
              globalEventFired = true;
            }
            var domEventFired = false;
            try {
              domEventFired = fireDomEvent(
                name,
                eventToObjectGenerator[name].apply(null, arguments)
              );
            } catch (e) {
              async.throwLater(e);
              domEventFired = true;
            }
            return domEventFired || globalEventFired;
          };
          Promise2.config = function(opts) {
            opts = Object(opts);
            if ("longStackTraces" in opts) {
              if (opts.longStackTraces) {
                Promise2.longStackTraces();
              } else if (!opts.longStackTraces && Promise2.hasLongStackTraces()) {
                disableLongStackTraces();
              }
            }
            if ("warnings" in opts) {
              var warningsOption = opts.warnings;
              config.warnings = !!warningsOption;
              wForgottenReturn = config.warnings;
              if (util.isObject(warningsOption)) {
                if ("wForgottenReturn" in warningsOption) {
                  wForgottenReturn = !!warningsOption.wForgottenReturn;
                }
              }
            }
            if ("cancellation" in opts && opts.cancellation && !config.cancellation) {
              if (async.haveItemsQueued()) {
                throw new Error(
                  "cannot enable cancellation after promises are in use"
                );
              }
              Promise2.prototype._clearCancellationData = cancellationClearCancellationData;
              Promise2.prototype._propagateFrom = cancellationPropagateFrom;
              Promise2.prototype._onCancel = cancellationOnCancel;
              Promise2.prototype._setOnCancel = cancellationSetOnCancel;
              Promise2.prototype._attachCancellationCallback = cancellationAttachCancellationCallback;
              Promise2.prototype._execute = cancellationExecute;
              propagateFromFunction = cancellationPropagateFrom;
              config.cancellation = true;
            }
            if ("monitoring" in opts) {
              if (opts.monitoring && !config.monitoring) {
                config.monitoring = true;
                Promise2.prototype._fireEvent = activeFireEvent;
              } else if (!opts.monitoring && config.monitoring) {
                config.monitoring = false;
                Promise2.prototype._fireEvent = defaultFireEvent;
              }
            }
            if ("asyncHooks" in opts && util.nodeSupportsAsyncResource) {
              var prev = config.asyncHooks;
              var cur = !!opts.asyncHooks;
              if (prev !== cur) {
                config.asyncHooks = cur;
                if (cur) {
                  enableAsyncHooks();
                } else {
                  disableAsyncHooks();
                }
              }
            }
            return Promise2;
          };
          function defaultFireEvent() {
            return false;
          }
          Promise2.prototype._fireEvent = defaultFireEvent;
          Promise2.prototype._execute = function(executor, resolve, reject) {
            try {
              executor(resolve, reject);
            } catch (e) {
              return e;
            }
          };
          Promise2.prototype._onCancel = function() {
          };
          Promise2.prototype._setOnCancel = function(handler) {
            ;
          };
          Promise2.prototype._attachCancellationCallback = function(onCancel) {
            ;
          };
          Promise2.prototype._captureStackTrace = function() {
          };
          Promise2.prototype._attachExtraTrace = function() {
          };
          Promise2.prototype._dereferenceTrace = function() {
          };
          Promise2.prototype._clearCancellationData = function() {
          };
          Promise2.prototype._propagateFrom = function(parent, flags) {
            ;
            ;
          };
          function cancellationExecute(executor, resolve, reject) {
            var promise = this;
            try {
              executor(resolve, reject, function(onCancel) {
                if (typeof onCancel !== "function") {
                  throw new TypeError("onCancel must be a function, got: " + util.toString(onCancel));
                }
                promise._attachCancellationCallback(onCancel);
              });
            } catch (e) {
              return e;
            }
          }
          function cancellationAttachCancellationCallback(onCancel) {
            if (!this._isCancellable())
              return this;
            var previousOnCancel = this._onCancel();
            if (previousOnCancel !== void 0) {
              if (util.isArray(previousOnCancel)) {
                previousOnCancel.push(onCancel);
              } else {
                this._setOnCancel([previousOnCancel, onCancel]);
              }
            } else {
              this._setOnCancel(onCancel);
            }
          }
          function cancellationOnCancel() {
            return this._onCancelField;
          }
          function cancellationSetOnCancel(onCancel) {
            this._onCancelField = onCancel;
          }
          function cancellationClearCancellationData() {
            this._cancellationParent = void 0;
            this._onCancelField = void 0;
          }
          function cancellationPropagateFrom(parent, flags) {
            if ((flags & 1) !== 0) {
              this._cancellationParent = parent;
              var branchesRemainingToCancel = parent._branchesRemainingToCancel;
              if (branchesRemainingToCancel === void 0) {
                branchesRemainingToCancel = 0;
              }
              parent._branchesRemainingToCancel = branchesRemainingToCancel + 1;
            }
            if ((flags & 2) !== 0 && parent._isBound()) {
              this._setBoundTo(parent._boundTo);
            }
          }
          function bindingPropagateFrom(parent, flags) {
            if ((flags & 2) !== 0 && parent._isBound()) {
              this._setBoundTo(parent._boundTo);
            }
          }
          var propagateFromFunction = bindingPropagateFrom;
          function boundValueFunction() {
            var ret2 = this._boundTo;
            if (ret2 !== void 0) {
              if (ret2 instanceof Promise2) {
                if (ret2.isFulfilled()) {
                  return ret2.value();
                } else {
                  return void 0;
                }
              }
            }
            return ret2;
          }
          function longStackTracesCaptureStackTrace() {
            this._trace = new CapturedTrace(this._peekContext());
          }
          function longStackTracesAttachExtraTrace(error, ignoreSelf) {
            if (canAttachTrace2(error)) {
              var trace = this._trace;
              if (trace !== void 0) {
                if (ignoreSelf)
                  trace = trace._parent;
              }
              if (trace !== void 0) {
                trace.attachExtraTrace(error);
              } else if (!error.__stackCleaned__) {
                var parsed = parseStackAndMessage(error);
                util.notEnumerableProp(
                  error,
                  "stack",
                  parsed.message + "\n" + parsed.stack.join("\n")
                );
                util.notEnumerableProp(error, "__stackCleaned__", true);
              }
            }
          }
          function longStackTracesDereferenceTrace() {
            this._trace = void 0;
          }
          function checkForgottenReturns(returnValue, promiseCreated, name, promise, parent) {
            if (returnValue === void 0 && promiseCreated !== null && wForgottenReturn) {
              if (parent !== void 0 && parent._returnedNonUndefined())
                return;
              if ((promise._bitField & 65535) === 0)
                return;
              if (name)
                name = name + " ";
              var handlerLine = "";
              var creatorLine = "";
              if (promiseCreated._trace) {
                var traceLines = promiseCreated._trace.stack.split("\n");
                var stack = cleanStack(traceLines);
                for (var i = stack.length - 1; i >= 0; --i) {
                  var line = stack[i];
                  if (!nodeFramePattern.test(line)) {
                    var lineMatches = line.match(parseLinePattern);
                    if (lineMatches) {
                      handlerLine = "at " + lineMatches[1] + ":" + lineMatches[2] + ":" + lineMatches[3] + " ";
                    }
                    break;
                  }
                }
                if (stack.length > 0) {
                  var firstUserLine = stack[0];
                  for (var i = 0; i < traceLines.length; ++i) {
                    if (traceLines[i] === firstUserLine) {
                      if (i > 0) {
                        creatorLine = "\n" + traceLines[i - 1];
                      }
                      break;
                    }
                  }
                }
              }
              var msg = "a promise was created in a " + name + "handler " + handlerLine + "but was not returned from it, see http://goo.gl/rRqMUw" + creatorLine;
              promise._warn(msg, true, promiseCreated);
            }
          }
          function deprecated(name, replacement) {
            var message = name + " is deprecated and will be removed in a future version.";
            if (replacement)
              message += " Use " + replacement + " instead.";
            return warn(message);
          }
          function warn(message, shouldUseOwnTrace, promise) {
            if (!config.warnings)
              return;
            var warning = new Warning(message);
            var ctx;
            if (shouldUseOwnTrace) {
              promise._attachExtraTrace(warning);
            } else if (config.longStackTraces && (ctx = Promise2._peekContext())) {
              ctx.attachExtraTrace(warning);
            } else {
              var parsed = parseStackAndMessage(warning);
              warning.stack = parsed.message + "\n" + parsed.stack.join("\n");
            }
            if (!activeFireEvent("warning", warning)) {
              formatAndLogError(warning, "", true);
            }
          }
          function reconstructStack(message, stacks) {
            for (var i = 0; i < stacks.length - 1; ++i) {
              stacks[i].push("From previous event:");
              stacks[i] = stacks[i].join("\n");
            }
            if (i < stacks.length) {
              stacks[i] = stacks[i].join("\n");
            }
            return message + "\n" + stacks.join("\n");
          }
          function removeDuplicateOrEmptyJumps(stacks) {
            for (var i = 0; i < stacks.length; ++i) {
              if (stacks[i].length === 0 || i + 1 < stacks.length && stacks[i][0] === stacks[i + 1][0]) {
                stacks.splice(i, 1);
                i--;
              }
            }
          }
          function removeCommonRoots(stacks) {
            var current = stacks[0];
            for (var i = 1; i < stacks.length; ++i) {
              var prev = stacks[i];
              var currentLastIndex = current.length - 1;
              var currentLastLine = current[currentLastIndex];
              var commonRootMeetPoint = -1;
              for (var j = prev.length - 1; j >= 0; --j) {
                if (prev[j] === currentLastLine) {
                  commonRootMeetPoint = j;
                  break;
                }
              }
              for (var j = commonRootMeetPoint; j >= 0; --j) {
                var line = prev[j];
                if (current[currentLastIndex] === line) {
                  current.pop();
                  currentLastIndex--;
                } else {
                  break;
                }
              }
              current = prev;
            }
          }
          function cleanStack(stack) {
            var ret2 = [];
            for (var i = 0; i < stack.length; ++i) {
              var line = stack[i];
              var isTraceLine = "    (No stack trace)" === line || stackFramePattern.test(line);
              var isInternalFrame = isTraceLine && shouldIgnore(line);
              if (isTraceLine && !isInternalFrame) {
                if (indentStackFrames && line.charAt(0) !== " ") {
                  line = "    " + line;
                }
                ret2.push(line);
              }
            }
            return ret2;
          }
          function stackFramesAsArray(error) {
            var stack = error.stack.replace(/\s+$/g, "").split("\n");
            for (var i = 0; i < stack.length; ++i) {
              var line = stack[i];
              if ("    (No stack trace)" === line || stackFramePattern.test(line)) {
                break;
              }
            }
            if (i > 0 && error.name != "SyntaxError") {
              stack = stack.slice(i);
            }
            return stack;
          }
          function parseStackAndMessage(error) {
            var stack = error.stack;
            var message = error.toString();
            stack = typeof stack === "string" && stack.length > 0 ? stackFramesAsArray(error) : ["    (No stack trace)"];
            return {
              message,
              stack: error.name == "SyntaxError" ? stack : cleanStack(stack)
            };
          }
          function formatAndLogError(error, title, isSoft) {
            if (typeof console !== "undefined") {
              var message;
              if (util.isObject(error)) {
                var stack = error.stack;
                message = title + formatStack(stack, error);
              } else {
                message = title + String(error);
              }
              if (typeof printWarning === "function") {
                printWarning(message, isSoft);
              } else if (typeof console.log === "function" || typeof console.log === "object") {
                console.log(message);
              }
            }
          }
          function fireRejectionEvent(name, localHandler, reason, promise) {
            var localEventFired = false;
            try {
              if (typeof localHandler === "function") {
                localEventFired = true;
                if (name === "rejectionHandled") {
                  localHandler(promise);
                } else {
                  localHandler(reason, promise);
                }
              }
            } catch (e) {
              async.throwLater(e);
            }
            if (name === "unhandledRejection") {
              if (!activeFireEvent(name, reason, promise) && !localEventFired) {
                formatAndLogError(reason, "Unhandled rejection ");
              }
            } else {
              activeFireEvent(name, promise);
            }
          }
          function formatNonError(obj2) {
            var str;
            if (typeof obj2 === "function") {
              str = "[function " + (obj2.name || "anonymous") + "]";
            } else {
              str = obj2 && typeof obj2.toString === "function" ? obj2.toString() : util.toString(obj2);
              var ruselessToString = /\[object [a-zA-Z0-9$_]+\]/;
              if (ruselessToString.test(str)) {
                try {
                  var newStr = JSON.stringify(obj2);
                  str = newStr;
                } catch (e) {
                }
              }
              if (str.length === 0) {
                str = "(empty array)";
              }
            }
            return "(<" + snip(str) + ">, no stack trace)";
          }
          function snip(str) {
            var maxChars = 41;
            if (str.length < maxChars) {
              return str;
            }
            return str.substr(0, maxChars - 3) + "...";
          }
          function longStackTracesIsSupported() {
            return typeof captureStackTrace === "function";
          }
          var shouldIgnore = function() {
            return false;
          };
          var parseLineInfoRegex = /[\/<\(]([^:\/]+):(\d+):(?:\d+)\)?\s*$/;
          function parseLineInfo(line) {
            var matches = line.match(parseLineInfoRegex);
            if (matches) {
              return {
                fileName: matches[1],
                line: parseInt(matches[2], 10)
              };
            }
          }
          function setBounds(firstLineError, lastLineError) {
            if (!longStackTracesIsSupported())
              return;
            var firstStackLines = (firstLineError.stack || "").split("\n");
            var lastStackLines = (lastLineError.stack || "").split("\n");
            var firstIndex = -1;
            var lastIndex = -1;
            var firstFileName;
            var lastFileName;
            for (var i = 0; i < firstStackLines.length; ++i) {
              var result = parseLineInfo(firstStackLines[i]);
              if (result) {
                firstFileName = result.fileName;
                firstIndex = result.line;
                break;
              }
            }
            for (var i = 0; i < lastStackLines.length; ++i) {
              var result = parseLineInfo(lastStackLines[i]);
              if (result) {
                lastFileName = result.fileName;
                lastIndex = result.line;
                break;
              }
            }
            if (firstIndex < 0 || lastIndex < 0 || !firstFileName || !lastFileName || firstFileName !== lastFileName || firstIndex >= lastIndex) {
              return;
            }
            shouldIgnore = function(line) {
              if (bluebirdFramePattern.test(line))
                return true;
              var info = parseLineInfo(line);
              if (info) {
                if (info.fileName === firstFileName && (firstIndex <= info.line && info.line <= lastIndex)) {
                  return true;
                }
              }
              return false;
            };
          }
          function CapturedTrace(parent) {
            this._parent = parent;
            this._promisesCreated = 0;
            var length = this._length = 1 + (parent === void 0 ? 0 : parent._length);
            captureStackTrace(this, CapturedTrace);
            if (length > 32)
              this.uncycle();
          }
          util.inherits(CapturedTrace, Error);
          Context.CapturedTrace = CapturedTrace;
          CapturedTrace.prototype.uncycle = function() {
            var length = this._length;
            if (length < 2)
              return;
            var nodes = [];
            var stackToIndex = {};
            for (var i = 0, node = this; node !== void 0; ++i) {
              nodes.push(node);
              node = node._parent;
            }
            length = this._length = i;
            for (var i = length - 1; i >= 0; --i) {
              var stack = nodes[i].stack;
              if (stackToIndex[stack] === void 0) {
                stackToIndex[stack] = i;
              }
            }
            for (var i = 0; i < length; ++i) {
              var currentStack = nodes[i].stack;
              var index = stackToIndex[currentStack];
              if (index !== void 0 && index !== i) {
                if (index > 0) {
                  nodes[index - 1]._parent = void 0;
                  nodes[index - 1]._length = 1;
                }
                nodes[i]._parent = void 0;
                nodes[i]._length = 1;
                var cycleEdgeNode = i > 0 ? nodes[i - 1] : this;
                if (index < length - 1) {
                  cycleEdgeNode._parent = nodes[index + 1];
                  cycleEdgeNode._parent.uncycle();
                  cycleEdgeNode._length = cycleEdgeNode._parent._length + 1;
                } else {
                  cycleEdgeNode._parent = void 0;
                  cycleEdgeNode._length = 1;
                }
                var currentChildLength = cycleEdgeNode._length + 1;
                for (var j = i - 2; j >= 0; --j) {
                  nodes[j]._length = currentChildLength;
                  currentChildLength++;
                }
                return;
              }
            }
          };
          CapturedTrace.prototype.attachExtraTrace = function(error) {
            if (error.__stackCleaned__)
              return;
            this.uncycle();
            var parsed = parseStackAndMessage(error);
            var message = parsed.message;
            var stacks = [parsed.stack];
            var trace = this;
            while (trace !== void 0) {
              stacks.push(cleanStack(trace.stack.split("\n")));
              trace = trace._parent;
            }
            removeCommonRoots(stacks);
            removeDuplicateOrEmptyJumps(stacks);
            util.notEnumerableProp(error, "stack", reconstructStack(message, stacks));
            util.notEnumerableProp(error, "__stackCleaned__", true);
          };
          var captureStackTrace = function stackDetection() {
            var v8stackFramePattern = /^\s*at\s*/;
            var v8stackFormatter = function(stack, error) {
              if (typeof stack === "string")
                return stack;
              if (error.name !== void 0 && error.message !== void 0) {
                return error.toString();
              }
              return formatNonError(error);
            };
            if (typeof Error.stackTraceLimit === "number" && typeof Error.captureStackTrace === "function") {
              Error.stackTraceLimit += 6;
              stackFramePattern = v8stackFramePattern;
              formatStack = v8stackFormatter;
              var captureStackTrace2 = Error.captureStackTrace;
              shouldIgnore = function(line) {
                return bluebirdFramePattern.test(line);
              };
              return function(receiver2, ignoreUntil) {
                Error.stackTraceLimit += 6;
                captureStackTrace2(receiver2, ignoreUntil);
                Error.stackTraceLimit -= 6;
              };
            }
            var err = new Error();
            if (typeof err.stack === "string" && err.stack.split("\n")[0].indexOf("stackDetection@") >= 0) {
              stackFramePattern = /@/;
              formatStack = v8stackFormatter;
              indentStackFrames = true;
              return function captureStackTrace3(o) {
                o.stack = new Error().stack;
              };
            }
            var hasStackAfterThrow;
            try {
              throw new Error();
            } catch (e) {
              hasStackAfterThrow = "stack" in e;
            }
            if (!("stack" in err) && hasStackAfterThrow && typeof Error.stackTraceLimit === "number") {
              stackFramePattern = v8stackFramePattern;
              formatStack = v8stackFormatter;
              return function captureStackTrace3(o) {
                Error.stackTraceLimit += 6;
                try {
                  throw new Error();
                } catch (e) {
                  o.stack = e.stack;
                }
                Error.stackTraceLimit -= 6;
              };
            }
            formatStack = function(stack, error) {
              if (typeof stack === "string")
                return stack;
              if ((typeof error === "object" || typeof error === "function") && error.name !== void 0 && error.message !== void 0) {
                return error.toString();
              }
              return formatNonError(error);
            };
            return null;
          }([]);
          if (typeof console !== "undefined" && typeof console.warn !== "undefined") {
            printWarning = function(message) {
              console.warn(message);
            };
            if (util.isNode && process.stderr.isTTY) {
              printWarning = function(message, isSoft) {
                var color = isSoft ? "\x1B[33m" : "\x1B[31m";
                console.warn(color + message + "\x1B[0m\n");
              };
            } else if (!util.isNode && typeof new Error().stack === "string") {
              printWarning = function(message, isSoft) {
                console.warn(
                  "%c" + message,
                  isSoft ? "color: darkorange" : "color: red"
                );
              };
            }
          }
          var config = {
            warnings,
            longStackTraces: false,
            cancellation: false,
            monitoring: false,
            asyncHooks: false
          };
          if (longStackTraces)
            Promise2.longStackTraces();
          return {
            asyncHooks: function() {
              return config.asyncHooks;
            },
            longStackTraces: function() {
              return config.longStackTraces;
            },
            warnings: function() {
              return config.warnings;
            },
            cancellation: function() {
              return config.cancellation;
            },
            monitoring: function() {
              return config.monitoring;
            },
            propagateFromFunction: function() {
              return propagateFromFunction;
            },
            boundValueFunction: function() {
              return boundValueFunction;
            },
            checkForgottenReturns,
            setBounds,
            warn,
            deprecated,
            CapturedTrace,
            fireDomEvent,
            fireGlobalEvent
          };
        };
      }, { "./errors": 12, "./es5": 13, "./util": 36 }], 10: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2) {
          function returner() {
            return this.value;
          }
          function thrower2() {
            throw this.reason;
          }
          Promise2.prototype["return"] = Promise2.prototype.thenReturn = function(value) {
            if (value instanceof Promise2)
              value.suppressUnhandledRejections();
            return this._then(
              returner,
              void 0,
              void 0,
              { value },
              void 0
            );
          };
          Promise2.prototype["throw"] = Promise2.prototype.thenThrow = function(reason) {
            return this._then(
              thrower2,
              void 0,
              void 0,
              { reason },
              void 0
            );
          };
          Promise2.prototype.catchThrow = function(reason) {
            if (arguments.length <= 1) {
              return this._then(
                void 0,
                thrower2,
                void 0,
                { reason },
                void 0
              );
            } else {
              var _reason = arguments[1];
              var handler = function() {
                throw _reason;
              };
              return this.caught(reason, handler);
            }
          };
          Promise2.prototype.catchReturn = function(value) {
            if (arguments.length <= 1) {
              if (value instanceof Promise2)
                value.suppressUnhandledRejections();
              return this._then(
                void 0,
                returner,
                void 0,
                { value },
                void 0
              );
            } else {
              var _value = arguments[1];
              if (_value instanceof Promise2)
                _value.suppressUnhandledRejections();
              var handler = function() {
                return _value;
              };
              return this.caught(value, handler);
            }
          };
        };
      }, {}], 11: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, INTERNAL) {
          var PromiseReduce = Promise2.reduce;
          var PromiseAll = Promise2.all;
          function promiseAllThis() {
            return PromiseAll(this);
          }
          function PromiseMapSeries(promises, fn) {
            return PromiseReduce(promises, fn, INTERNAL, INTERNAL);
          }
          Promise2.prototype.each = function(fn) {
            return PromiseReduce(this, fn, INTERNAL, 0)._then(promiseAllThis, void 0, void 0, this, void 0);
          };
          Promise2.prototype.mapSeries = function(fn) {
            return PromiseReduce(this, fn, INTERNAL, INTERNAL);
          };
          Promise2.each = function(promises, fn) {
            return PromiseReduce(promises, fn, INTERNAL, 0)._then(promiseAllThis, void 0, void 0, promises, void 0);
          };
          Promise2.mapSeries = PromiseMapSeries;
        };
      }, {}], 12: [function(_dereq_2, module2, exports2) {
        "use strict";
        var es52 = _dereq_2("./es5");
        var Objectfreeze = es52.freeze;
        var util = _dereq_2("./util");
        var inherits2 = util.inherits;
        var notEnumerableProp2 = util.notEnumerableProp;
        function subError(nameProperty, defaultMessage) {
          function SubError(message) {
            if (!(this instanceof SubError))
              return new SubError(message);
            notEnumerableProp2(
              this,
              "message",
              typeof message === "string" ? message : defaultMessage
            );
            notEnumerableProp2(this, "name", nameProperty);
            if (Error.captureStackTrace) {
              Error.captureStackTrace(this, this.constructor);
            } else {
              Error.call(this);
            }
          }
          inherits2(SubError, Error);
          return SubError;
        }
        var _TypeError, _RangeError;
        var Warning = subError("Warning", "warning");
        var CancellationError = subError("CancellationError", "cancellation error");
        var TimeoutError = subError("TimeoutError", "timeout error");
        var AggregateError = subError("AggregateError", "aggregate error");
        try {
          _TypeError = TypeError;
          _RangeError = RangeError;
        } catch (e) {
          _TypeError = subError("TypeError", "type error");
          _RangeError = subError("RangeError", "range error");
        }
        var methods = "join pop push shift unshift slice filter forEach some every map indexOf lastIndexOf reduce reduceRight sort reverse".split(" ");
        for (var i = 0; i < methods.length; ++i) {
          if (typeof Array.prototype[methods[i]] === "function") {
            AggregateError.prototype[methods[i]] = Array.prototype[methods[i]];
          }
        }
        es52.defineProperty(AggregateError.prototype, "length", {
          value: 0,
          configurable: false,
          writable: true,
          enumerable: true
        });
        AggregateError.prototype["isOperational"] = true;
        var level = 0;
        AggregateError.prototype.toString = function() {
          var indent = Array(level * 4 + 1).join(" ");
          var ret2 = "\n" + indent + "AggregateError of:\n";
          level++;
          indent = Array(level * 4 + 1).join(" ");
          for (var i2 = 0; i2 < this.length; ++i2) {
            var str = this[i2] === this ? "[Circular AggregateError]" : this[i2] + "";
            var lines = str.split("\n");
            for (var j = 0; j < lines.length; ++j) {
              lines[j] = indent + lines[j];
            }
            str = lines.join("\n");
            ret2 += str + "\n";
          }
          level--;
          return ret2;
        };
        function OperationalError(message) {
          if (!(this instanceof OperationalError))
            return new OperationalError(message);
          notEnumerableProp2(this, "name", "OperationalError");
          notEnumerableProp2(this, "message", message);
          this.cause = message;
          this["isOperational"] = true;
          if (message instanceof Error) {
            notEnumerableProp2(this, "message", message.message);
            notEnumerableProp2(this, "stack", message.stack);
          } else if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
          }
        }
        inherits2(OperationalError, Error);
        var errorTypes = Error["__BluebirdErrorTypes__"];
        if (!errorTypes) {
          errorTypes = Objectfreeze({
            CancellationError,
            TimeoutError,
            OperationalError,
            RejectionError: OperationalError,
            AggregateError
          });
          es52.defineProperty(Error, "__BluebirdErrorTypes__", {
            value: errorTypes,
            writable: false,
            enumerable: false,
            configurable: false
          });
        }
        module2.exports = {
          Error,
          TypeError: _TypeError,
          RangeError: _RangeError,
          CancellationError: errorTypes.CancellationError,
          OperationalError: errorTypes.OperationalError,
          TimeoutError: errorTypes.TimeoutError,
          AggregateError: errorTypes.AggregateError,
          Warning
        };
      }, { "./es5": 13, "./util": 36 }], 13: [function(_dereq_2, module2, exports2) {
        var isES5 = function() {
          "use strict";
          return this === void 0;
        }();
        if (isES5) {
          module2.exports = {
            freeze: Object.freeze,
            defineProperty: Object.defineProperty,
            getDescriptor: Object.getOwnPropertyDescriptor,
            keys: Object.keys,
            names: Object.getOwnPropertyNames,
            getPrototypeOf: Object.getPrototypeOf,
            isArray: Array.isArray,
            isES5,
            propertyIsWritable: function(obj2, prop) {
              var descriptor = Object.getOwnPropertyDescriptor(obj2, prop);
              return !!(!descriptor || descriptor.writable || descriptor.set);
            }
          };
        } else {
          var has = {}.hasOwnProperty;
          var str = {}.toString;
          var proto = {}.constructor.prototype;
          var ObjectKeys = function(o) {
            var ret2 = [];
            for (var key in o) {
              if (has.call(o, key)) {
                ret2.push(key);
              }
            }
            return ret2;
          };
          var ObjectGetDescriptor = function(o, key) {
            return { value: o[key] };
          };
          var ObjectDefineProperty = function(o, key, desc) {
            o[key] = desc.value;
            return o;
          };
          var ObjectFreeze = function(obj2) {
            return obj2;
          };
          var ObjectGetPrototypeOf = function(obj2) {
            try {
              return Object(obj2).constructor.prototype;
            } catch (e) {
              return proto;
            }
          };
          var ArrayIsArray = function(obj2) {
            try {
              return str.call(obj2) === "[object Array]";
            } catch (e) {
              return false;
            }
          };
          module2.exports = {
            isArray: ArrayIsArray,
            keys: ObjectKeys,
            names: ObjectKeys,
            defineProperty: ObjectDefineProperty,
            getDescriptor: ObjectGetDescriptor,
            freeze: ObjectFreeze,
            getPrototypeOf: ObjectGetPrototypeOf,
            isES5,
            propertyIsWritable: function() {
              return true;
            }
          };
        }
      }, {}], 14: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, INTERNAL) {
          var PromiseMap = Promise2.map;
          Promise2.prototype.filter = function(fn, options) {
            return PromiseMap(this, fn, options, INTERNAL);
          };
          Promise2.filter = function(promises, fn, options) {
            return PromiseMap(promises, fn, options, INTERNAL);
          };
        };
      }, {}], 15: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, tryConvertToPromise, NEXT_FILTER) {
          var util = _dereq_2("./util");
          var CancellationError = Promise2.CancellationError;
          var errorObj2 = util.errorObj;
          var catchFilter = _dereq_2("./catch_filter")(NEXT_FILTER);
          function PassThroughHandlerContext(promise, type, handler) {
            this.promise = promise;
            this.type = type;
            this.handler = handler;
            this.called = false;
            this.cancelPromise = null;
          }
          PassThroughHandlerContext.prototype.isFinallyHandler = function() {
            return this.type === 0;
          };
          function FinallyHandlerCancelReaction(finallyHandler2) {
            this.finallyHandler = finallyHandler2;
          }
          FinallyHandlerCancelReaction.prototype._resultCancelled = function() {
            checkCancel(this.finallyHandler);
          };
          function checkCancel(ctx, reason) {
            if (ctx.cancelPromise != null) {
              if (arguments.length > 1) {
                ctx.cancelPromise._reject(reason);
              } else {
                ctx.cancelPromise._cancel();
              }
              ctx.cancelPromise = null;
              return true;
            }
            return false;
          }
          function succeed() {
            return finallyHandler.call(this, this.promise._target()._settledValue());
          }
          function fail(reason) {
            if (checkCancel(this, reason))
              return;
            errorObj2.e = reason;
            return errorObj2;
          }
          function finallyHandler(reasonOrValue) {
            var promise = this.promise;
            var handler = this.handler;
            if (!this.called) {
              this.called = true;
              var ret2 = this.isFinallyHandler() ? handler.call(promise._boundValue()) : handler.call(promise._boundValue(), reasonOrValue);
              if (ret2 === NEXT_FILTER) {
                return ret2;
              } else if (ret2 !== void 0) {
                promise._setReturnedNonUndefined();
                var maybePromise = tryConvertToPromise(ret2, promise);
                if (maybePromise instanceof Promise2) {
                  if (this.cancelPromise != null) {
                    if (maybePromise._isCancelled()) {
                      var reason = new CancellationError("late cancellation observer");
                      promise._attachExtraTrace(reason);
                      errorObj2.e = reason;
                      return errorObj2;
                    } else if (maybePromise.isPending()) {
                      maybePromise._attachCancellationCallback(
                        new FinallyHandlerCancelReaction(this)
                      );
                    }
                  }
                  return maybePromise._then(
                    succeed,
                    fail,
                    void 0,
                    this,
                    void 0
                  );
                }
              }
            }
            if (promise.isRejected()) {
              checkCancel(this);
              errorObj2.e = reasonOrValue;
              return errorObj2;
            } else {
              checkCancel(this);
              return reasonOrValue;
            }
          }
          Promise2.prototype._passThrough = function(handler, type, success, fail2) {
            if (typeof handler !== "function")
              return this.then();
            return this._then(
              success,
              fail2,
              void 0,
              new PassThroughHandlerContext(this, type, handler),
              void 0
            );
          };
          Promise2.prototype.lastly = Promise2.prototype["finally"] = function(handler) {
            return this._passThrough(
              handler,
              0,
              finallyHandler,
              finallyHandler
            );
          };
          Promise2.prototype.tap = function(handler) {
            return this._passThrough(handler, 1, finallyHandler);
          };
          Promise2.prototype.tapCatch = function(handlerOrPredicate) {
            var len = arguments.length;
            if (len === 1) {
              return this._passThrough(
                handlerOrPredicate,
                1,
                void 0,
                finallyHandler
              );
            } else {
              var catchInstances = new Array(len - 1), j = 0, i;
              for (i = 0; i < len - 1; ++i) {
                var item = arguments[i];
                if (util.isObject(item)) {
                  catchInstances[j++] = item;
                } else {
                  return Promise2.reject(new TypeError(
                    "tapCatch statement predicate: expecting an object but got " + util.classString(item)
                  ));
                }
              }
              catchInstances.length = j;
              var handler = arguments[i];
              return this._passThrough(
                catchFilter(catchInstances, handler, this),
                1,
                void 0,
                finallyHandler
              );
            }
          };
          return PassThroughHandlerContext;
        };
      }, { "./catch_filter": 7, "./util": 36 }], 16: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, apiRejection, INTERNAL, tryConvertToPromise, Proxyable, debug) {
          var errors = _dereq_2("./errors");
          var TypeError2 = errors.TypeError;
          var util = _dereq_2("./util");
          var errorObj2 = util.errorObj;
          var tryCatch2 = util.tryCatch;
          var yieldHandlers = [];
          function promiseFromYieldHandler(value, yieldHandlers2, traceParent) {
            for (var i = 0; i < yieldHandlers2.length; ++i) {
              traceParent._pushContext();
              var result = tryCatch2(yieldHandlers2[i])(value);
              traceParent._popContext();
              if (result === errorObj2) {
                traceParent._pushContext();
                var ret2 = Promise2.reject(errorObj2.e);
                traceParent._popContext();
                return ret2;
              }
              var maybePromise = tryConvertToPromise(result, traceParent);
              if (maybePromise instanceof Promise2)
                return maybePromise;
            }
            return null;
          }
          function PromiseSpawn(generatorFunction, receiver2, yieldHandler, stack) {
            if (debug.cancellation()) {
              var internal = new Promise2(INTERNAL);
              var _finallyPromise = this._finallyPromise = new Promise2(INTERNAL);
              this._promise = internal.lastly(function() {
                return _finallyPromise;
              });
              internal._captureStackTrace();
              internal._setOnCancel(this);
            } else {
              var promise = this._promise = new Promise2(INTERNAL);
              promise._captureStackTrace();
            }
            this._stack = stack;
            this._generatorFunction = generatorFunction;
            this._receiver = receiver2;
            this._generator = void 0;
            this._yieldHandlers = typeof yieldHandler === "function" ? [yieldHandler].concat(yieldHandlers) : yieldHandlers;
            this._yieldedPromise = null;
            this._cancellationPhase = false;
          }
          util.inherits(PromiseSpawn, Proxyable);
          PromiseSpawn.prototype._isResolved = function() {
            return this._promise === null;
          };
          PromiseSpawn.prototype._cleanup = function() {
            this._promise = this._generator = null;
            if (debug.cancellation() && this._finallyPromise !== null) {
              this._finallyPromise._fulfill();
              this._finallyPromise = null;
            }
          };
          PromiseSpawn.prototype._promiseCancelled = function() {
            if (this._isResolved())
              return;
            var implementsReturn = typeof this._generator["return"] !== "undefined";
            var result;
            if (!implementsReturn) {
              var reason = new Promise2.CancellationError(
                "generator .return() sentinel"
              );
              Promise2.coroutine.returnSentinel = reason;
              this._promise._attachExtraTrace(reason);
              this._promise._pushContext();
              result = tryCatch2(this._generator["throw"]).call(
                this._generator,
                reason
              );
              this._promise._popContext();
            } else {
              this._promise._pushContext();
              result = tryCatch2(this._generator["return"]).call(
                this._generator,
                void 0
              );
              this._promise._popContext();
            }
            this._cancellationPhase = true;
            this._yieldedPromise = null;
            this._continue(result);
          };
          PromiseSpawn.prototype._promiseFulfilled = function(value) {
            this._yieldedPromise = null;
            this._promise._pushContext();
            var result = tryCatch2(this._generator.next).call(this._generator, value);
            this._promise._popContext();
            this._continue(result);
          };
          PromiseSpawn.prototype._promiseRejected = function(reason) {
            this._yieldedPromise = null;
            this._promise._attachExtraTrace(reason);
            this._promise._pushContext();
            var result = tryCatch2(this._generator["throw"]).call(this._generator, reason);
            this._promise._popContext();
            this._continue(result);
          };
          PromiseSpawn.prototype._resultCancelled = function() {
            if (this._yieldedPromise instanceof Promise2) {
              var promise = this._yieldedPromise;
              this._yieldedPromise = null;
              promise.cancel();
            }
          };
          PromiseSpawn.prototype.promise = function() {
            return this._promise;
          };
          PromiseSpawn.prototype._run = function() {
            this._generator = this._generatorFunction.call(this._receiver);
            this._receiver = this._generatorFunction = void 0;
            this._promiseFulfilled(void 0);
          };
          PromiseSpawn.prototype._continue = function(result) {
            var promise = this._promise;
            if (result === errorObj2) {
              this._cleanup();
              if (this._cancellationPhase) {
                return promise.cancel();
              } else {
                return promise._rejectCallback(result.e, false);
              }
            }
            var value = result.value;
            if (result.done === true) {
              this._cleanup();
              if (this._cancellationPhase) {
                return promise.cancel();
              } else {
                return promise._resolveCallback(value);
              }
            } else {
              var maybePromise = tryConvertToPromise(value, this._promise);
              if (!(maybePromise instanceof Promise2)) {
                maybePromise = promiseFromYieldHandler(
                  maybePromise,
                  this._yieldHandlers,
                  this._promise
                );
                if (maybePromise === null) {
                  this._promiseRejected(
                    new TypeError2(
                      "A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/MqrFmX\n\n".replace("%s", String(value)) + "From coroutine:\n" + this._stack.split("\n").slice(1, -7).join("\n")
                    )
                  );
                  return;
                }
              }
              maybePromise = maybePromise._target();
              var bitField = maybePromise._bitField;
              ;
              if ((bitField & 50397184) === 0) {
                this._yieldedPromise = maybePromise;
                maybePromise._proxy(this, null);
              } else if ((bitField & 33554432) !== 0) {
                Promise2._async.invoke(
                  this._promiseFulfilled,
                  this,
                  maybePromise._value()
                );
              } else if ((bitField & 16777216) !== 0) {
                Promise2._async.invoke(
                  this._promiseRejected,
                  this,
                  maybePromise._reason()
                );
              } else {
                this._promiseCancelled();
              }
            }
          };
          Promise2.coroutine = function(generatorFunction, options) {
            if (typeof generatorFunction !== "function") {
              throw new TypeError2("generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n");
            }
            var yieldHandler = Object(options).yieldHandler;
            var PromiseSpawn$ = PromiseSpawn;
            var stack = new Error().stack;
            return function() {
              var generator = generatorFunction.apply(this, arguments);
              var spawn = new PromiseSpawn$(
                void 0,
                void 0,
                yieldHandler,
                stack
              );
              var ret2 = spawn.promise();
              spawn._generator = generator;
              spawn._promiseFulfilled(void 0);
              return ret2;
            };
          };
          Promise2.coroutine.addYieldHandler = function(fn) {
            if (typeof fn !== "function") {
              throw new TypeError2("expecting a function but got " + util.classString(fn));
            }
            yieldHandlers.push(fn);
          };
          Promise2.spawn = function(generatorFunction) {
            debug.deprecated("Promise.spawn()", "Promise.coroutine()");
            if (typeof generatorFunction !== "function") {
              return apiRejection("generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n");
            }
            var spawn = new PromiseSpawn(generatorFunction, this);
            var ret2 = spawn.promise();
            spawn._run(Promise2.spawn);
            return ret2;
          };
        };
      }, { "./errors": 12, "./util": 36 }], 17: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, PromiseArray, tryConvertToPromise, INTERNAL, async) {
          var util = _dereq_2("./util");
          var canEvaluate2 = util.canEvaluate;
          var tryCatch2 = util.tryCatch;
          var errorObj2 = util.errorObj;
          var reject;
          if (false) {
            if (canEvaluate2) {
              var thenCallback = function(i2) {
                return new Function("value", "holder", "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ".replace(/Index/g, i2));
              };
              var promiseSetter = function(i2) {
                return new Function("promise", "holder", "                           \n            'use strict';                                                    \n            holder.pIndex = promise;                                         \n            ".replace(/Index/g, i2));
              };
              var generateHolderClass = function(total) {
                var props = new Array(total);
                for (var i2 = 0; i2 < props.length; ++i2) {
                  props[i2] = "this.p" + (i2 + 1);
                }
                var assignment = props.join(" = ") + " = null;";
                var cancellationCode = "var promise;\n" + props.map(function(prop) {
                  return "                                                         \n                promise = " + prop + ";                                      \n                if (promise instanceof Promise) {                            \n                    promise.cancel();                                        \n                }                                                            \n            ";
                }).join("\n");
                var passedArguments = props.join(", ");
                var name = "Holder$" + total;
                var code = "return function(tryCatch, errorObj, Promise, async) {    \n            'use strict';                                                    \n            function [TheName](fn) {                                         \n                [TheProperties]                                              \n                this.fn = fn;                                                \n                this.asyncNeeded = true;                                     \n                this.now = 0;                                                \n            }                                                                \n                                                                             \n            [TheName].prototype._callFunction = function(promise) {          \n                promise._pushContext();                                      \n                var ret = tryCatch(this.fn)([ThePassedArguments]);           \n                promise._popContext();                                       \n                if (ret === errorObj) {                                      \n                    promise._rejectCallback(ret.e, false);                   \n                } else {                                                     \n                    promise._resolveCallback(ret);                           \n                }                                                            \n            };                                                               \n                                                                             \n            [TheName].prototype.checkFulfillment = function(promise) {       \n                var now = ++this.now;                                        \n                if (now === [TheTotal]) {                                    \n                    if (this.asyncNeeded) {                                  \n                        async.invoke(this._callFunction, this, promise);     \n                    } else {                                                 \n                        this._callFunction(promise);                         \n                    }                                                        \n                                                                             \n                }                                                            \n            };                                                               \n                                                                             \n            [TheName].prototype._resultCancelled = function() {              \n                [CancellationCode]                                           \n            };                                                               \n                                                                             \n            return [TheName];                                                \n        }(tryCatch, errorObj, Promise, async);                               \n        ";
                code = code.replace(/\[TheName\]/g, name).replace(/\[TheTotal\]/g, total).replace(/\[ThePassedArguments\]/g, passedArguments).replace(/\[TheProperties\]/g, assignment).replace(/\[CancellationCode\]/g, cancellationCode);
                return new Function("tryCatch", "errorObj", "Promise", "async", code)(tryCatch2, errorObj2, Promise2, async);
              };
              var holderClasses = [];
              var thenCallbacks = [];
              var promiseSetters = [];
              for (var i = 0; i < 8; ++i) {
                holderClasses.push(generateHolderClass(i + 1));
                thenCallbacks.push(thenCallback(i + 1));
                promiseSetters.push(promiseSetter(i + 1));
              }
              reject = function(reason) {
                this._reject(reason);
              };
            }
          }
          Promise2.join = function() {
            var last = arguments.length - 1;
            var fn;
            if (last > 0 && typeof arguments[last] === "function") {
              fn = arguments[last];
              if (false) {
                if (last <= 8 && canEvaluate2) {
                  var ret2 = new Promise2(INTERNAL);
                  ret2._captureStackTrace();
                  var HolderClass = holderClasses[last - 1];
                  var holder = new HolderClass(fn);
                  var callbacks = thenCallbacks;
                  for (var i2 = 0; i2 < last; ++i2) {
                    var maybePromise = tryConvertToPromise(arguments[i2], ret2);
                    if (maybePromise instanceof Promise2) {
                      maybePromise = maybePromise._target();
                      var bitField = maybePromise._bitField;
                      ;
                      if ((bitField & 50397184) === 0) {
                        maybePromise._then(
                          callbacks[i2],
                          reject,
                          void 0,
                          ret2,
                          holder
                        );
                        promiseSetters[i2](maybePromise, holder);
                        holder.asyncNeeded = false;
                      } else if ((bitField & 33554432) !== 0) {
                        callbacks[i2].call(
                          ret2,
                          maybePromise._value(),
                          holder
                        );
                      } else if ((bitField & 16777216) !== 0) {
                        ret2._reject(maybePromise._reason());
                      } else {
                        ret2._cancel();
                      }
                    } else {
                      callbacks[i2].call(ret2, maybePromise, holder);
                    }
                  }
                  if (!ret2._isFateSealed()) {
                    if (holder.asyncNeeded) {
                      var context = Promise2._getContext();
                      holder.fn = util.contextBind(context, holder.fn);
                    }
                    ret2._setAsyncGuaranteed();
                    ret2._setOnCancel(holder);
                  }
                  return ret2;
                }
              }
            }
            var args = [].slice.call(arguments);
            ;
            if (fn)
              args.pop();
            var ret2 = new PromiseArray(args).promise();
            return fn !== void 0 ? ret2.spread(fn) : ret2;
          };
        };
      }, { "./util": 36 }], 18: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug) {
          var util = _dereq_2("./util");
          var tryCatch2 = util.tryCatch;
          var errorObj2 = util.errorObj;
          var async = Promise2._async;
          function MappingPromiseArray(promises, fn, limit, _filter) {
            this.constructor$(promises);
            this._promise._captureStackTrace();
            var context = Promise2._getContext();
            this._callback = util.contextBind(context, fn);
            this._preservedValues = _filter === INTERNAL ? new Array(this.length()) : null;
            this._limit = limit;
            this._inFlight = 0;
            this._queue = [];
            async.invoke(this._asyncInit, this, void 0);
            if (util.isArray(promises)) {
              for (var i = 0; i < promises.length; ++i) {
                var maybePromise = promises[i];
                if (maybePromise instanceof Promise2) {
                  maybePromise.suppressUnhandledRejections();
                }
              }
            }
          }
          util.inherits(MappingPromiseArray, PromiseArray);
          MappingPromiseArray.prototype._asyncInit = function() {
            this._init$(void 0, -2);
          };
          MappingPromiseArray.prototype._init = function() {
          };
          MappingPromiseArray.prototype._promiseFulfilled = function(value, index) {
            var values = this._values;
            var length = this.length();
            var preservedValues = this._preservedValues;
            var limit = this._limit;
            if (index < 0) {
              index = index * -1 - 1;
              values[index] = value;
              if (limit >= 1) {
                this._inFlight--;
                this._drainQueue();
                if (this._isResolved())
                  return true;
              }
            } else {
              if (limit >= 1 && this._inFlight >= limit) {
                values[index] = value;
                this._queue.push(index);
                return false;
              }
              if (preservedValues !== null)
                preservedValues[index] = value;
              var promise = this._promise;
              var callback = this._callback;
              var receiver2 = promise._boundValue();
              promise._pushContext();
              var ret2 = tryCatch2(callback).call(receiver2, value, index, length);
              var promiseCreated = promise._popContext();
              debug.checkForgottenReturns(
                ret2,
                promiseCreated,
                preservedValues !== null ? "Promise.filter" : "Promise.map",
                promise
              );
              if (ret2 === errorObj2) {
                this._reject(ret2.e);
                return true;
              }
              var maybePromise = tryConvertToPromise(ret2, this._promise);
              if (maybePromise instanceof Promise2) {
                maybePromise = maybePromise._target();
                var bitField = maybePromise._bitField;
                ;
                if ((bitField & 50397184) === 0) {
                  if (limit >= 1)
                    this._inFlight++;
                  values[index] = maybePromise;
                  maybePromise._proxy(this, (index + 1) * -1);
                  return false;
                } else if ((bitField & 33554432) !== 0) {
                  ret2 = maybePromise._value();
                } else if ((bitField & 16777216) !== 0) {
                  this._reject(maybePromise._reason());
                  return true;
                } else {
                  this._cancel();
                  return true;
                }
              }
              values[index] = ret2;
            }
            var totalResolved = ++this._totalResolved;
            if (totalResolved >= length) {
              if (preservedValues !== null) {
                this._filter(values, preservedValues);
              } else {
                this._resolve(values);
              }
              return true;
            }
            return false;
          };
          MappingPromiseArray.prototype._drainQueue = function() {
            var queue = this._queue;
            var limit = this._limit;
            var values = this._values;
            while (queue.length > 0 && this._inFlight < limit) {
              if (this._isResolved())
                return;
              var index = queue.pop();
              this._promiseFulfilled(values[index], index);
            }
          };
          MappingPromiseArray.prototype._filter = function(booleans, values) {
            var len = values.length;
            var ret2 = new Array(len);
            var j = 0;
            for (var i = 0; i < len; ++i) {
              if (booleans[i])
                ret2[j++] = values[i];
            }
            ret2.length = j;
            this._resolve(ret2);
          };
          MappingPromiseArray.prototype.preservedValues = function() {
            return this._preservedValues;
          };
          function map(promises, fn, options, _filter) {
            if (typeof fn !== "function") {
              return apiRejection("expecting a function but got " + util.classString(fn));
            }
            var limit = 0;
            if (options !== void 0) {
              if (typeof options === "object" && options !== null) {
                if (typeof options.concurrency !== "number") {
                  return Promise2.reject(
                    new TypeError("'concurrency' must be a number but it is " + util.classString(options.concurrency))
                  );
                }
                limit = options.concurrency;
              } else {
                return Promise2.reject(new TypeError(
                  "options argument must be an object but it is " + util.classString(options)
                ));
              }
            }
            limit = typeof limit === "number" && isFinite(limit) && limit >= 1 ? limit : 0;
            return new MappingPromiseArray(promises, fn, limit, _filter).promise();
          }
          Promise2.prototype.map = function(fn, options) {
            return map(this, fn, options, null);
          };
          Promise2.map = function(promises, fn, options, _filter) {
            return map(promises, fn, options, _filter);
          };
        };
      }, { "./util": 36 }], 19: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, INTERNAL, tryConvertToPromise, apiRejection, debug) {
          var util = _dereq_2("./util");
          var tryCatch2 = util.tryCatch;
          Promise2.method = function(fn) {
            if (typeof fn !== "function") {
              throw new Promise2.TypeError("expecting a function but got " + util.classString(fn));
            }
            return function() {
              var ret2 = new Promise2(INTERNAL);
              ret2._captureStackTrace();
              ret2._pushContext();
              var value = tryCatch2(fn).apply(this, arguments);
              var promiseCreated = ret2._popContext();
              debug.checkForgottenReturns(
                value,
                promiseCreated,
                "Promise.method",
                ret2
              );
              ret2._resolveFromSyncValue(value);
              return ret2;
            };
          };
          Promise2.attempt = Promise2["try"] = function(fn) {
            if (typeof fn !== "function") {
              return apiRejection("expecting a function but got " + util.classString(fn));
            }
            var ret2 = new Promise2(INTERNAL);
            ret2._captureStackTrace();
            ret2._pushContext();
            var value;
            if (arguments.length > 1) {
              debug.deprecated("calling Promise.try with more than 1 argument");
              var arg = arguments[1];
              var ctx = arguments[2];
              value = util.isArray(arg) ? tryCatch2(fn).apply(ctx, arg) : tryCatch2(fn).call(ctx, arg);
            } else {
              value = tryCatch2(fn)();
            }
            var promiseCreated = ret2._popContext();
            debug.checkForgottenReturns(
              value,
              promiseCreated,
              "Promise.try",
              ret2
            );
            ret2._resolveFromSyncValue(value);
            return ret2;
          };
          Promise2.prototype._resolveFromSyncValue = function(value) {
            if (value === util.errorObj) {
              this._rejectCallback(value.e, false);
            } else {
              this._resolveCallback(value, true);
            }
          };
        };
      }, { "./util": 36 }], 20: [function(_dereq_2, module2, exports2) {
        "use strict";
        var util = _dereq_2("./util");
        var maybeWrapAsError2 = util.maybeWrapAsError;
        var errors = _dereq_2("./errors");
        var OperationalError = errors.OperationalError;
        var es52 = _dereq_2("./es5");
        function isUntypedError(obj2) {
          return obj2 instanceof Error && es52.getPrototypeOf(obj2) === Error.prototype;
        }
        var rErrorKey = /^(?:name|message|stack|cause)$/;
        function wrapAsOperationalError(obj2) {
          var ret2;
          if (isUntypedError(obj2)) {
            ret2 = new OperationalError(obj2);
            ret2.name = obj2.name;
            ret2.message = obj2.message;
            ret2.stack = obj2.stack;
            var keys = es52.keys(obj2);
            for (var i = 0; i < keys.length; ++i) {
              var key = keys[i];
              if (!rErrorKey.test(key)) {
                ret2[key] = obj2[key];
              }
            }
            return ret2;
          }
          util.markAsOriginatingFromRejection(obj2);
          return obj2;
        }
        function nodebackForPromise(promise, multiArgs) {
          return function(err, value) {
            if (promise === null)
              return;
            if (err) {
              var wrapped = wrapAsOperationalError(maybeWrapAsError2(err));
              promise._attachExtraTrace(wrapped);
              promise._reject(wrapped);
            } else if (!multiArgs) {
              promise._fulfill(value);
            } else {
              var args = [].slice.call(arguments, 1);
              ;
              promise._fulfill(args);
            }
            promise = null;
          };
        }
        module2.exports = nodebackForPromise;
      }, { "./errors": 12, "./es5": 13, "./util": 36 }], 21: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2) {
          var util = _dereq_2("./util");
          var async = Promise2._async;
          var tryCatch2 = util.tryCatch;
          var errorObj2 = util.errorObj;
          function spreadAdapter(val, nodeback) {
            var promise = this;
            if (!util.isArray(val))
              return successAdapter.call(promise, val, nodeback);
            var ret2 = tryCatch2(nodeback).apply(promise._boundValue(), [null].concat(val));
            if (ret2 === errorObj2) {
              async.throwLater(ret2.e);
            }
          }
          function successAdapter(val, nodeback) {
            var promise = this;
            var receiver2 = promise._boundValue();
            var ret2 = val === void 0 ? tryCatch2(nodeback).call(receiver2, null) : tryCatch2(nodeback).call(receiver2, null, val);
            if (ret2 === errorObj2) {
              async.throwLater(ret2.e);
            }
          }
          function errorAdapter(reason, nodeback) {
            var promise = this;
            if (!reason) {
              var newReason = new Error(reason + "");
              newReason.cause = reason;
              reason = newReason;
            }
            var ret2 = tryCatch2(nodeback).call(promise._boundValue(), reason);
            if (ret2 === errorObj2) {
              async.throwLater(ret2.e);
            }
          }
          Promise2.prototype.asCallback = Promise2.prototype.nodeify = function(nodeback, options) {
            if (typeof nodeback == "function") {
              var adapter = successAdapter;
              if (options !== void 0 && Object(options).spread) {
                adapter = spreadAdapter;
              }
              this._then(
                adapter,
                errorAdapter,
                void 0,
                this,
                nodeback
              );
            }
            return this;
          };
        };
      }, { "./util": 36 }], 22: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function() {
          var makeSelfResolutionError = function() {
            return new TypeError2("circular promise resolution chain\n\n    See http://goo.gl/MqrFmX\n");
          };
          var reflectHandler2 = function() {
            return new Promise2.PromiseInspection(this._target());
          };
          var apiRejection = function(msg) {
            return Promise2.reject(new TypeError2(msg));
          };
          function Proxyable() {
          }
          var UNDEFINED_BINDING = {};
          var util = _dereq_2("./util");
          util.setReflectHandler(reflectHandler2);
          var getDomain = function() {
            var domain = process.domain;
            if (domain === void 0) {
              return null;
            }
            return domain;
          };
          var getContextDefault = function() {
            return null;
          };
          var getContextDomain = function() {
            return {
              domain: getDomain(),
              async: null
            };
          };
          var AsyncResource = util.isNode && util.nodeSupportsAsyncResource ? _dereq_2("async_hooks").AsyncResource : null;
          var getContextAsyncHooks = function() {
            return {
              domain: getDomain(),
              async: new AsyncResource("Bluebird::Promise")
            };
          };
          var getContext = util.isNode ? getContextDomain : getContextDefault;
          util.notEnumerableProp(Promise2, "_getContext", getContext);
          var enableAsyncHooks = function() {
            getContext = getContextAsyncHooks;
            util.notEnumerableProp(Promise2, "_getContext", getContextAsyncHooks);
          };
          var disableAsyncHooks = function() {
            getContext = getContextDomain;
            util.notEnumerableProp(Promise2, "_getContext", getContextDomain);
          };
          var es52 = _dereq_2("./es5");
          var Async = _dereq_2("./async");
          var async = new Async();
          es52.defineProperty(Promise2, "_async", { value: async });
          var errors = _dereq_2("./errors");
          var TypeError2 = Promise2.TypeError = errors.TypeError;
          Promise2.RangeError = errors.RangeError;
          var CancellationError = Promise2.CancellationError = errors.CancellationError;
          Promise2.TimeoutError = errors.TimeoutError;
          Promise2.OperationalError = errors.OperationalError;
          Promise2.RejectionError = errors.OperationalError;
          Promise2.AggregateError = errors.AggregateError;
          var INTERNAL = function() {
          };
          var APPLY = {};
          var NEXT_FILTER = {};
          var tryConvertToPromise = _dereq_2("./thenables")(Promise2, INTERNAL);
          var PromiseArray = _dereq_2("./promise_array")(
            Promise2,
            INTERNAL,
            tryConvertToPromise,
            apiRejection,
            Proxyable
          );
          var Context = _dereq_2("./context")(Promise2);
          var createContext = Context.create;
          var debug = _dereq_2("./debuggability")(
            Promise2,
            Context,
            enableAsyncHooks,
            disableAsyncHooks
          );
          var CapturedTrace = debug.CapturedTrace;
          var PassThroughHandlerContext = _dereq_2("./finally")(Promise2, tryConvertToPromise, NEXT_FILTER);
          var catchFilter = _dereq_2("./catch_filter")(NEXT_FILTER);
          var nodebackForPromise = _dereq_2("./nodeback");
          var errorObj2 = util.errorObj;
          var tryCatch2 = util.tryCatch;
          function check(self2, executor) {
            if (self2 == null || self2.constructor !== Promise2) {
              throw new TypeError2("the promise constructor cannot be invoked directly\n\n    See http://goo.gl/MqrFmX\n");
            }
            if (typeof executor !== "function") {
              throw new TypeError2("expecting a function but got " + util.classString(executor));
            }
          }
          function Promise2(executor) {
            if (executor !== INTERNAL) {
              check(this, executor);
            }
            this._bitField = 0;
            this._fulfillmentHandler0 = void 0;
            this._rejectionHandler0 = void 0;
            this._promise0 = void 0;
            this._receiver0 = void 0;
            this._resolveFromExecutor(executor);
            this._promiseCreated();
            this._fireEvent("promiseCreated", this);
          }
          Promise2.prototype.toString = function() {
            return "[object Promise]";
          };
          Promise2.prototype.caught = Promise2.prototype["catch"] = function(fn) {
            var len = arguments.length;
            if (len > 1) {
              var catchInstances = new Array(len - 1), j = 0, i;
              for (i = 0; i < len - 1; ++i) {
                var item = arguments[i];
                if (util.isObject(item)) {
                  catchInstances[j++] = item;
                } else {
                  return apiRejection("Catch statement predicate: expecting an object but got " + util.classString(item));
                }
              }
              catchInstances.length = j;
              fn = arguments[i];
              if (typeof fn !== "function") {
                throw new TypeError2("The last argument to .catch() must be a function, got " + util.toString(fn));
              }
              return this.then(void 0, catchFilter(catchInstances, fn, this));
            }
            return this.then(void 0, fn);
          };
          Promise2.prototype.reflect = function() {
            return this._then(
              reflectHandler2,
              reflectHandler2,
              void 0,
              this,
              void 0
            );
          };
          Promise2.prototype.then = function(didFulfill, didReject) {
            if (debug.warnings() && arguments.length > 0 && typeof didFulfill !== "function" && typeof didReject !== "function") {
              var msg = ".then() only accepts functions but was passed: " + util.classString(didFulfill);
              if (arguments.length > 1) {
                msg += ", " + util.classString(didReject);
              }
              this._warn(msg);
            }
            return this._then(didFulfill, didReject, void 0, void 0, void 0);
          };
          Promise2.prototype.done = function(didFulfill, didReject) {
            var promise = this._then(didFulfill, didReject, void 0, void 0, void 0);
            promise._setIsFinal();
          };
          Promise2.prototype.spread = function(fn) {
            if (typeof fn !== "function") {
              return apiRejection("expecting a function but got " + util.classString(fn));
            }
            return this.all()._then(fn, void 0, void 0, APPLY, void 0);
          };
          Promise2.prototype.toJSON = function() {
            var ret2 = {
              isFulfilled: false,
              isRejected: false,
              fulfillmentValue: void 0,
              rejectionReason: void 0
            };
            if (this.isFulfilled()) {
              ret2.fulfillmentValue = this.value();
              ret2.isFulfilled = true;
            } else if (this.isRejected()) {
              ret2.rejectionReason = this.reason();
              ret2.isRejected = true;
            }
            return ret2;
          };
          Promise2.prototype.all = function() {
            if (arguments.length > 0) {
              this._warn(".all() was passed arguments but it does not take any");
            }
            return new PromiseArray(this).promise();
          };
          Promise2.prototype.error = function(fn) {
            return this.caught(util.originatesFromRejection, fn);
          };
          Promise2.getNewLibraryCopy = module2.exports;
          Promise2.is = function(val) {
            return val instanceof Promise2;
          };
          Promise2.fromNode = Promise2.fromCallback = function(fn) {
            var ret2 = new Promise2(INTERNAL);
            ret2._captureStackTrace();
            var multiArgs = arguments.length > 1 ? !!Object(arguments[1]).multiArgs : false;
            var result = tryCatch2(fn)(nodebackForPromise(ret2, multiArgs));
            if (result === errorObj2) {
              ret2._rejectCallback(result.e, true);
            }
            if (!ret2._isFateSealed())
              ret2._setAsyncGuaranteed();
            return ret2;
          };
          Promise2.all = function(promises) {
            return new PromiseArray(promises).promise();
          };
          Promise2.cast = function(obj2) {
            var ret2 = tryConvertToPromise(obj2);
            if (!(ret2 instanceof Promise2)) {
              ret2 = new Promise2(INTERNAL);
              ret2._captureStackTrace();
              ret2._setFulfilled();
              ret2._rejectionHandler0 = obj2;
            }
            return ret2;
          };
          Promise2.resolve = Promise2.fulfilled = Promise2.cast;
          Promise2.reject = Promise2.rejected = function(reason) {
            var ret2 = new Promise2(INTERNAL);
            ret2._captureStackTrace();
            ret2._rejectCallback(reason, true);
            return ret2;
          };
          Promise2.setScheduler = function(fn) {
            if (typeof fn !== "function") {
              throw new TypeError2("expecting a function but got " + util.classString(fn));
            }
            return async.setScheduler(fn);
          };
          Promise2.prototype._then = function(didFulfill, didReject, _, receiver2, internalData) {
            var haveInternalData = internalData !== void 0;
            var promise = haveInternalData ? internalData : new Promise2(INTERNAL);
            var target = this._target();
            var bitField = target._bitField;
            if (!haveInternalData) {
              promise._propagateFrom(this, 3);
              promise._captureStackTrace();
              if (receiver2 === void 0 && (this._bitField & 2097152) !== 0) {
                if (!((bitField & 50397184) === 0)) {
                  receiver2 = this._boundValue();
                } else {
                  receiver2 = target === this ? void 0 : this._boundTo;
                }
              }
              this._fireEvent("promiseChained", this, promise);
            }
            var context = getContext();
            if (!((bitField & 50397184) === 0)) {
              var handler, value, settler = target._settlePromiseCtx;
              if ((bitField & 33554432) !== 0) {
                value = target._rejectionHandler0;
                handler = didFulfill;
              } else if ((bitField & 16777216) !== 0) {
                value = target._fulfillmentHandler0;
                handler = didReject;
                target._unsetRejectionIsUnhandled();
              } else {
                settler = target._settlePromiseLateCancellationObserver;
                value = new CancellationError("late cancellation observer");
                target._attachExtraTrace(value);
                handler = didReject;
              }
              async.invoke(settler, target, {
                handler: util.contextBind(context, handler),
                promise,
                receiver: receiver2,
                value
              });
            } else {
              target._addCallbacks(
                didFulfill,
                didReject,
                promise,
                receiver2,
                context
              );
            }
            return promise;
          };
          Promise2.prototype._length = function() {
            return this._bitField & 65535;
          };
          Promise2.prototype._isFateSealed = function() {
            return (this._bitField & 117506048) !== 0;
          };
          Promise2.prototype._isFollowing = function() {
            return (this._bitField & 67108864) === 67108864;
          };
          Promise2.prototype._setLength = function(len) {
            this._bitField = this._bitField & -65536 | len & 65535;
          };
          Promise2.prototype._setFulfilled = function() {
            this._bitField = this._bitField | 33554432;
            this._fireEvent("promiseFulfilled", this);
          };
          Promise2.prototype._setRejected = function() {
            this._bitField = this._bitField | 16777216;
            this._fireEvent("promiseRejected", this);
          };
          Promise2.prototype._setFollowing = function() {
            this._bitField = this._bitField | 67108864;
            this._fireEvent("promiseResolved", this);
          };
          Promise2.prototype._setIsFinal = function() {
            this._bitField = this._bitField | 4194304;
          };
          Promise2.prototype._isFinal = function() {
            return (this._bitField & 4194304) > 0;
          };
          Promise2.prototype._unsetCancelled = function() {
            this._bitField = this._bitField & ~65536;
          };
          Promise2.prototype._setCancelled = function() {
            this._bitField = this._bitField | 65536;
            this._fireEvent("promiseCancelled", this);
          };
          Promise2.prototype._setWillBeCancelled = function() {
            this._bitField = this._bitField | 8388608;
          };
          Promise2.prototype._setAsyncGuaranteed = function() {
            if (async.hasCustomScheduler())
              return;
            var bitField = this._bitField;
            this._bitField = bitField | (bitField & 536870912) >> 2 ^ 134217728;
          };
          Promise2.prototype._setNoAsyncGuarantee = function() {
            this._bitField = (this._bitField | 536870912) & ~134217728;
          };
          Promise2.prototype._receiverAt = function(index) {
            var ret2 = index === 0 ? this._receiver0 : this[index * 4 - 4 + 3];
            if (ret2 === UNDEFINED_BINDING) {
              return void 0;
            } else if (ret2 === void 0 && this._isBound()) {
              return this._boundValue();
            }
            return ret2;
          };
          Promise2.prototype._promiseAt = function(index) {
            return this[index * 4 - 4 + 2];
          };
          Promise2.prototype._fulfillmentHandlerAt = function(index) {
            return this[index * 4 - 4 + 0];
          };
          Promise2.prototype._rejectionHandlerAt = function(index) {
            return this[index * 4 - 4 + 1];
          };
          Promise2.prototype._boundValue = function() {
          };
          Promise2.prototype._migrateCallback0 = function(follower) {
            var bitField = follower._bitField;
            var fulfill = follower._fulfillmentHandler0;
            var reject = follower._rejectionHandler0;
            var promise = follower._promise0;
            var receiver2 = follower._receiverAt(0);
            if (receiver2 === void 0)
              receiver2 = UNDEFINED_BINDING;
            this._addCallbacks(fulfill, reject, promise, receiver2, null);
          };
          Promise2.prototype._migrateCallbackAt = function(follower, index) {
            var fulfill = follower._fulfillmentHandlerAt(index);
            var reject = follower._rejectionHandlerAt(index);
            var promise = follower._promiseAt(index);
            var receiver2 = follower._receiverAt(index);
            if (receiver2 === void 0)
              receiver2 = UNDEFINED_BINDING;
            this._addCallbacks(fulfill, reject, promise, receiver2, null);
          };
          Promise2.prototype._addCallbacks = function(fulfill, reject, promise, receiver2, context) {
            var index = this._length();
            if (index >= 65535 - 4) {
              index = 0;
              this._setLength(0);
            }
            if (index === 0) {
              this._promise0 = promise;
              this._receiver0 = receiver2;
              if (typeof fulfill === "function") {
                this._fulfillmentHandler0 = util.contextBind(context, fulfill);
              }
              if (typeof reject === "function") {
                this._rejectionHandler0 = util.contextBind(context, reject);
              }
            } else {
              var base = index * 4 - 4;
              this[base + 2] = promise;
              this[base + 3] = receiver2;
              if (typeof fulfill === "function") {
                this[base + 0] = util.contextBind(context, fulfill);
              }
              if (typeof reject === "function") {
                this[base + 1] = util.contextBind(context, reject);
              }
            }
            this._setLength(index + 1);
            return index;
          };
          Promise2.prototype._proxy = function(proxyable, arg) {
            this._addCallbacks(void 0, void 0, arg, proxyable, null);
          };
          Promise2.prototype._resolveCallback = function(value, shouldBind) {
            if ((this._bitField & 117506048) !== 0)
              return;
            if (value === this)
              return this._rejectCallback(makeSelfResolutionError(), false);
            var maybePromise = tryConvertToPromise(value, this);
            if (!(maybePromise instanceof Promise2))
              return this._fulfill(value);
            if (shouldBind)
              this._propagateFrom(maybePromise, 2);
            var promise = maybePromise._target();
            if (promise === this) {
              this._reject(makeSelfResolutionError());
              return;
            }
            var bitField = promise._bitField;
            if ((bitField & 50397184) === 0) {
              var len = this._length();
              if (len > 0)
                promise._migrateCallback0(this);
              for (var i = 1; i < len; ++i) {
                promise._migrateCallbackAt(this, i);
              }
              this._setFollowing();
              this._setLength(0);
              this._setFollowee(maybePromise);
            } else if ((bitField & 33554432) !== 0) {
              this._fulfill(promise._value());
            } else if ((bitField & 16777216) !== 0) {
              this._reject(promise._reason());
            } else {
              var reason = new CancellationError("late cancellation observer");
              promise._attachExtraTrace(reason);
              this._reject(reason);
            }
          };
          Promise2.prototype._rejectCallback = function(reason, synchronous, ignoreNonErrorWarnings) {
            var trace = util.ensureErrorObject(reason);
            var hasStack = trace === reason;
            if (!hasStack && !ignoreNonErrorWarnings && debug.warnings()) {
              var message = "a promise was rejected with a non-error: " + util.classString(reason);
              this._warn(message, true);
            }
            this._attachExtraTrace(trace, synchronous ? hasStack : false);
            this._reject(reason);
          };
          Promise2.prototype._resolveFromExecutor = function(executor) {
            if (executor === INTERNAL)
              return;
            var promise = this;
            this._captureStackTrace();
            this._pushContext();
            var synchronous = true;
            var r = this._execute(executor, function(value) {
              promise._resolveCallback(value);
            }, function(reason) {
              promise._rejectCallback(reason, synchronous);
            });
            synchronous = false;
            this._popContext();
            if (r !== void 0) {
              promise._rejectCallback(r, true);
            }
          };
          Promise2.prototype._settlePromiseFromHandler = function(handler, receiver2, value, promise) {
            var bitField = promise._bitField;
            if ((bitField & 65536) !== 0)
              return;
            promise._pushContext();
            var x;
            if (receiver2 === APPLY) {
              if (!value || typeof value.length !== "number") {
                x = errorObj2;
                x.e = new TypeError2("cannot .spread() a non-array: " + util.classString(value));
              } else {
                x = tryCatch2(handler).apply(this._boundValue(), value);
              }
            } else {
              x = tryCatch2(handler).call(receiver2, value);
            }
            var promiseCreated = promise._popContext();
            bitField = promise._bitField;
            if ((bitField & 65536) !== 0)
              return;
            if (x === NEXT_FILTER) {
              promise._reject(value);
            } else if (x === errorObj2) {
              promise._rejectCallback(x.e, false);
            } else {
              debug.checkForgottenReturns(x, promiseCreated, "", promise, this);
              promise._resolveCallback(x);
            }
          };
          Promise2.prototype._target = function() {
            var ret2 = this;
            while (ret2._isFollowing())
              ret2 = ret2._followee();
            return ret2;
          };
          Promise2.prototype._followee = function() {
            return this._rejectionHandler0;
          };
          Promise2.prototype._setFollowee = function(promise) {
            this._rejectionHandler0 = promise;
          };
          Promise2.prototype._settlePromise = function(promise, handler, receiver2, value) {
            var isPromise = promise instanceof Promise2;
            var bitField = this._bitField;
            var asyncGuaranteed = (bitField & 134217728) !== 0;
            if ((bitField & 65536) !== 0) {
              if (isPromise)
                promise._invokeInternalOnCancel();
              if (receiver2 instanceof PassThroughHandlerContext && receiver2.isFinallyHandler()) {
                receiver2.cancelPromise = promise;
                if (tryCatch2(handler).call(receiver2, value) === errorObj2) {
                  promise._reject(errorObj2.e);
                }
              } else if (handler === reflectHandler2) {
                promise._fulfill(reflectHandler2.call(receiver2));
              } else if (receiver2 instanceof Proxyable) {
                receiver2._promiseCancelled(promise);
              } else if (isPromise || promise instanceof PromiseArray) {
                promise._cancel();
              } else {
                receiver2.cancel();
              }
            } else if (typeof handler === "function") {
              if (!isPromise) {
                handler.call(receiver2, value, promise);
              } else {
                if (asyncGuaranteed)
                  promise._setAsyncGuaranteed();
                this._settlePromiseFromHandler(handler, receiver2, value, promise);
              }
            } else if (receiver2 instanceof Proxyable) {
              if (!receiver2._isResolved()) {
                if ((bitField & 33554432) !== 0) {
                  receiver2._promiseFulfilled(value, promise);
                } else {
                  receiver2._promiseRejected(value, promise);
                }
              }
            } else if (isPromise) {
              if (asyncGuaranteed)
                promise._setAsyncGuaranteed();
              if ((bitField & 33554432) !== 0) {
                promise._fulfill(value);
              } else {
                promise._reject(value);
              }
            }
          };
          Promise2.prototype._settlePromiseLateCancellationObserver = function(ctx) {
            var handler = ctx.handler;
            var promise = ctx.promise;
            var receiver2 = ctx.receiver;
            var value = ctx.value;
            if (typeof handler === "function") {
              if (!(promise instanceof Promise2)) {
                handler.call(receiver2, value, promise);
              } else {
                this._settlePromiseFromHandler(handler, receiver2, value, promise);
              }
            } else if (promise instanceof Promise2) {
              promise._reject(value);
            }
          };
          Promise2.prototype._settlePromiseCtx = function(ctx) {
            this._settlePromise(ctx.promise, ctx.handler, ctx.receiver, ctx.value);
          };
          Promise2.prototype._settlePromise0 = function(handler, value, bitField) {
            var promise = this._promise0;
            var receiver2 = this._receiverAt(0);
            this._promise0 = void 0;
            this._receiver0 = void 0;
            this._settlePromise(promise, handler, receiver2, value);
          };
          Promise2.prototype._clearCallbackDataAtIndex = function(index) {
            var base = index * 4 - 4;
            this[base + 2] = this[base + 3] = this[base + 0] = this[base + 1] = void 0;
          };
          Promise2.prototype._fulfill = function(value) {
            var bitField = this._bitField;
            if ((bitField & 117506048) >>> 16)
              return;
            if (value === this) {
              var err = makeSelfResolutionError();
              this._attachExtraTrace(err);
              return this._reject(err);
            }
            this._setFulfilled();
            this._rejectionHandler0 = value;
            if ((bitField & 65535) > 0) {
              if ((bitField & 134217728) !== 0) {
                this._settlePromises();
              } else {
                async.settlePromises(this);
              }
              this._dereferenceTrace();
            }
          };
          Promise2.prototype._reject = function(reason) {
            var bitField = this._bitField;
            if ((bitField & 117506048) >>> 16)
              return;
            this._setRejected();
            this._fulfillmentHandler0 = reason;
            if (this._isFinal()) {
              return async.fatalError(reason, util.isNode);
            }
            if ((bitField & 65535) > 0) {
              async.settlePromises(this);
            } else {
              this._ensurePossibleRejectionHandled();
            }
          };
          Promise2.prototype._fulfillPromises = function(len, value) {
            for (var i = 1; i < len; i++) {
              var handler = this._fulfillmentHandlerAt(i);
              var promise = this._promiseAt(i);
              var receiver2 = this._receiverAt(i);
              this._clearCallbackDataAtIndex(i);
              this._settlePromise(promise, handler, receiver2, value);
            }
          };
          Promise2.prototype._rejectPromises = function(len, reason) {
            for (var i = 1; i < len; i++) {
              var handler = this._rejectionHandlerAt(i);
              var promise = this._promiseAt(i);
              var receiver2 = this._receiverAt(i);
              this._clearCallbackDataAtIndex(i);
              this._settlePromise(promise, handler, receiver2, reason);
            }
          };
          Promise2.prototype._settlePromises = function() {
            var bitField = this._bitField;
            var len = bitField & 65535;
            if (len > 0) {
              if ((bitField & 16842752) !== 0) {
                var reason = this._fulfillmentHandler0;
                this._settlePromise0(this._rejectionHandler0, reason, bitField);
                this._rejectPromises(len, reason);
              } else {
                var value = this._rejectionHandler0;
                this._settlePromise0(this._fulfillmentHandler0, value, bitField);
                this._fulfillPromises(len, value);
              }
              this._setLength(0);
            }
            this._clearCancellationData();
          };
          Promise2.prototype._settledValue = function() {
            var bitField = this._bitField;
            if ((bitField & 33554432) !== 0) {
              return this._rejectionHandler0;
            } else if ((bitField & 16777216) !== 0) {
              return this._fulfillmentHandler0;
            }
          };
          if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
            es52.defineProperty(Promise2.prototype, Symbol.toStringTag, {
              get: function() {
                return "Object";
              }
            });
          }
          function deferResolve(v) {
            this.promise._resolveCallback(v);
          }
          function deferReject(v) {
            this.promise._rejectCallback(v, false);
          }
          Promise2.defer = Promise2.pending = function() {
            debug.deprecated("Promise.defer", "new Promise");
            var promise = new Promise2(INTERNAL);
            return {
              promise,
              resolve: deferResolve,
              reject: deferReject
            };
          };
          util.notEnumerableProp(
            Promise2,
            "_makeSelfResolutionError",
            makeSelfResolutionError
          );
          _dereq_2("./method")(
            Promise2,
            INTERNAL,
            tryConvertToPromise,
            apiRejection,
            debug
          );
          _dereq_2("./bind")(Promise2, INTERNAL, tryConvertToPromise, debug);
          _dereq_2("./cancel")(Promise2, PromiseArray, apiRejection, debug);
          _dereq_2("./direct_resolve")(Promise2);
          _dereq_2("./synchronous_inspection")(Promise2);
          _dereq_2("./join")(
            Promise2,
            PromiseArray,
            tryConvertToPromise,
            INTERNAL,
            async
          );
          Promise2.Promise = Promise2;
          Promise2.version = "3.7.2";
          _dereq_2("./call_get.js")(Promise2);
          _dereq_2("./generators.js")(Promise2, apiRejection, INTERNAL, tryConvertToPromise, Proxyable, debug);
          _dereq_2("./map.js")(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug);
          _dereq_2("./nodeify.js")(Promise2);
          _dereq_2("./promisify.js")(Promise2, INTERNAL);
          _dereq_2("./props.js")(Promise2, PromiseArray, tryConvertToPromise, apiRejection);
          _dereq_2("./race.js")(Promise2, INTERNAL, tryConvertToPromise, apiRejection);
          _dereq_2("./reduce.js")(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug);
          _dereq_2("./settle.js")(Promise2, PromiseArray, debug);
          _dereq_2("./some.js")(Promise2, PromiseArray, apiRejection);
          _dereq_2("./timers.js")(Promise2, INTERNAL, debug);
          _dereq_2("./using.js")(Promise2, apiRejection, tryConvertToPromise, createContext, INTERNAL, debug);
          _dereq_2("./any.js")(Promise2);
          _dereq_2("./each.js")(Promise2, INTERNAL);
          _dereq_2("./filter.js")(Promise2, INTERNAL);
          util.toFastProperties(Promise2);
          util.toFastProperties(Promise2.prototype);
          function fillTypes(value) {
            var p = new Promise2(INTERNAL);
            p._fulfillmentHandler0 = value;
            p._rejectionHandler0 = value;
            p._promise0 = value;
            p._receiver0 = value;
          }
          fillTypes({ a: 1 });
          fillTypes({ b: 2 });
          fillTypes({ c: 3 });
          fillTypes(1);
          fillTypes(function() {
          });
          fillTypes(void 0);
          fillTypes(false);
          fillTypes(new Promise2(INTERNAL));
          debug.setBounds(Async.firstLineError, util.lastLineError);
          return Promise2;
        };
      }, { "./any.js": 1, "./async": 2, "./bind": 3, "./call_get.js": 5, "./cancel": 6, "./catch_filter": 7, "./context": 8, "./debuggability": 9, "./direct_resolve": 10, "./each.js": 11, "./errors": 12, "./es5": 13, "./filter.js": 14, "./finally": 15, "./generators.js": 16, "./join": 17, "./map.js": 18, "./method": 19, "./nodeback": 20, "./nodeify.js": 21, "./promise_array": 23, "./promisify.js": 24, "./props.js": 25, "./race.js": 27, "./reduce.js": 28, "./settle.js": 30, "./some.js": 31, "./synchronous_inspection": 32, "./thenables": 33, "./timers.js": 34, "./using.js": 35, "./util": 36, "async_hooks": void 0 }], 23: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, INTERNAL, tryConvertToPromise, apiRejection, Proxyable) {
          var util = _dereq_2("./util");
          var isArray = util.isArray;
          function toResolutionValue(val) {
            switch (val) {
              case -2:
                return [];
              case -3:
                return {};
              case -6:
                return /* @__PURE__ */ new Map();
            }
          }
          function PromiseArray(values) {
            var promise = this._promise = new Promise2(INTERNAL);
            if (values instanceof Promise2) {
              promise._propagateFrom(values, 3);
              values.suppressUnhandledRejections();
            }
            promise._setOnCancel(this);
            this._values = values;
            this._length = 0;
            this._totalResolved = 0;
            this._init(void 0, -2);
          }
          util.inherits(PromiseArray, Proxyable);
          PromiseArray.prototype.length = function() {
            return this._length;
          };
          PromiseArray.prototype.promise = function() {
            return this._promise;
          };
          PromiseArray.prototype._init = function init(_, resolveValueIfEmpty) {
            var values = tryConvertToPromise(this._values, this._promise);
            if (values instanceof Promise2) {
              values = values._target();
              var bitField = values._bitField;
              ;
              this._values = values;
              if ((bitField & 50397184) === 0) {
                this._promise._setAsyncGuaranteed();
                return values._then(
                  init,
                  this._reject,
                  void 0,
                  this,
                  resolveValueIfEmpty
                );
              } else if ((bitField & 33554432) !== 0) {
                values = values._value();
              } else if ((bitField & 16777216) !== 0) {
                return this._reject(values._reason());
              } else {
                return this._cancel();
              }
            }
            values = util.asArray(values);
            if (values === null) {
              var err = apiRejection(
                "expecting an array or an iterable object but got " + util.classString(values)
              ).reason();
              this._promise._rejectCallback(err, false);
              return;
            }
            if (values.length === 0) {
              if (resolveValueIfEmpty === -5) {
                this._resolveEmptyArray();
              } else {
                this._resolve(toResolutionValue(resolveValueIfEmpty));
              }
              return;
            }
            this._iterate(values);
          };
          PromiseArray.prototype._iterate = function(values) {
            var len = this.getActualLength(values.length);
            this._length = len;
            this._values = this.shouldCopyValues() ? new Array(len) : this._values;
            var result = this._promise;
            var isResolved = false;
            var bitField = null;
            for (var i = 0; i < len; ++i) {
              var maybePromise = tryConvertToPromise(values[i], result);
              if (maybePromise instanceof Promise2) {
                maybePromise = maybePromise._target();
                bitField = maybePromise._bitField;
              } else {
                bitField = null;
              }
              if (isResolved) {
                if (bitField !== null) {
                  maybePromise.suppressUnhandledRejections();
                }
              } else if (bitField !== null) {
                if ((bitField & 50397184) === 0) {
                  maybePromise._proxy(this, i);
                  this._values[i] = maybePromise;
                } else if ((bitField & 33554432) !== 0) {
                  isResolved = this._promiseFulfilled(maybePromise._value(), i);
                } else if ((bitField & 16777216) !== 0) {
                  isResolved = this._promiseRejected(maybePromise._reason(), i);
                } else {
                  isResolved = this._promiseCancelled(i);
                }
              } else {
                isResolved = this._promiseFulfilled(maybePromise, i);
              }
            }
            if (!isResolved)
              result._setAsyncGuaranteed();
          };
          PromiseArray.prototype._isResolved = function() {
            return this._values === null;
          };
          PromiseArray.prototype._resolve = function(value) {
            this._values = null;
            this._promise._fulfill(value);
          };
          PromiseArray.prototype._cancel = function() {
            if (this._isResolved() || !this._promise._isCancellable())
              return;
            this._values = null;
            this._promise._cancel();
          };
          PromiseArray.prototype._reject = function(reason) {
            this._values = null;
            this._promise._rejectCallback(reason, false);
          };
          PromiseArray.prototype._promiseFulfilled = function(value, index) {
            this._values[index] = value;
            var totalResolved = ++this._totalResolved;
            if (totalResolved >= this._length) {
              this._resolve(this._values);
              return true;
            }
            return false;
          };
          PromiseArray.prototype._promiseCancelled = function() {
            this._cancel();
            return true;
          };
          PromiseArray.prototype._promiseRejected = function(reason) {
            this._totalResolved++;
            this._reject(reason);
            return true;
          };
          PromiseArray.prototype._resultCancelled = function() {
            if (this._isResolved())
              return;
            var values = this._values;
            this._cancel();
            if (values instanceof Promise2) {
              values.cancel();
            } else {
              for (var i = 0; i < values.length; ++i) {
                if (values[i] instanceof Promise2) {
                  values[i].cancel();
                }
              }
            }
          };
          PromiseArray.prototype.shouldCopyValues = function() {
            return true;
          };
          PromiseArray.prototype.getActualLength = function(len) {
            return len;
          };
          return PromiseArray;
        };
      }, { "./util": 36 }], 24: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, INTERNAL) {
          var THIS = {};
          var util = _dereq_2("./util");
          var nodebackForPromise = _dereq_2("./nodeback");
          var withAppended2 = util.withAppended;
          var maybeWrapAsError2 = util.maybeWrapAsError;
          var canEvaluate2 = util.canEvaluate;
          var TypeError2 = _dereq_2("./errors").TypeError;
          var defaultSuffix = "Async";
          var defaultPromisified = { __isPromisified__: true };
          var noCopyProps = [
            "arity",
            "length",
            "name",
            "arguments",
            "caller",
            "callee",
            "prototype",
            "__isPromisified__"
          ];
          var noCopyPropsPattern = new RegExp("^(?:" + noCopyProps.join("|") + ")$");
          var defaultFilter = function(name) {
            return util.isIdentifier(name) && name.charAt(0) !== "_" && name !== "constructor";
          };
          function propsFilter(key) {
            return !noCopyPropsPattern.test(key);
          }
          function isPromisified(fn) {
            try {
              return fn.__isPromisified__ === true;
            } catch (e) {
              return false;
            }
          }
          function hasPromisified(obj2, key, suffix) {
            var val = util.getDataPropertyOrDefault(
              obj2,
              key + suffix,
              defaultPromisified
            );
            return val ? isPromisified(val) : false;
          }
          function checkValid(ret2, suffix, suffixRegexp) {
            for (var i = 0; i < ret2.length; i += 2) {
              var key = ret2[i];
              if (suffixRegexp.test(key)) {
                var keyWithoutAsyncSuffix = key.replace(suffixRegexp, "");
                for (var j = 0; j < ret2.length; j += 2) {
                  if (ret2[j] === keyWithoutAsyncSuffix) {
                    throw new TypeError2("Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/MqrFmX\n".replace("%s", suffix));
                  }
                }
              }
            }
          }
          function promisifiableMethods(obj2, suffix, suffixRegexp, filter) {
            var keys = util.inheritedDataKeys(obj2);
            var ret2 = [];
            for (var i = 0; i < keys.length; ++i) {
              var key = keys[i];
              var value = obj2[key];
              var passesDefaultFilter = filter === defaultFilter ? true : defaultFilter(key, value, obj2);
              if (typeof value === "function" && !isPromisified(value) && !hasPromisified(obj2, key, suffix) && filter(key, value, obj2, passesDefaultFilter)) {
                ret2.push(key, value);
              }
            }
            checkValid(ret2, suffix, suffixRegexp);
            return ret2;
          }
          var escapeIdentRegex = function(str) {
            return str.replace(/([$])/, "\\$");
          };
          var makeNodePromisifiedEval;
          if (false) {
            var switchCaseArgumentOrder = function(likelyArgumentCount) {
              var ret2 = [likelyArgumentCount];
              var min = Math.max(0, likelyArgumentCount - 1 - 3);
              for (var i = likelyArgumentCount - 1; i >= min; --i) {
                ret2.push(i);
              }
              for (var i = likelyArgumentCount + 1; i <= 3; ++i) {
                ret2.push(i);
              }
              return ret2;
            };
            var argumentSequence = function(argumentCount) {
              return util.filledRange(argumentCount, "_arg", "");
            };
            var parameterDeclaration = function(parameterCount2) {
              return util.filledRange(
                Math.max(parameterCount2, 3),
                "_arg",
                ""
              );
            };
            var parameterCount = function(fn) {
              if (typeof fn.length === "number") {
                return Math.max(Math.min(fn.length, 1023 + 1), 0);
              }
              return 0;
            };
            makeNodePromisifiedEval = function(callback, receiver2, originalName, fn, _, multiArgs) {
              var newParameterCount = Math.max(0, parameterCount(fn) - 1);
              var argumentOrder = switchCaseArgumentOrder(newParameterCount);
              var shouldProxyThis = typeof callback === "string" || receiver2 === THIS;
              function generateCallForArgumentCount(count) {
                var args = argumentSequence(count).join(", ");
                var comma = count > 0 ? ", " : "";
                var ret2;
                if (shouldProxyThis) {
                  ret2 = "ret = callback.call(this, {{args}}, nodeback); break;\n";
                } else {
                  ret2 = receiver2 === void 0 ? "ret = callback({{args}}, nodeback); break;\n" : "ret = callback.call(receiver, {{args}}, nodeback); break;\n";
                }
                return ret2.replace("{{args}}", args).replace(", ", comma);
              }
              function generateArgumentSwitchCase() {
                var ret2 = "";
                for (var i = 0; i < argumentOrder.length; ++i) {
                  ret2 += "case " + argumentOrder[i] + ":" + generateCallForArgumentCount(argumentOrder[i]);
                }
                ret2 += "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = nodeback;                                              \n            [CodeForCall]                                                    \n            break;                                                           \n        ".replace("[CodeForCall]", shouldProxyThis ? "ret = callback.apply(this, args);\n" : "ret = callback.apply(receiver, args);\n");
                return ret2;
              }
              var getFunctionCode = typeof callback === "string" ? "this != null ? this['" + callback + "'] : fn" : "fn";
              var body = "'use strict';                                                \n        var ret = function (Parameters) {                                    \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            var nodeback = nodebackForPromise(promise, " + multiArgs + ");   \n            var ret;                                                         \n            var callback = tryCatch([GetFunctionCode]);                      \n            switch(len) {                                                    \n                [CodeForSwitchCase]                                          \n            }                                                                \n            if (ret === errorObj) {                                          \n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n            }                                                                \n            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();     \n            return promise;                                                  \n        };                                                                   \n        notEnumerableProp(ret, '__isPromisified__', true);                   \n        return ret;                                                          \n    ".replace("[CodeForSwitchCase]", generateArgumentSwitchCase()).replace("[GetFunctionCode]", getFunctionCode);
              body = body.replace("Parameters", parameterDeclaration(newParameterCount));
              return new Function(
                "Promise",
                "fn",
                "receiver",
                "withAppended",
                "maybeWrapAsError",
                "nodebackForPromise",
                "tryCatch",
                "errorObj",
                "notEnumerableProp",
                "INTERNAL",
                body
              )(
                Promise2,
                fn,
                receiver2,
                withAppended2,
                maybeWrapAsError2,
                nodebackForPromise,
                util.tryCatch,
                util.errorObj,
                util.notEnumerableProp,
                INTERNAL
              );
            };
          }
          function makeNodePromisifiedClosure(callback, receiver2, _, fn, __, multiArgs) {
            var defaultThis = function() {
              return this;
            }();
            var method = callback;
            if (typeof method === "string") {
              callback = fn;
            }
            function promisified() {
              var _receiver = receiver2;
              if (receiver2 === THIS)
                _receiver = this;
              var promise = new Promise2(INTERNAL);
              promise._captureStackTrace();
              var cb = typeof method === "string" && this !== defaultThis ? this[method] : callback;
              var fn2 = nodebackForPromise(promise, multiArgs);
              try {
                cb.apply(_receiver, withAppended2(arguments, fn2));
              } catch (e) {
                promise._rejectCallback(maybeWrapAsError2(e), true, true);
              }
              if (!promise._isFateSealed())
                promise._setAsyncGuaranteed();
              return promise;
            }
            util.notEnumerableProp(promisified, "__isPromisified__", true);
            return promisified;
          }
          var makeNodePromisified = canEvaluate2 ? makeNodePromisifiedEval : makeNodePromisifiedClosure;
          function promisifyAll(obj2, suffix, filter, promisifier, multiArgs) {
            var suffixRegexp = new RegExp(escapeIdentRegex(suffix) + "$");
            var methods = promisifiableMethods(obj2, suffix, suffixRegexp, filter);
            for (var i = 0, len = methods.length; i < len; i += 2) {
              var key = methods[i];
              var fn = methods[i + 1];
              var promisifiedKey = key + suffix;
              if (promisifier === makeNodePromisified) {
                obj2[promisifiedKey] = makeNodePromisified(key, THIS, key, fn, suffix, multiArgs);
              } else {
                var promisified = promisifier(fn, function() {
                  return makeNodePromisified(
                    key,
                    THIS,
                    key,
                    fn,
                    suffix,
                    multiArgs
                  );
                });
                util.notEnumerableProp(promisified, "__isPromisified__", true);
                obj2[promisifiedKey] = promisified;
              }
            }
            util.toFastProperties(obj2);
            return obj2;
          }
          function promisify(callback, receiver2, multiArgs) {
            return makeNodePromisified(
              callback,
              receiver2,
              void 0,
              callback,
              null,
              multiArgs
            );
          }
          Promise2.promisify = function(fn, options) {
            if (typeof fn !== "function") {
              throw new TypeError2("expecting a function but got " + util.classString(fn));
            }
            if (isPromisified(fn)) {
              return fn;
            }
            options = Object(options);
            var receiver2 = options.context === void 0 ? THIS : options.context;
            var multiArgs = !!options.multiArgs;
            var ret2 = promisify(fn, receiver2, multiArgs);
            util.copyDescriptors(fn, ret2, propsFilter);
            return ret2;
          };
          Promise2.promisifyAll = function(target, options) {
            if (typeof target !== "function" && typeof target !== "object") {
              throw new TypeError2("the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/MqrFmX\n");
            }
            options = Object(options);
            var multiArgs = !!options.multiArgs;
            var suffix = options.suffix;
            if (typeof suffix !== "string")
              suffix = defaultSuffix;
            var filter = options.filter;
            if (typeof filter !== "function")
              filter = defaultFilter;
            var promisifier = options.promisifier;
            if (typeof promisifier !== "function")
              promisifier = makeNodePromisified;
            if (!util.isIdentifier(suffix)) {
              throw new RangeError("suffix must be a valid identifier\n\n    See http://goo.gl/MqrFmX\n");
            }
            var keys = util.inheritedDataKeys(target);
            for (var i = 0; i < keys.length; ++i) {
              var value = target[keys[i]];
              if (keys[i] !== "constructor" && util.isClass(value)) {
                promisifyAll(
                  value.prototype,
                  suffix,
                  filter,
                  promisifier,
                  multiArgs
                );
                promisifyAll(value, suffix, filter, promisifier, multiArgs);
              }
            }
            return promisifyAll(target, suffix, filter, promisifier, multiArgs);
          };
        };
      }, { "./errors": 12, "./nodeback": 20, "./util": 36 }], 25: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, PromiseArray, tryConvertToPromise, apiRejection) {
          var util = _dereq_2("./util");
          var isObject2 = util.isObject;
          var es52 = _dereq_2("./es5");
          var Es6Map;
          if (typeof Map === "function")
            Es6Map = Map;
          var mapToEntries = function() {
            var index = 0;
            var size = 0;
            function extractEntry(value, key) {
              this[index] = value;
              this[index + size] = key;
              index++;
            }
            return function mapToEntries2(map) {
              size = map.size;
              index = 0;
              var ret2 = new Array(map.size * 2);
              map.forEach(extractEntry, ret2);
              return ret2;
            };
          }();
          var entriesToMap = function(entries) {
            var ret2 = new Es6Map();
            var length = entries.length / 2 | 0;
            for (var i = 0; i < length; ++i) {
              var key = entries[length + i];
              var value = entries[i];
              ret2.set(key, value);
            }
            return ret2;
          };
          function PropertiesPromiseArray(obj2) {
            var isMap = false;
            var entries;
            if (Es6Map !== void 0 && obj2 instanceof Es6Map) {
              entries = mapToEntries(obj2);
              isMap = true;
            } else {
              var keys = es52.keys(obj2);
              var len = keys.length;
              entries = new Array(len * 2);
              for (var i = 0; i < len; ++i) {
                var key = keys[i];
                entries[i] = obj2[key];
                entries[i + len] = key;
              }
            }
            this.constructor$(entries);
            this._isMap = isMap;
            this._init$(void 0, isMap ? -6 : -3);
          }
          util.inherits(PropertiesPromiseArray, PromiseArray);
          PropertiesPromiseArray.prototype._init = function() {
          };
          PropertiesPromiseArray.prototype._promiseFulfilled = function(value, index) {
            this._values[index] = value;
            var totalResolved = ++this._totalResolved;
            if (totalResolved >= this._length) {
              var val;
              if (this._isMap) {
                val = entriesToMap(this._values);
              } else {
                val = {};
                var keyOffset = this.length();
                for (var i = 0, len = this.length(); i < len; ++i) {
                  val[this._values[i + keyOffset]] = this._values[i];
                }
              }
              this._resolve(val);
              return true;
            }
            return false;
          };
          PropertiesPromiseArray.prototype.shouldCopyValues = function() {
            return false;
          };
          PropertiesPromiseArray.prototype.getActualLength = function(len) {
            return len >> 1;
          };
          function props(promises) {
            var ret2;
            var castValue = tryConvertToPromise(promises);
            if (!isObject2(castValue)) {
              return apiRejection("cannot await properties of a non-object\n\n    See http://goo.gl/MqrFmX\n");
            } else if (castValue instanceof Promise2) {
              ret2 = castValue._then(
                Promise2.props,
                void 0,
                void 0,
                void 0,
                void 0
              );
            } else {
              ret2 = new PropertiesPromiseArray(castValue).promise();
            }
            if (castValue instanceof Promise2) {
              ret2._propagateFrom(castValue, 2);
            }
            return ret2;
          }
          Promise2.prototype.props = function() {
            return props(this);
          };
          Promise2.props = function(promises) {
            return props(promises);
          };
        };
      }, { "./es5": 13, "./util": 36 }], 26: [function(_dereq_2, module2, exports2) {
        "use strict";
        function arrayMove(src, srcIndex, dst, dstIndex, len) {
          for (var j = 0; j < len; ++j) {
            dst[j + dstIndex] = src[j + srcIndex];
            src[j + srcIndex] = void 0;
          }
        }
        function Queue(capacity) {
          this._capacity = capacity;
          this._length = 0;
          this._front = 0;
        }
        Queue.prototype._willBeOverCapacity = function(size) {
          return this._capacity < size;
        };
        Queue.prototype._pushOne = function(arg) {
          var length = this.length();
          this._checkCapacity(length + 1);
          var i = this._front + length & this._capacity - 1;
          this[i] = arg;
          this._length = length + 1;
        };
        Queue.prototype.push = function(fn, receiver2, arg) {
          var length = this.length() + 3;
          if (this._willBeOverCapacity(length)) {
            this._pushOne(fn);
            this._pushOne(receiver2);
            this._pushOne(arg);
            return;
          }
          var j = this._front + length - 3;
          this._checkCapacity(length);
          var wrapMask = this._capacity - 1;
          this[j + 0 & wrapMask] = fn;
          this[j + 1 & wrapMask] = receiver2;
          this[j + 2 & wrapMask] = arg;
          this._length = length;
        };
        Queue.prototype.shift = function() {
          var front = this._front, ret2 = this[front];
          this[front] = void 0;
          this._front = front + 1 & this._capacity - 1;
          this._length--;
          return ret2;
        };
        Queue.prototype.length = function() {
          return this._length;
        };
        Queue.prototype._checkCapacity = function(size) {
          if (this._capacity < size) {
            this._resizeTo(this._capacity << 1);
          }
        };
        Queue.prototype._resizeTo = function(capacity) {
          var oldCapacity = this._capacity;
          this._capacity = capacity;
          var front = this._front;
          var length = this._length;
          var moveItemsCount = front + length & oldCapacity - 1;
          arrayMove(this, 0, this, oldCapacity, moveItemsCount);
        };
        module2.exports = Queue;
      }, {}], 27: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, INTERNAL, tryConvertToPromise, apiRejection) {
          var util = _dereq_2("./util");
          var raceLater = function(promise) {
            return promise.then(function(array) {
              return race(array, promise);
            });
          };
          function race(promises, parent) {
            var maybePromise = tryConvertToPromise(promises);
            if (maybePromise instanceof Promise2) {
              return raceLater(maybePromise);
            } else {
              promises = util.asArray(promises);
              if (promises === null)
                return apiRejection("expecting an array or an iterable object but got " + util.classString(promises));
            }
            var ret2 = new Promise2(INTERNAL);
            if (parent !== void 0) {
              ret2._propagateFrom(parent, 3);
            }
            var fulfill = ret2._fulfill;
            var reject = ret2._reject;
            for (var i = 0, len = promises.length; i < len; ++i) {
              var val = promises[i];
              if (val === void 0 && !(i in promises)) {
                continue;
              }
              Promise2.cast(val)._then(fulfill, reject, void 0, ret2, null);
            }
            return ret2;
          }
          Promise2.race = function(promises) {
            return race(promises, void 0);
          };
          Promise2.prototype.race = function() {
            return race(this, void 0);
          };
        };
      }, { "./util": 36 }], 28: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug) {
          var util = _dereq_2("./util");
          var tryCatch2 = util.tryCatch;
          function ReductionPromiseArray(promises, fn, initialValue, _each) {
            this.constructor$(promises);
            var context = Promise2._getContext();
            this._fn = util.contextBind(context, fn);
            if (initialValue !== void 0) {
              initialValue = Promise2.resolve(initialValue);
              initialValue._attachCancellationCallback(this);
            }
            this._initialValue = initialValue;
            this._currentCancellable = null;
            if (_each === INTERNAL) {
              this._eachValues = Array(this._length);
            } else if (_each === 0) {
              this._eachValues = null;
            } else {
              this._eachValues = void 0;
            }
            this._promise._captureStackTrace();
            this._init$(void 0, -5);
          }
          util.inherits(ReductionPromiseArray, PromiseArray);
          ReductionPromiseArray.prototype._gotAccum = function(accum) {
            if (this._eachValues !== void 0 && this._eachValues !== null && accum !== INTERNAL) {
              this._eachValues.push(accum);
            }
          };
          ReductionPromiseArray.prototype._eachComplete = function(value) {
            if (this._eachValues !== null) {
              this._eachValues.push(value);
            }
            return this._eachValues;
          };
          ReductionPromiseArray.prototype._init = function() {
          };
          ReductionPromiseArray.prototype._resolveEmptyArray = function() {
            this._resolve(this._eachValues !== void 0 ? this._eachValues : this._initialValue);
          };
          ReductionPromiseArray.prototype.shouldCopyValues = function() {
            return false;
          };
          ReductionPromiseArray.prototype._resolve = function(value) {
            this._promise._resolveCallback(value);
            this._values = null;
          };
          ReductionPromiseArray.prototype._resultCancelled = function(sender) {
            if (sender === this._initialValue)
              return this._cancel();
            if (this._isResolved())
              return;
            this._resultCancelled$();
            if (this._currentCancellable instanceof Promise2) {
              this._currentCancellable.cancel();
            }
            if (this._initialValue instanceof Promise2) {
              this._initialValue.cancel();
            }
          };
          ReductionPromiseArray.prototype._iterate = function(values) {
            this._values = values;
            var value;
            var i;
            var length = values.length;
            if (this._initialValue !== void 0) {
              value = this._initialValue;
              i = 0;
            } else {
              value = Promise2.resolve(values[0]);
              i = 1;
            }
            this._currentCancellable = value;
            for (var j = i; j < length; ++j) {
              var maybePromise = values[j];
              if (maybePromise instanceof Promise2) {
                maybePromise.suppressUnhandledRejections();
              }
            }
            if (!value.isRejected()) {
              for (; i < length; ++i) {
                var ctx = {
                  accum: null,
                  value: values[i],
                  index: i,
                  length,
                  array: this
                };
                value = value._then(gotAccum, void 0, void 0, ctx, void 0);
                if ((i & 127) === 0) {
                  value._setNoAsyncGuarantee();
                }
              }
            }
            if (this._eachValues !== void 0) {
              value = value._then(this._eachComplete, void 0, void 0, this, void 0);
            }
            value._then(completed, completed, void 0, value, this);
          };
          Promise2.prototype.reduce = function(fn, initialValue) {
            return reduce(this, fn, initialValue, null);
          };
          Promise2.reduce = function(promises, fn, initialValue, _each) {
            return reduce(promises, fn, initialValue, _each);
          };
          function completed(valueOrReason, array) {
            if (this.isFulfilled()) {
              array._resolve(valueOrReason);
            } else {
              array._reject(valueOrReason);
            }
          }
          function reduce(promises, fn, initialValue, _each) {
            if (typeof fn !== "function") {
              return apiRejection("expecting a function but got " + util.classString(fn));
            }
            var array = new ReductionPromiseArray(promises, fn, initialValue, _each);
            return array.promise();
          }
          function gotAccum(accum) {
            this.accum = accum;
            this.array._gotAccum(accum);
            var value = tryConvertToPromise(this.value, this.array._promise);
            if (value instanceof Promise2) {
              this.array._currentCancellable = value;
              return value._then(gotValue, void 0, void 0, this, void 0);
            } else {
              return gotValue.call(this, value);
            }
          }
          function gotValue(value) {
            var array = this.array;
            var promise = array._promise;
            var fn = tryCatch2(array._fn);
            promise._pushContext();
            var ret2;
            if (array._eachValues !== void 0) {
              ret2 = fn.call(promise._boundValue(), value, this.index, this.length);
            } else {
              ret2 = fn.call(
                promise._boundValue(),
                this.accum,
                value,
                this.index,
                this.length
              );
            }
            if (ret2 instanceof Promise2) {
              array._currentCancellable = ret2;
            }
            var promiseCreated = promise._popContext();
            debug.checkForgottenReturns(
              ret2,
              promiseCreated,
              array._eachValues !== void 0 ? "Promise.each" : "Promise.reduce",
              promise
            );
            return ret2;
          }
        };
      }, { "./util": 36 }], 29: [function(_dereq_2, module2, exports2) {
        "use strict";
        var util = _dereq_2("./util");
        var schedule;
        var noAsyncScheduler = function() {
          throw new Error("No async scheduler available\n\n    See http://goo.gl/MqrFmX\n");
        };
        var NativePromise = util.getNativePromise();
        if (util.isNode && typeof MutationObserver === "undefined") {
          var GlobalSetImmediate = global.setImmediate;
          var ProcessNextTick = process.nextTick;
          schedule = util.isRecentNode ? function(fn) {
            GlobalSetImmediate.call(global, fn);
          } : function(fn) {
            ProcessNextTick.call(process, fn);
          };
        } else if (typeof NativePromise === "function" && typeof NativePromise.resolve === "function") {
          var nativePromise = NativePromise.resolve();
          schedule = function(fn) {
            nativePromise.then(fn);
          };
        } else if (typeof MutationObserver !== "undefined" && !(typeof window !== "undefined" && window.navigator && (window.navigator.standalone || window.cordova)) && "classList" in document.documentElement) {
          schedule = function() {
            var div = document.createElement("div");
            var opts = { attributes: true };
            var toggleScheduled = false;
            var div2 = document.createElement("div");
            var o2 = new MutationObserver(function() {
              div.classList.toggle("foo");
              toggleScheduled = false;
            });
            o2.observe(div2, opts);
            var scheduleToggle = function() {
              if (toggleScheduled)
                return;
              toggleScheduled = true;
              div2.classList.toggle("foo");
            };
            return function schedule2(fn) {
              var o = new MutationObserver(function() {
                o.disconnect();
                fn();
              });
              o.observe(div, opts);
              scheduleToggle();
            };
          }();
        } else if (typeof setImmediate !== "undefined") {
          schedule = function(fn) {
            setImmediate(fn);
          };
        } else if (typeof setTimeout !== "undefined") {
          schedule = function(fn) {
            setTimeout(fn, 0);
          };
        } else {
          schedule = noAsyncScheduler;
        }
        module2.exports = schedule;
      }, { "./util": 36 }], 30: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, PromiseArray, debug) {
          var PromiseInspection = Promise2.PromiseInspection;
          var util = _dereq_2("./util");
          function SettledPromiseArray(values) {
            this.constructor$(values);
          }
          util.inherits(SettledPromiseArray, PromiseArray);
          SettledPromiseArray.prototype._promiseResolved = function(index, inspection) {
            this._values[index] = inspection;
            var totalResolved = ++this._totalResolved;
            if (totalResolved >= this._length) {
              this._resolve(this._values);
              return true;
            }
            return false;
          };
          SettledPromiseArray.prototype._promiseFulfilled = function(value, index) {
            var ret2 = new PromiseInspection();
            ret2._bitField = 33554432;
            ret2._settledValueField = value;
            return this._promiseResolved(index, ret2);
          };
          SettledPromiseArray.prototype._promiseRejected = function(reason, index) {
            var ret2 = new PromiseInspection();
            ret2._bitField = 16777216;
            ret2._settledValueField = reason;
            return this._promiseResolved(index, ret2);
          };
          Promise2.settle = function(promises) {
            debug.deprecated(".settle()", ".reflect()");
            return new SettledPromiseArray(promises).promise();
          };
          Promise2.allSettled = function(promises) {
            return new SettledPromiseArray(promises).promise();
          };
          Promise2.prototype.settle = function() {
            return Promise2.settle(this);
          };
        };
      }, { "./util": 36 }], 31: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, PromiseArray, apiRejection) {
          var util = _dereq_2("./util");
          var RangeError2 = _dereq_2("./errors").RangeError;
          var AggregateError = _dereq_2("./errors").AggregateError;
          var isArray = util.isArray;
          var CANCELLATION = {};
          function SomePromiseArray(values) {
            this.constructor$(values);
            this._howMany = 0;
            this._unwrap = false;
            this._initialized = false;
          }
          util.inherits(SomePromiseArray, PromiseArray);
          SomePromiseArray.prototype._init = function() {
            if (!this._initialized) {
              return;
            }
            if (this._howMany === 0) {
              this._resolve([]);
              return;
            }
            this._init$(void 0, -5);
            var isArrayResolved = isArray(this._values);
            if (!this._isResolved() && isArrayResolved && this._howMany > this._canPossiblyFulfill()) {
              this._reject(this._getRangeError(this.length()));
            }
          };
          SomePromiseArray.prototype.init = function() {
            this._initialized = true;
            this._init();
          };
          SomePromiseArray.prototype.setUnwrap = function() {
            this._unwrap = true;
          };
          SomePromiseArray.prototype.howMany = function() {
            return this._howMany;
          };
          SomePromiseArray.prototype.setHowMany = function(count) {
            this._howMany = count;
          };
          SomePromiseArray.prototype._promiseFulfilled = function(value) {
            this._addFulfilled(value);
            if (this._fulfilled() === this.howMany()) {
              this._values.length = this.howMany();
              if (this.howMany() === 1 && this._unwrap) {
                this._resolve(this._values[0]);
              } else {
                this._resolve(this._values);
              }
              return true;
            }
            return false;
          };
          SomePromiseArray.prototype._promiseRejected = function(reason) {
            this._addRejected(reason);
            return this._checkOutcome();
          };
          SomePromiseArray.prototype._promiseCancelled = function() {
            if (this._values instanceof Promise2 || this._values == null) {
              return this._cancel();
            }
            this._addRejected(CANCELLATION);
            return this._checkOutcome();
          };
          SomePromiseArray.prototype._checkOutcome = function() {
            if (this.howMany() > this._canPossiblyFulfill()) {
              var e = new AggregateError();
              for (var i = this.length(); i < this._values.length; ++i) {
                if (this._values[i] !== CANCELLATION) {
                  e.push(this._values[i]);
                }
              }
              if (e.length > 0) {
                this._reject(e);
              } else {
                this._cancel();
              }
              return true;
            }
            return false;
          };
          SomePromiseArray.prototype._fulfilled = function() {
            return this._totalResolved;
          };
          SomePromiseArray.prototype._rejected = function() {
            return this._values.length - this.length();
          };
          SomePromiseArray.prototype._addRejected = function(reason) {
            this._values.push(reason);
          };
          SomePromiseArray.prototype._addFulfilled = function(value) {
            this._values[this._totalResolved++] = value;
          };
          SomePromiseArray.prototype._canPossiblyFulfill = function() {
            return this.length() - this._rejected();
          };
          SomePromiseArray.prototype._getRangeError = function(count) {
            var message = "Input array must contain at least " + this._howMany + " items but contains only " + count + " items";
            return new RangeError2(message);
          };
          SomePromiseArray.prototype._resolveEmptyArray = function() {
            this._reject(this._getRangeError(0));
          };
          function some(promises, howMany) {
            if ((howMany | 0) !== howMany || howMany < 0) {
              return apiRejection("expecting a positive integer\n\n    See http://goo.gl/MqrFmX\n");
            }
            var ret2 = new SomePromiseArray(promises);
            var promise = ret2.promise();
            ret2.setHowMany(howMany);
            ret2.init();
            return promise;
          }
          Promise2.some = function(promises, howMany) {
            return some(promises, howMany);
          };
          Promise2.prototype.some = function(howMany) {
            return some(this, howMany);
          };
          Promise2._SomePromiseArray = SomePromiseArray;
        };
      }, { "./errors": 12, "./util": 36 }], 32: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2) {
          function PromiseInspection(promise) {
            if (promise !== void 0) {
              promise = promise._target();
              this._bitField = promise._bitField;
              this._settledValueField = promise._isFateSealed() ? promise._settledValue() : void 0;
            } else {
              this._bitField = 0;
              this._settledValueField = void 0;
            }
          }
          PromiseInspection.prototype._settledValue = function() {
            return this._settledValueField;
          };
          var value = PromiseInspection.prototype.value = function() {
            if (!this.isFulfilled()) {
              throw new TypeError("cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/MqrFmX\n");
            }
            return this._settledValue();
          };
          var reason = PromiseInspection.prototype.error = PromiseInspection.prototype.reason = function() {
            if (!this.isRejected()) {
              throw new TypeError("cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/MqrFmX\n");
            }
            return this._settledValue();
          };
          var isFulfilled = PromiseInspection.prototype.isFulfilled = function() {
            return (this._bitField & 33554432) !== 0;
          };
          var isRejected = PromiseInspection.prototype.isRejected = function() {
            return (this._bitField & 16777216) !== 0;
          };
          var isPending = PromiseInspection.prototype.isPending = function() {
            return (this._bitField & 50397184) === 0;
          };
          var isResolved = PromiseInspection.prototype.isResolved = function() {
            return (this._bitField & 50331648) !== 0;
          };
          PromiseInspection.prototype.isCancelled = function() {
            return (this._bitField & 8454144) !== 0;
          };
          Promise2.prototype.__isCancelled = function() {
            return (this._bitField & 65536) === 65536;
          };
          Promise2.prototype._isCancelled = function() {
            return this._target().__isCancelled();
          };
          Promise2.prototype.isCancelled = function() {
            return (this._target()._bitField & 8454144) !== 0;
          };
          Promise2.prototype.isPending = function() {
            return isPending.call(this._target());
          };
          Promise2.prototype.isRejected = function() {
            return isRejected.call(this._target());
          };
          Promise2.prototype.isFulfilled = function() {
            return isFulfilled.call(this._target());
          };
          Promise2.prototype.isResolved = function() {
            return isResolved.call(this._target());
          };
          Promise2.prototype.value = function() {
            return value.call(this._target());
          };
          Promise2.prototype.reason = function() {
            var target = this._target();
            target._unsetRejectionIsUnhandled();
            return reason.call(target);
          };
          Promise2.prototype._value = function() {
            return this._settledValue();
          };
          Promise2.prototype._reason = function() {
            this._unsetRejectionIsUnhandled();
            return this._settledValue();
          };
          Promise2.PromiseInspection = PromiseInspection;
        };
      }, {}], 33: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, INTERNAL) {
          var util = _dereq_2("./util");
          var errorObj2 = util.errorObj;
          var isObject2 = util.isObject;
          function tryConvertToPromise(obj2, context) {
            if (isObject2(obj2)) {
              if (obj2 instanceof Promise2)
                return obj2;
              var then = getThen(obj2);
              if (then === errorObj2) {
                if (context)
                  context._pushContext();
                var ret2 = Promise2.reject(then.e);
                if (context)
                  context._popContext();
                return ret2;
              } else if (typeof then === "function") {
                if (isAnyBluebirdPromise(obj2)) {
                  var ret2 = new Promise2(INTERNAL);
                  obj2._then(
                    ret2._fulfill,
                    ret2._reject,
                    void 0,
                    ret2,
                    null
                  );
                  return ret2;
                }
                return doThenable(obj2, then, context);
              }
            }
            return obj2;
          }
          function doGetThen(obj2) {
            return obj2.then;
          }
          function getThen(obj2) {
            try {
              return doGetThen(obj2);
            } catch (e) {
              errorObj2.e = e;
              return errorObj2;
            }
          }
          var hasProp = {}.hasOwnProperty;
          function isAnyBluebirdPromise(obj2) {
            try {
              return hasProp.call(obj2, "_promise0");
            } catch (e) {
              return false;
            }
          }
          function doThenable(x, then, context) {
            var promise = new Promise2(INTERNAL);
            var ret2 = promise;
            if (context)
              context._pushContext();
            promise._captureStackTrace();
            if (context)
              context._popContext();
            var synchronous = true;
            var result = util.tryCatch(then).call(x, resolve, reject);
            synchronous = false;
            if (promise && result === errorObj2) {
              promise._rejectCallback(result.e, true, true);
              promise = null;
            }
            function resolve(value) {
              if (!promise)
                return;
              promise._resolveCallback(value);
              promise = null;
            }
            function reject(reason) {
              if (!promise)
                return;
              promise._rejectCallback(reason, synchronous, true);
              promise = null;
            }
            return ret2;
          }
          return tryConvertToPromise;
        };
      }, { "./util": 36 }], 34: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, INTERNAL, debug) {
          var util = _dereq_2("./util");
          var TimeoutError = Promise2.TimeoutError;
          function HandleWrapper(handle) {
            this.handle = handle;
          }
          HandleWrapper.prototype._resultCancelled = function() {
            clearTimeout(this.handle);
          };
          var afterValue = function(value) {
            return delay(+this).thenReturn(value);
          };
          var delay = Promise2.delay = function(ms, value) {
            var ret2;
            var handle;
            if (value !== void 0) {
              ret2 = Promise2.resolve(value)._then(afterValue, null, null, ms, void 0);
              if (debug.cancellation() && value instanceof Promise2) {
                ret2._setOnCancel(value);
              }
            } else {
              ret2 = new Promise2(INTERNAL);
              handle = setTimeout(function() {
                ret2._fulfill();
              }, +ms);
              if (debug.cancellation()) {
                ret2._setOnCancel(new HandleWrapper(handle));
              }
              ret2._captureStackTrace();
            }
            ret2._setAsyncGuaranteed();
            return ret2;
          };
          Promise2.prototype.delay = function(ms) {
            return delay(ms, this);
          };
          var afterTimeout = function(promise, message, parent) {
            var err;
            if (typeof message !== "string") {
              if (message instanceof Error) {
                err = message;
              } else {
                err = new TimeoutError("operation timed out");
              }
            } else {
              err = new TimeoutError(message);
            }
            util.markAsOriginatingFromRejection(err);
            promise._attachExtraTrace(err);
            promise._reject(err);
            if (parent != null) {
              parent.cancel();
            }
          };
          function successClear(value) {
            clearTimeout(this.handle);
            return value;
          }
          function failureClear(reason) {
            clearTimeout(this.handle);
            throw reason;
          }
          Promise2.prototype.timeout = function(ms, message) {
            ms = +ms;
            var ret2, parent;
            var handleWrapper = new HandleWrapper(setTimeout(function timeoutTimeout() {
              if (ret2.isPending()) {
                afterTimeout(ret2, message, parent);
              }
            }, ms));
            if (debug.cancellation()) {
              parent = this.then();
              ret2 = parent._then(
                successClear,
                failureClear,
                void 0,
                handleWrapper,
                void 0
              );
              ret2._setOnCancel(handleWrapper);
            } else {
              ret2 = this._then(
                successClear,
                failureClear,
                void 0,
                handleWrapper,
                void 0
              );
            }
            return ret2;
          };
        };
      }, { "./util": 36 }], 35: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, apiRejection, tryConvertToPromise, createContext, INTERNAL, debug) {
          var util = _dereq_2("./util");
          var TypeError2 = _dereq_2("./errors").TypeError;
          var inherits2 = _dereq_2("./util").inherits;
          var errorObj2 = util.errorObj;
          var tryCatch2 = util.tryCatch;
          var NULL = {};
          function thrower2(e) {
            setTimeout(function() {
              throw e;
            }, 0);
          }
          function castPreservingDisposable(thenable) {
            var maybePromise = tryConvertToPromise(thenable);
            if (maybePromise !== thenable && typeof thenable._isDisposable === "function" && typeof thenable._getDisposer === "function" && thenable._isDisposable()) {
              maybePromise._setDisposable(thenable._getDisposer());
            }
            return maybePromise;
          }
          function dispose(resources, inspection) {
            var i = 0;
            var len = resources.length;
            var ret2 = new Promise2(INTERNAL);
            function iterator() {
              if (i >= len)
                return ret2._fulfill();
              var maybePromise = castPreservingDisposable(resources[i++]);
              if (maybePromise instanceof Promise2 && maybePromise._isDisposable()) {
                try {
                  maybePromise = tryConvertToPromise(
                    maybePromise._getDisposer().tryDispose(inspection),
                    resources.promise
                  );
                } catch (e) {
                  return thrower2(e);
                }
                if (maybePromise instanceof Promise2) {
                  return maybePromise._then(
                    iterator,
                    thrower2,
                    null,
                    null,
                    null
                  );
                }
              }
              iterator();
            }
            iterator();
            return ret2;
          }
          function Disposer(data, promise, context) {
            this._data = data;
            this._promise = promise;
            this._context = context;
          }
          Disposer.prototype.data = function() {
            return this._data;
          };
          Disposer.prototype.promise = function() {
            return this._promise;
          };
          Disposer.prototype.resource = function() {
            if (this.promise().isFulfilled()) {
              return this.promise().value();
            }
            return NULL;
          };
          Disposer.prototype.tryDispose = function(inspection) {
            var resource = this.resource();
            var context = this._context;
            if (context !== void 0)
              context._pushContext();
            var ret2 = resource !== NULL ? this.doDispose(resource, inspection) : null;
            if (context !== void 0)
              context._popContext();
            this._promise._unsetDisposable();
            this._data = null;
            return ret2;
          };
          Disposer.isDisposer = function(d) {
            return d != null && typeof d.resource === "function" && typeof d.tryDispose === "function";
          };
          function FunctionDisposer(fn, promise, context) {
            this.constructor$(fn, promise, context);
          }
          inherits2(FunctionDisposer, Disposer);
          FunctionDisposer.prototype.doDispose = function(resource, inspection) {
            var fn = this.data();
            return fn.call(resource, resource, inspection);
          };
          function maybeUnwrapDisposer(value) {
            if (Disposer.isDisposer(value)) {
              this.resources[this.index]._setDisposable(value);
              return value.promise();
            }
            return value;
          }
          function ResourceList(length) {
            this.length = length;
            this.promise = null;
            this[length - 1] = null;
          }
          ResourceList.prototype._resultCancelled = function() {
            var len = this.length;
            for (var i = 0; i < len; ++i) {
              var item = this[i];
              if (item instanceof Promise2) {
                item.cancel();
              }
            }
          };
          Promise2.using = function() {
            var len = arguments.length;
            if (len < 2)
              return apiRejection(
                "you must pass at least 2 arguments to Promise.using"
              );
            var fn = arguments[len - 1];
            if (typeof fn !== "function") {
              return apiRejection("expecting a function but got " + util.classString(fn));
            }
            var input;
            var spreadArgs = true;
            if (len === 2 && Array.isArray(arguments[0])) {
              input = arguments[0];
              len = input.length;
              spreadArgs = false;
            } else {
              input = arguments;
              len--;
            }
            var resources = new ResourceList(len);
            for (var i = 0; i < len; ++i) {
              var resource = input[i];
              if (Disposer.isDisposer(resource)) {
                var disposer = resource;
                resource = resource.promise();
                resource._setDisposable(disposer);
              } else {
                var maybePromise = tryConvertToPromise(resource);
                if (maybePromise instanceof Promise2) {
                  resource = maybePromise._then(maybeUnwrapDisposer, null, null, {
                    resources,
                    index: i
                  }, void 0);
                }
              }
              resources[i] = resource;
            }
            var reflectedResources = new Array(resources.length);
            for (var i = 0; i < reflectedResources.length; ++i) {
              reflectedResources[i] = Promise2.resolve(resources[i]).reflect();
            }
            var resultPromise = Promise2.all(reflectedResources).then(function(inspections) {
              for (var i2 = 0; i2 < inspections.length; ++i2) {
                var inspection = inspections[i2];
                if (inspection.isRejected()) {
                  errorObj2.e = inspection.error();
                  return errorObj2;
                } else if (!inspection.isFulfilled()) {
                  resultPromise.cancel();
                  return;
                }
                inspections[i2] = inspection.value();
              }
              promise._pushContext();
              fn = tryCatch2(fn);
              var ret2 = spreadArgs ? fn.apply(void 0, inspections) : fn(inspections);
              var promiseCreated = promise._popContext();
              debug.checkForgottenReturns(
                ret2,
                promiseCreated,
                "Promise.using",
                promise
              );
              return ret2;
            });
            var promise = resultPromise.lastly(function() {
              var inspection = new Promise2.PromiseInspection(resultPromise);
              return dispose(resources, inspection);
            });
            resources.promise = promise;
            promise._setOnCancel(resources);
            return promise;
          };
          Promise2.prototype._setDisposable = function(disposer) {
            this._bitField = this._bitField | 131072;
            this._disposer = disposer;
          };
          Promise2.prototype._isDisposable = function() {
            return (this._bitField & 131072) > 0;
          };
          Promise2.prototype._getDisposer = function() {
            return this._disposer;
          };
          Promise2.prototype._unsetDisposable = function() {
            this._bitField = this._bitField & ~131072;
            this._disposer = void 0;
          };
          Promise2.prototype.disposer = function(fn) {
            if (typeof fn === "function") {
              return new FunctionDisposer(fn, this, createContext());
            }
            throw new TypeError2();
          };
        };
      }, { "./errors": 12, "./util": 36 }], 36: [function(_dereq_, module, exports) {
        "use strict";
        var es5 = _dereq_("./es5");
        var canEvaluate = typeof navigator == "undefined";
        var errorObj = { e: {} };
        var tryCatchTarget;
        var globalObject = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : this !== void 0 ? this : null;
        function tryCatcher() {
          try {
            var target = tryCatchTarget;
            tryCatchTarget = null;
            return target.apply(this, arguments);
          } catch (e) {
            errorObj.e = e;
            return errorObj;
          }
        }
        function tryCatch(fn) {
          tryCatchTarget = fn;
          return tryCatcher;
        }
        var inherits = function(Child, Parent) {
          var hasProp = {}.hasOwnProperty;
          function T() {
            this.constructor = Child;
            this.constructor$ = Parent;
            for (var propertyName in Parent.prototype) {
              if (hasProp.call(Parent.prototype, propertyName) && propertyName.charAt(propertyName.length - 1) !== "$") {
                this[propertyName + "$"] = Parent.prototype[propertyName];
              }
            }
          }
          T.prototype = Parent.prototype;
          Child.prototype = new T();
          return Child.prototype;
        };
        function isPrimitive(val) {
          return val == null || val === true || val === false || typeof val === "string" || typeof val === "number";
        }
        function isObject(value) {
          return typeof value === "function" || typeof value === "object" && value !== null;
        }
        function maybeWrapAsError(maybeError) {
          if (!isPrimitive(maybeError))
            return maybeError;
          return new Error(safeToString(maybeError));
        }
        function withAppended(target, appendee) {
          var len = target.length;
          var ret2 = new Array(len + 1);
          var i;
          for (i = 0; i < len; ++i) {
            ret2[i] = target[i];
          }
          ret2[i] = appendee;
          return ret2;
        }
        function getDataPropertyOrDefault(obj2, key, defaultValue) {
          if (es5.isES5) {
            var desc = Object.getOwnPropertyDescriptor(obj2, key);
            if (desc != null) {
              return desc.get == null && desc.set == null ? desc.value : defaultValue;
            }
          } else {
            return {}.hasOwnProperty.call(obj2, key) ? obj2[key] : void 0;
          }
        }
        function notEnumerableProp(obj2, name, value) {
          if (isPrimitive(obj2))
            return obj2;
          var descriptor = {
            value,
            configurable: true,
            enumerable: false,
            writable: true
          };
          es5.defineProperty(obj2, name, descriptor);
          return obj2;
        }
        function thrower(r) {
          throw r;
        }
        var inheritedDataKeys = function() {
          var excludedPrototypes = [
            Array.prototype,
            Object.prototype,
            Function.prototype
          ];
          var isExcludedProto = function(val) {
            for (var i = 0; i < excludedPrototypes.length; ++i) {
              if (excludedPrototypes[i] === val) {
                return true;
              }
            }
            return false;
          };
          if (es5.isES5) {
            var getKeys = Object.getOwnPropertyNames;
            return function(obj2) {
              var ret2 = [];
              var visitedKeys = /* @__PURE__ */ Object.create(null);
              while (obj2 != null && !isExcludedProto(obj2)) {
                var keys;
                try {
                  keys = getKeys(obj2);
                } catch (e) {
                  return ret2;
                }
                for (var i = 0; i < keys.length; ++i) {
                  var key = keys[i];
                  if (visitedKeys[key])
                    continue;
                  visitedKeys[key] = true;
                  var desc = Object.getOwnPropertyDescriptor(obj2, key);
                  if (desc != null && desc.get == null && desc.set == null) {
                    ret2.push(key);
                  }
                }
                obj2 = es5.getPrototypeOf(obj2);
              }
              return ret2;
            };
          } else {
            var hasProp = {}.hasOwnProperty;
            return function(obj2) {
              if (isExcludedProto(obj2))
                return [];
              var ret2 = [];
              enumeration:
                for (var key in obj2) {
                  if (hasProp.call(obj2, key)) {
                    ret2.push(key);
                  } else {
                    for (var i = 0; i < excludedPrototypes.length; ++i) {
                      if (hasProp.call(excludedPrototypes[i], key)) {
                        continue enumeration;
                      }
                    }
                    ret2.push(key);
                  }
                }
              return ret2;
            };
          }
        }();
        var thisAssignmentPattern = /this\s*\.\s*\S+\s*=/;
        function isClass(fn) {
          try {
            if (typeof fn === "function") {
              var keys = es5.names(fn.prototype);
              var hasMethods = es5.isES5 && keys.length > 1;
              var hasMethodsOtherThanConstructor = keys.length > 0 && !(keys.length === 1 && keys[0] === "constructor");
              var hasThisAssignmentAndStaticMethods = thisAssignmentPattern.test(fn + "") && es5.names(fn).length > 0;
              if (hasMethods || hasMethodsOtherThanConstructor || hasThisAssignmentAndStaticMethods) {
                return true;
              }
            }
            return false;
          } catch (e) {
            return false;
          }
        }
        function toFastProperties(obj) {
          function FakeConstructor() {
          }
          FakeConstructor.prototype = obj;
          var receiver = new FakeConstructor();
          function ic() {
            return typeof receiver.foo;
          }
          ic();
          ic();
          return obj;
          eval(obj);
        }
        var rident = /^[a-z$_][a-z$_0-9]*$/i;
        function isIdentifier(str) {
          return rident.test(str);
        }
        function filledRange(count, prefix, suffix) {
          var ret2 = new Array(count);
          for (var i = 0; i < count; ++i) {
            ret2[i] = prefix + i + suffix;
          }
          return ret2;
        }
        function safeToString(obj2) {
          try {
            return obj2 + "";
          } catch (e) {
            return "[no string representation]";
          }
        }
        function isError(obj2) {
          return obj2 instanceof Error || obj2 !== null && typeof obj2 === "object" && typeof obj2.message === "string" && typeof obj2.name === "string";
        }
        function markAsOriginatingFromRejection(e) {
          try {
            notEnumerableProp(e, "isOperational", true);
          } catch (ignore) {
          }
        }
        function originatesFromRejection(e) {
          if (e == null)
            return false;
          return e instanceof Error["__BluebirdErrorTypes__"].OperationalError || e["isOperational"] === true;
        }
        function canAttachTrace(obj2) {
          return isError(obj2) && es5.propertyIsWritable(obj2, "stack");
        }
        var ensureErrorObject = function() {
          if (!("stack" in new Error())) {
            return function(value) {
              if (canAttachTrace(value))
                return value;
              try {
                throw new Error(safeToString(value));
              } catch (err) {
                return err;
              }
            };
          } else {
            return function(value) {
              if (canAttachTrace(value))
                return value;
              return new Error(safeToString(value));
            };
          }
        }();
        function classString(obj2) {
          return {}.toString.call(obj2);
        }
        function copyDescriptors(from, to, filter) {
          var keys = es5.names(from);
          for (var i = 0; i < keys.length; ++i) {
            var key = keys[i];
            if (filter(key)) {
              try {
                es5.defineProperty(to, key, es5.getDescriptor(from, key));
              } catch (ignore) {
              }
            }
          }
        }
        var asArray = function(v) {
          if (es5.isArray(v)) {
            return v;
          }
          return null;
        };
        if (typeof Symbol !== "undefined" && Symbol.iterator) {
          var ArrayFrom = typeof Array.from === "function" ? function(v) {
            return Array.from(v);
          } : function(v) {
            var ret2 = [];
            var it = v[Symbol.iterator]();
            var itResult;
            while (!(itResult = it.next()).done) {
              ret2.push(itResult.value);
            }
            return ret2;
          };
          asArray = function(v) {
            if (es5.isArray(v)) {
              return v;
            } else if (v != null && typeof v[Symbol.iterator] === "function") {
              return ArrayFrom(v);
            }
            return null;
          };
        }
        var isNode = typeof process !== "undefined" && classString(process).toLowerCase() === "[object process]";
        var hasEnvVariables = typeof process !== "undefined" && typeof process.env !== "undefined";
        function env(key) {
          return hasEnvVariables ? process.env[key] : void 0;
        }
        function getNativePromise() {
          if (typeof Promise === "function") {
            try {
              var promise = new Promise(function() {
              });
              if (classString(promise) === "[object Promise]") {
                return Promise;
              }
            } catch (e) {
            }
          }
        }
        var reflectHandler;
        function contextBind(ctx, cb) {
          if (ctx === null || typeof cb !== "function" || cb === reflectHandler) {
            return cb;
          }
          if (ctx.domain !== null) {
            cb = ctx.domain.bind(cb);
          }
          var async = ctx.async;
          if (async !== null) {
            var old = cb;
            cb = function() {
              var args = new Array(2).concat([].slice.call(arguments));
              ;
              args[0] = old;
              args[1] = this;
              return async.runInAsyncScope.apply(async, args);
            };
          }
          return cb;
        }
        var ret = {
          setReflectHandler: function(fn) {
            reflectHandler = fn;
          },
          isClass,
          isIdentifier,
          inheritedDataKeys,
          getDataPropertyOrDefault,
          thrower,
          isArray: es5.isArray,
          asArray,
          notEnumerableProp,
          isPrimitive,
          isObject,
          isError,
          canEvaluate,
          errorObj,
          tryCatch,
          inherits,
          withAppended,
          maybeWrapAsError,
          toFastProperties,
          filledRange,
          toString: safeToString,
          canAttachTrace,
          ensureErrorObject,
          originatesFromRejection,
          markAsOriginatingFromRejection,
          classString,
          copyDescriptors,
          isNode,
          hasEnvVariables,
          env,
          global: globalObject,
          getNativePromise,
          contextBind
        };
        ret.isRecentNode = ret.isNode && function() {
          var version;
          if (process.versions && process.versions.node) {
            version = process.versions.node.split(".").map(Number);
          } else if (process.version) {
            version = process.version.split(".").map(Number);
          }
          return version[0] === 0 && version[1] > 10 || version[0] > 0;
        }();
        ret.nodeSupportsAsyncResource = ret.isNode && function() {
          var supportsAsync = false;
          try {
            var res = _dereq_("async_hooks").AsyncResource;
            supportsAsync = typeof res.prototype.runInAsyncScope === "function";
          } catch (e) {
            supportsAsync = false;
          }
          return supportsAsync;
        }();
        if (ret.isNode)
          ret.toFastProperties(process);
        try {
          throw new Error();
        } catch (e) {
          ret.lastLineError = e;
        }
        module.exports = ret;
      }, { "./es5": 13, "async_hooks": void 0 }] }, {}, [4])(4);
    });
    if (typeof window !== "undefined" && window !== null) {
      window.P = window.Promise;
    } else if (typeof self !== "undefined" && self !== null) {
      self.P = self.Promise;
    }
  }
});

// browser-external:crypto
var require_crypto = __commonJS({
  "browser-external:crypto"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "crypto" has been externalized for browser compatibility. Cannot access "crypto.${key}" in client code.`);
        }
      }
    }));
  }
});

// browser-external:events
var require_events = __commonJS({
  "browser-external:events"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "events" has been externalized for browser compatibility. Cannot access "events.${key}" in client code.`);
        }
      }
    }));
  }
});

// browser-external:net
var require_net = __commonJS({
  "browser-external:net"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "net" has been externalized for browser compatibility. Cannot access "net.${key}" in client code.`);
        }
      }
    }));
  }
});

// browser-external:tls
var require_tls = __commonJS({
  "browser-external:tls"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "tls" has been externalized for browser compatibility. Cannot access "tls.${key}" in client code.`);
        }
      }
    }));
  }
});

// browser-external:url
var require_url = __commonJS({
  "browser-external:url"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "url" has been externalized for browser compatibility. Cannot access "url.${key}" in client code.`);
        }
      }
    }));
  }
});

// node_modules/mysql/lib/protocol/constants/client.js
var require_client = __commonJS({
  "node_modules/mysql/lib/protocol/constants/client.js"(exports2) {
    exports2.CLIENT_LONG_PASSWORD = 1;
    exports2.CLIENT_FOUND_ROWS = 2;
    exports2.CLIENT_LONG_FLAG = 4;
    exports2.CLIENT_CONNECT_WITH_DB = 8;
    exports2.CLIENT_NO_SCHEMA = 16;
    exports2.CLIENT_COMPRESS = 32;
    exports2.CLIENT_ODBC = 64;
    exports2.CLIENT_LOCAL_FILES = 128;
    exports2.CLIENT_IGNORE_SPACE = 256;
    exports2.CLIENT_PROTOCOL_41 = 512;
    exports2.CLIENT_INTERACTIVE = 1024;
    exports2.CLIENT_SSL = 2048;
    exports2.CLIENT_IGNORE_SIGPIPE = 4096;
    exports2.CLIENT_TRANSACTIONS = 8192;
    exports2.CLIENT_RESERVED = 16384;
    exports2.CLIENT_SECURE_CONNECTION = 32768;
    exports2.CLIENT_MULTI_STATEMENTS = 65536;
    exports2.CLIENT_MULTI_RESULTS = 131072;
    exports2.CLIENT_PS_MULTI_RESULTS = 262144;
    exports2.CLIENT_PLUGIN_AUTH = 524288;
    exports2.CLIENT_SSL_VERIFY_SERVER_CERT = 1073741824;
    exports2.CLIENT_REMEMBER_OPTIONS = 2147483648;
  }
});

// node_modules/mysql/lib/protocol/constants/charsets.js
var require_charsets = __commonJS({
  "node_modules/mysql/lib/protocol/constants/charsets.js"(exports2) {
    exports2.BIG5_CHINESE_CI = 1;
    exports2.LATIN2_CZECH_CS = 2;
    exports2.DEC8_SWEDISH_CI = 3;
    exports2.CP850_GENERAL_CI = 4;
    exports2.LATIN1_GERMAN1_CI = 5;
    exports2.HP8_ENGLISH_CI = 6;
    exports2.KOI8R_GENERAL_CI = 7;
    exports2.LATIN1_SWEDISH_CI = 8;
    exports2.LATIN2_GENERAL_CI = 9;
    exports2.SWE7_SWEDISH_CI = 10;
    exports2.ASCII_GENERAL_CI = 11;
    exports2.UJIS_JAPANESE_CI = 12;
    exports2.SJIS_JAPANESE_CI = 13;
    exports2.CP1251_BULGARIAN_CI = 14;
    exports2.LATIN1_DANISH_CI = 15;
    exports2.HEBREW_GENERAL_CI = 16;
    exports2.TIS620_THAI_CI = 18;
    exports2.EUCKR_KOREAN_CI = 19;
    exports2.LATIN7_ESTONIAN_CS = 20;
    exports2.LATIN2_HUNGARIAN_CI = 21;
    exports2.KOI8U_GENERAL_CI = 22;
    exports2.CP1251_UKRAINIAN_CI = 23;
    exports2.GB2312_CHINESE_CI = 24;
    exports2.GREEK_GENERAL_CI = 25;
    exports2.CP1250_GENERAL_CI = 26;
    exports2.LATIN2_CROATIAN_CI = 27;
    exports2.GBK_CHINESE_CI = 28;
    exports2.CP1257_LITHUANIAN_CI = 29;
    exports2.LATIN5_TURKISH_CI = 30;
    exports2.LATIN1_GERMAN2_CI = 31;
    exports2.ARMSCII8_GENERAL_CI = 32;
    exports2.UTF8_GENERAL_CI = 33;
    exports2.CP1250_CZECH_CS = 34;
    exports2.UCS2_GENERAL_CI = 35;
    exports2.CP866_GENERAL_CI = 36;
    exports2.KEYBCS2_GENERAL_CI = 37;
    exports2.MACCE_GENERAL_CI = 38;
    exports2.MACROMAN_GENERAL_CI = 39;
    exports2.CP852_GENERAL_CI = 40;
    exports2.LATIN7_GENERAL_CI = 41;
    exports2.LATIN7_GENERAL_CS = 42;
    exports2.MACCE_BIN = 43;
    exports2.CP1250_CROATIAN_CI = 44;
    exports2.UTF8MB4_GENERAL_CI = 45;
    exports2.UTF8MB4_BIN = 46;
    exports2.LATIN1_BIN = 47;
    exports2.LATIN1_GENERAL_CI = 48;
    exports2.LATIN1_GENERAL_CS = 49;
    exports2.CP1251_BIN = 50;
    exports2.CP1251_GENERAL_CI = 51;
    exports2.CP1251_GENERAL_CS = 52;
    exports2.MACROMAN_BIN = 53;
    exports2.UTF16_GENERAL_CI = 54;
    exports2.UTF16_BIN = 55;
    exports2.UTF16LE_GENERAL_CI = 56;
    exports2.CP1256_GENERAL_CI = 57;
    exports2.CP1257_BIN = 58;
    exports2.CP1257_GENERAL_CI = 59;
    exports2.UTF32_GENERAL_CI = 60;
    exports2.UTF32_BIN = 61;
    exports2.UTF16LE_BIN = 62;
    exports2.BINARY = 63;
    exports2.ARMSCII8_BIN = 64;
    exports2.ASCII_BIN = 65;
    exports2.CP1250_BIN = 66;
    exports2.CP1256_BIN = 67;
    exports2.CP866_BIN = 68;
    exports2.DEC8_BIN = 69;
    exports2.GREEK_BIN = 70;
    exports2.HEBREW_BIN = 71;
    exports2.HP8_BIN = 72;
    exports2.KEYBCS2_BIN = 73;
    exports2.KOI8R_BIN = 74;
    exports2.KOI8U_BIN = 75;
    exports2.LATIN2_BIN = 77;
    exports2.LATIN5_BIN = 78;
    exports2.LATIN7_BIN = 79;
    exports2.CP850_BIN = 80;
    exports2.CP852_BIN = 81;
    exports2.SWE7_BIN = 82;
    exports2.UTF8_BIN = 83;
    exports2.BIG5_BIN = 84;
    exports2.EUCKR_BIN = 85;
    exports2.GB2312_BIN = 86;
    exports2.GBK_BIN = 87;
    exports2.SJIS_BIN = 88;
    exports2.TIS620_BIN = 89;
    exports2.UCS2_BIN = 90;
    exports2.UJIS_BIN = 91;
    exports2.GEOSTD8_GENERAL_CI = 92;
    exports2.GEOSTD8_BIN = 93;
    exports2.LATIN1_SPANISH_CI = 94;
    exports2.CP932_JAPANESE_CI = 95;
    exports2.CP932_BIN = 96;
    exports2.EUCJPMS_JAPANESE_CI = 97;
    exports2.EUCJPMS_BIN = 98;
    exports2.CP1250_POLISH_CI = 99;
    exports2.UTF16_UNICODE_CI = 101;
    exports2.UTF16_ICELANDIC_CI = 102;
    exports2.UTF16_LATVIAN_CI = 103;
    exports2.UTF16_ROMANIAN_CI = 104;
    exports2.UTF16_SLOVENIAN_CI = 105;
    exports2.UTF16_POLISH_CI = 106;
    exports2.UTF16_ESTONIAN_CI = 107;
    exports2.UTF16_SPANISH_CI = 108;
    exports2.UTF16_SWEDISH_CI = 109;
    exports2.UTF16_TURKISH_CI = 110;
    exports2.UTF16_CZECH_CI = 111;
    exports2.UTF16_DANISH_CI = 112;
    exports2.UTF16_LITHUANIAN_CI = 113;
    exports2.UTF16_SLOVAK_CI = 114;
    exports2.UTF16_SPANISH2_CI = 115;
    exports2.UTF16_ROMAN_CI = 116;
    exports2.UTF16_PERSIAN_CI = 117;
    exports2.UTF16_ESPERANTO_CI = 118;
    exports2.UTF16_HUNGARIAN_CI = 119;
    exports2.UTF16_SINHALA_CI = 120;
    exports2.UTF16_GERMAN2_CI = 121;
    exports2.UTF16_CROATIAN_MYSQL561_CI = 122;
    exports2.UTF16_UNICODE_520_CI = 123;
    exports2.UTF16_VIETNAMESE_CI = 124;
    exports2.UCS2_UNICODE_CI = 128;
    exports2.UCS2_ICELANDIC_CI = 129;
    exports2.UCS2_LATVIAN_CI = 130;
    exports2.UCS2_ROMANIAN_CI = 131;
    exports2.UCS2_SLOVENIAN_CI = 132;
    exports2.UCS2_POLISH_CI = 133;
    exports2.UCS2_ESTONIAN_CI = 134;
    exports2.UCS2_SPANISH_CI = 135;
    exports2.UCS2_SWEDISH_CI = 136;
    exports2.UCS2_TURKISH_CI = 137;
    exports2.UCS2_CZECH_CI = 138;
    exports2.UCS2_DANISH_CI = 139;
    exports2.UCS2_LITHUANIAN_CI = 140;
    exports2.UCS2_SLOVAK_CI = 141;
    exports2.UCS2_SPANISH2_CI = 142;
    exports2.UCS2_ROMAN_CI = 143;
    exports2.UCS2_PERSIAN_CI = 144;
    exports2.UCS2_ESPERANTO_CI = 145;
    exports2.UCS2_HUNGARIAN_CI = 146;
    exports2.UCS2_SINHALA_CI = 147;
    exports2.UCS2_GERMAN2_CI = 148;
    exports2.UCS2_CROATIAN_MYSQL561_CI = 149;
    exports2.UCS2_UNICODE_520_CI = 150;
    exports2.UCS2_VIETNAMESE_CI = 151;
    exports2.UCS2_GENERAL_MYSQL500_CI = 159;
    exports2.UTF32_UNICODE_CI = 160;
    exports2.UTF32_ICELANDIC_CI = 161;
    exports2.UTF32_LATVIAN_CI = 162;
    exports2.UTF32_ROMANIAN_CI = 163;
    exports2.UTF32_SLOVENIAN_CI = 164;
    exports2.UTF32_POLISH_CI = 165;
    exports2.UTF32_ESTONIAN_CI = 166;
    exports2.UTF32_SPANISH_CI = 167;
    exports2.UTF32_SWEDISH_CI = 168;
    exports2.UTF32_TURKISH_CI = 169;
    exports2.UTF32_CZECH_CI = 170;
    exports2.UTF32_DANISH_CI = 171;
    exports2.UTF32_LITHUANIAN_CI = 172;
    exports2.UTF32_SLOVAK_CI = 173;
    exports2.UTF32_SPANISH2_CI = 174;
    exports2.UTF32_ROMAN_CI = 175;
    exports2.UTF32_PERSIAN_CI = 176;
    exports2.UTF32_ESPERANTO_CI = 177;
    exports2.UTF32_HUNGARIAN_CI = 178;
    exports2.UTF32_SINHALA_CI = 179;
    exports2.UTF32_GERMAN2_CI = 180;
    exports2.UTF32_CROATIAN_MYSQL561_CI = 181;
    exports2.UTF32_UNICODE_520_CI = 182;
    exports2.UTF32_VIETNAMESE_CI = 183;
    exports2.UTF8_UNICODE_CI = 192;
    exports2.UTF8_ICELANDIC_CI = 193;
    exports2.UTF8_LATVIAN_CI = 194;
    exports2.UTF8_ROMANIAN_CI = 195;
    exports2.UTF8_SLOVENIAN_CI = 196;
    exports2.UTF8_POLISH_CI = 197;
    exports2.UTF8_ESTONIAN_CI = 198;
    exports2.UTF8_SPANISH_CI = 199;
    exports2.UTF8_SWEDISH_CI = 200;
    exports2.UTF8_TURKISH_CI = 201;
    exports2.UTF8_CZECH_CI = 202;
    exports2.UTF8_DANISH_CI = 203;
    exports2.UTF8_LITHUANIAN_CI = 204;
    exports2.UTF8_SLOVAK_CI = 205;
    exports2.UTF8_SPANISH2_CI = 206;
    exports2.UTF8_ROMAN_CI = 207;
    exports2.UTF8_PERSIAN_CI = 208;
    exports2.UTF8_ESPERANTO_CI = 209;
    exports2.UTF8_HUNGARIAN_CI = 210;
    exports2.UTF8_SINHALA_CI = 211;
    exports2.UTF8_GERMAN2_CI = 212;
    exports2.UTF8_CROATIAN_MYSQL561_CI = 213;
    exports2.UTF8_UNICODE_520_CI = 214;
    exports2.UTF8_VIETNAMESE_CI = 215;
    exports2.UTF8_GENERAL_MYSQL500_CI = 223;
    exports2.UTF8MB4_UNICODE_CI = 224;
    exports2.UTF8MB4_ICELANDIC_CI = 225;
    exports2.UTF8MB4_LATVIAN_CI = 226;
    exports2.UTF8MB4_ROMANIAN_CI = 227;
    exports2.UTF8MB4_SLOVENIAN_CI = 228;
    exports2.UTF8MB4_POLISH_CI = 229;
    exports2.UTF8MB4_ESTONIAN_CI = 230;
    exports2.UTF8MB4_SPANISH_CI = 231;
    exports2.UTF8MB4_SWEDISH_CI = 232;
    exports2.UTF8MB4_TURKISH_CI = 233;
    exports2.UTF8MB4_CZECH_CI = 234;
    exports2.UTF8MB4_DANISH_CI = 235;
    exports2.UTF8MB4_LITHUANIAN_CI = 236;
    exports2.UTF8MB4_SLOVAK_CI = 237;
    exports2.UTF8MB4_SPANISH2_CI = 238;
    exports2.UTF8MB4_ROMAN_CI = 239;
    exports2.UTF8MB4_PERSIAN_CI = 240;
    exports2.UTF8MB4_ESPERANTO_CI = 241;
    exports2.UTF8MB4_HUNGARIAN_CI = 242;
    exports2.UTF8MB4_SINHALA_CI = 243;
    exports2.UTF8MB4_GERMAN2_CI = 244;
    exports2.UTF8MB4_CROATIAN_MYSQL561_CI = 245;
    exports2.UTF8MB4_UNICODE_520_CI = 246;
    exports2.UTF8MB4_VIETNAMESE_CI = 247;
    exports2.UTF8_GENERAL50_CI = 253;
    exports2.ARMSCII8 = exports2.ARMSCII8_GENERAL_CI;
    exports2.ASCII = exports2.ASCII_GENERAL_CI;
    exports2.BIG5 = exports2.BIG5_CHINESE_CI;
    exports2.BINARY = exports2.BINARY;
    exports2.CP1250 = exports2.CP1250_GENERAL_CI;
    exports2.CP1251 = exports2.CP1251_GENERAL_CI;
    exports2.CP1256 = exports2.CP1256_GENERAL_CI;
    exports2.CP1257 = exports2.CP1257_GENERAL_CI;
    exports2.CP866 = exports2.CP866_GENERAL_CI;
    exports2.CP850 = exports2.CP850_GENERAL_CI;
    exports2.CP852 = exports2.CP852_GENERAL_CI;
    exports2.CP932 = exports2.CP932_JAPANESE_CI;
    exports2.DEC8 = exports2.DEC8_SWEDISH_CI;
    exports2.EUCJPMS = exports2.EUCJPMS_JAPANESE_CI;
    exports2.EUCKR = exports2.EUCKR_KOREAN_CI;
    exports2.GB2312 = exports2.GB2312_CHINESE_CI;
    exports2.GBK = exports2.GBK_CHINESE_CI;
    exports2.GEOSTD8 = exports2.GEOSTD8_GENERAL_CI;
    exports2.GREEK = exports2.GREEK_GENERAL_CI;
    exports2.HEBREW = exports2.HEBREW_GENERAL_CI;
    exports2.HP8 = exports2.HP8_ENGLISH_CI;
    exports2.KEYBCS2 = exports2.KEYBCS2_GENERAL_CI;
    exports2.KOI8R = exports2.KOI8R_GENERAL_CI;
    exports2.KOI8U = exports2.KOI8U_GENERAL_CI;
    exports2.LATIN1 = exports2.LATIN1_SWEDISH_CI;
    exports2.LATIN2 = exports2.LATIN2_GENERAL_CI;
    exports2.LATIN5 = exports2.LATIN5_TURKISH_CI;
    exports2.LATIN7 = exports2.LATIN7_GENERAL_CI;
    exports2.MACCE = exports2.MACCE_GENERAL_CI;
    exports2.MACROMAN = exports2.MACROMAN_GENERAL_CI;
    exports2.SJIS = exports2.SJIS_JAPANESE_CI;
    exports2.SWE7 = exports2.SWE7_SWEDISH_CI;
    exports2.TIS620 = exports2.TIS620_THAI_CI;
    exports2.UCS2 = exports2.UCS2_GENERAL_CI;
    exports2.UJIS = exports2.UJIS_JAPANESE_CI;
    exports2.UTF16 = exports2.UTF16_GENERAL_CI;
    exports2.UTF16LE = exports2.UTF16LE_GENERAL_CI;
    exports2.UTF8 = exports2.UTF8_GENERAL_CI;
    exports2.UTF8MB4 = exports2.UTF8MB4_GENERAL_CI;
    exports2.UTF32 = exports2.UTF32_GENERAL_CI;
  }
});

// node_modules/mysql/lib/protocol/constants/ssl_profiles.js
var require_ssl_profiles = __commonJS({
  "node_modules/mysql/lib/protocol/constants/ssl_profiles.js"(exports2) {
    exports2["Amazon RDS"] = {
      ca: [
        /**
         * Amazon RDS global certificate 2010 to 2015
         *
         *   CN = aws.amazon.com/rds/
         *   OU = RDS
         *   O = Amazon.com
         *   L = Seattle
         *   ST = Washington
         *   C = US
         *   P = 2010-04-05T22:44:31Z/2015-04-04T22:41:31Z
         *   F = 7F:09:8D:A5:7D:BB:A6:EF:7C:70:D8:CA:4E:49:11:55:7E:89:A7:D3
         */
        "-----BEGIN CERTIFICATE-----\nMIIDQzCCAqygAwIBAgIJAOd1tlfiGoEoMA0GCSqGSIb3DQEBBQUAMHUxCzAJBgNV\nBAYTAlVTMRMwEQYDVQQIEwpXYXNoaW5ndG9uMRAwDgYDVQQHEwdTZWF0dGxlMRMw\nEQYDVQQKEwpBbWF6b24uY29tMQwwCgYDVQQLEwNSRFMxHDAaBgNVBAMTE2F3cy5h\nbWF6b24uY29tL3Jkcy8wHhcNMTAwNDA1MjI0NDMxWhcNMTUwNDA0MjI0NDMxWjB1\nMQswCQYDVQQGEwJVUzETMBEGA1UECBMKV2FzaGluZ3RvbjEQMA4GA1UEBxMHU2Vh\ndHRsZTETMBEGA1UEChMKQW1hem9uLmNvbTEMMAoGA1UECxMDUkRTMRwwGgYDVQQD\nExNhd3MuYW1hem9uLmNvbS9yZHMvMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKB\ngQDKhXGU7tizxUR5WaFoMTFcxNxa05PEjZaIOEN5ctkWrqYSRov0/nOMoZjqk8bC\nmed9vPFoQGD0OTakPs0jVe3wwmR735hyVwmKIPPsGlaBYj1O6llIpZeQVyupNx56\nUzqtiLaDzh1KcmfqP3qP2dInzBfJQKjiRudo1FWnpPt33QIDAQABo4HaMIHXMB0G\nA1UdDgQWBBT/H3x+cqSkR/ePSIinPtc4yWKe3DCBpwYDVR0jBIGfMIGcgBT/H3x+\ncqSkR/ePSIinPtc4yWKe3KF5pHcwdTELMAkGA1UEBhMCVVMxEzARBgNVBAgTCldh\nc2hpbmd0b24xEDAOBgNVBAcTB1NlYXR0bGUxEzARBgNVBAoTCkFtYXpvbi5jb20x\nDDAKBgNVBAsTA1JEUzEcMBoGA1UEAxMTYXdzLmFtYXpvbi5jb20vcmRzL4IJAOd1\ntlfiGoEoMAwGA1UdEwQFMAMBAf8wDQYJKoZIhvcNAQEFBQADgYEAvguZy/BDT66x\nGfgnJlyQwnFSeVLQm9u/FIvz4huGjbq9dqnD6h/Gm56QPFdyMEyDiZWaqY6V08lY\nLTBNb4kcIc9/6pc0/ojKciP5QJRm6OiZ4vgG05nF4fYjhU7WClUx7cxq1fKjNc2J\nUCmmYqgiVkAGWRETVo+byOSDZ4swb10=\n-----END CERTIFICATE-----\n",
        /**
         * Amazon RDS global root CA 2015 to 2020
         *
         *   CN = Amazon RDS Root CA
         *   OU = Amazon RDS
         *   O = Amazon Web Services, Inc.
         *   L = Seattle
         *   ST = Washington
         *   C = US
         *   P = 2015-02-05T09:11:31Z/2020-03-05T09:11:31Z
         *   F = E8:11:88:56:E7:A7:CE:3E:5E:DC:9A:31:25:1B:93:AC:DC:43:CE:B0
         */
        "-----BEGIN CERTIFICATE-----\nMIID9DCCAtygAwIBAgIBQjANBgkqhkiG9w0BAQUFADCBijELMAkGA1UEBhMCVVMx\nEzARBgNVBAgMCldhc2hpbmd0b24xEDAOBgNVBAcMB1NlYXR0bGUxIjAgBgNVBAoM\nGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMx\nGzAZBgNVBAMMEkFtYXpvbiBSRFMgUm9vdCBDQTAeFw0xNTAyMDUwOTExMzFaFw0y\nMDAzMDUwOTExMzFaMIGKMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2FzaGluZ3Rv\nbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNl\ncywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEbMBkGA1UEAwwSQW1hem9uIFJE\nUyBSb290IENBMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAuD8nrZ8V\nu+VA8yVlUipCZIKPTDcOILYpUe8Tct0YeQQr0uyl018StdBsa3CjBgvwpDRq1HgF\nJi2N3+39+shCNspQeE6aYU+BHXhKhIIStt3r7gl/4NqYiDDMWKHxHq0nsGDFfArf\nAOcjZdJagOMqb3fF46flc8k2E7THTm9Sz4L7RY1WdABMuurpICLFE3oHcGdapOb9\nT53pQR+xpHW9atkcf3pf7gbO0rlKVSIoUenBlZipUlp1VZl/OD/E+TtRhDDNdI2J\nP/DSMM3aEsq6ZQkfbz/Ilml+Lx3tJYXUDmp+ZjzMPLk/+3beT8EhrwtcG3VPpvwp\nBIOqsqVVTvw/CwIDAQABo2MwYTAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0TAQH/BAUw\nAwEB/zAdBgNVHQ4EFgQUTgLurD72FchM7Sz1BcGPnIQISYMwHwYDVR0jBBgwFoAU\nTgLurD72FchM7Sz1BcGPnIQISYMwDQYJKoZIhvcNAQEFBQADggEBAHZcgIio8pAm\nMjHD5cl6wKjXxScXKtXygWH2BoDMYBJF9yfyKO2jEFxYKbHePpnXB1R04zJSWAw5\n2EUuDI1pSBh9BA82/5PkuNlNeSTB3dXDD2PEPdzVWbSKvUB8ZdooV+2vngL0Zm4r\n47QPyd18yPHrRIbtBtHR/6CwKevLZ394zgExqhnekYKIqqEX41xsUV0Gm6x4vpjf\n2u6O/+YE2U+qyyxHE5Wd5oqde0oo9UUpFETJPVb6Q2cEeQib8PBAyi0i6KnF+kIV\nA9dY7IHSubtCK/i8wxMVqfd5GtbA8mmpeJFwnDvm9rBEsHybl08qlax9syEwsUYr\n/40NawZfTUU=\n-----END CERTIFICATE-----\n",
        /**
         * Amazon RDS global root CA 2019 to 2024
         *
         *   CN = Amazon RDS Root 2019 CA
         *   OU = Amazon RDS
         *   O = Amazon Web Services, Inc.
         *   L = Seattle
         *   ST = Washington
         *   C = US
         *   P = 2019-08-22T17:08:50Z/2024-08-22T17:08:50Z
         *   F = D4:0D:DB:29:E3:75:0D:FF:A6:71:C3:14:0B:BF:5F:47:8D:1C:80:96
         */
        "-----BEGIN CERTIFICATE-----\nMIIEBjCCAu6gAwIBAgIJAMc0ZzaSUK51MA0GCSqGSIb3DQEBCwUAMIGPMQswCQYD\nVQQGEwJVUzEQMA4GA1UEBwwHU2VhdHRsZTETMBEGA1UECAwKV2FzaGluZ3RvbjEi\nMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1h\nem9uIFJEUzEgMB4GA1UEAwwXQW1hem9uIFJEUyBSb290IDIwMTkgQ0EwHhcNMTkw\nODIyMTcwODUwWhcNMjQwODIyMTcwODUwWjCBjzELMAkGA1UEBhMCVVMxEDAOBgNV\nBAcMB1NlYXR0bGUxEzARBgNVBAgMCldhc2hpbmd0b24xIjAgBgNVBAoMGUFtYXpv\nbiBXZWIgU2VydmljZXMsIEluYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxIDAeBgNV\nBAMMF0FtYXpvbiBSRFMgUm9vdCAyMDE5IENBMIIBIjANBgkqhkiG9w0BAQEFAAOC\nAQ8AMIIBCgKCAQEArXnF/E6/Qh+ku3hQTSKPMhQQlCpoWvnIthzX6MK3p5a0eXKZ\noWIjYcNNG6UwJjp4fUXl6glp53Jobn+tWNX88dNH2n8DVbppSwScVE2LpuL+94vY\n0EYE/XxN7svKea8YvlrqkUBKyxLxTjh+U/KrGOaHxz9v0l6ZNlDbuaZw3qIWdD/I\n6aNbGeRUVtpM6P+bWIoxVl/caQylQS6CEYUk+CpVyJSkopwJlzXT07tMoDL5WgX9\nO08KVgDNz9qP/IGtAcRduRcNioH3E9v981QO1zt/Gpb2f8NqAjUUCUZzOnij6mx9\nMcZ+9cWX88CRzR0vQODWuZscgI08NvM69Fn2SQIDAQABo2MwYTAOBgNVHQ8BAf8E\nBAMCAQYwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUc19g2LzLA5j0Kxc0LjZa\npmD/vB8wHwYDVR0jBBgwFoAUc19g2LzLA5j0Kxc0LjZapmD/vB8wDQYJKoZIhvcN\nAQELBQADggEBAHAG7WTmyjzPRIM85rVj+fWHsLIvqpw6DObIjMWokpliCeMINZFV\nynfgBKsf1ExwbvJNzYFXW6dihnguDG9VMPpi2up/ctQTN8tm9nDKOy08uNZoofMc\nNUZxKCEkVKZv+IL4oHoeayt8egtv3ujJM6V14AstMQ6SwvwvA93EP/Ug2e4WAXHu\ncbI1NAbUgVDqp+DRdfvZkgYKryjTWd/0+1fS8X1bBZVWzl7eirNVnHbSH2ZDpNuY\n0SBd8dj5F6ld3t58ydZbrTHze7JJOd8ijySAp4/kiu9UfZWuTPABzDa/DSdz9Dk/\nzPW4CXXvhLmE02TA9/HeCw3KEHIwicNuEfw=\n-----END CERTIFICATE-----\n",
        /**
         * Amazon RDS ap-northeast-1 certificate CA 2015 to 2020
         *
         *   CN = Amazon RDS ap-northeast-1 CA
         *   OU = Amazon RDS
         *   O = Amazon Web Services, Inc.
         *   L = Seattle
         *   ST = Washington
         *   C = US
         *   P = 2015-02-05T22:03:06Z/2020-03-05T22:03:06Z
         *   F = 4B:2D:8A:E0:C1:A3:A9:AF:A7:BB:65:0C:5A:16:8A:39:3C:03:F2:C5
         */
        "-----BEGIN CERTIFICATE-----\nMIIEATCCAumgAwIBAgIBRDANBgkqhkiG9w0BAQUFADCBijELMAkGA1UEBhMCVVMx\nEzARBgNVBAgMCldhc2hpbmd0b24xEDAOBgNVBAcMB1NlYXR0bGUxIjAgBgNVBAoM\nGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMx\nGzAZBgNVBAMMEkFtYXpvbiBSRFMgUm9vdCBDQTAeFw0xNTAyMDUyMjAzMDZaFw0y\nMDAzMDUyMjAzMDZaMIGUMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2FzaGluZ3Rv\nbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNl\ncywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzElMCMGA1UEAwwcQW1hem9uIFJE\nUyBhcC1ub3J0aGVhc3QtMSBDQTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoC\nggEBAMmM2B4PfTXCZjbZMWiDPyxvk/eeNwIRJAhfzesiGUiLozX6CRy3rwC1ZOPV\nAcQf0LB+O8wY88C/cV+d4Q2nBDmnk+Vx7o2MyMh343r5rR3Na+4izd89tkQVt0WW\nvO21KRH5i8EuBjinboOwAwu6IJ+HyiQiM0VjgjrmEr/YzFPL8MgHD/YUHehqjACn\nC0+B7/gu7W4qJzBL2DOf7ub2qszGtwPE+qQzkCRDwE1A4AJmVE++/FLH2Zx78Egg\nfV1sUxPtYgjGH76VyyO6GNKM6rAUMD/q5mnPASQVIXgKbupr618bnH+SWHFjBqZq\nHvDGPMtiiWII41EmGUypyt5AbysCAwEAAaNmMGQwDgYDVR0PAQH/BAQDAgEGMBIG\nA1UdEwEB/wQIMAYBAf8CAQAwHQYDVR0OBBYEFIiKM0Q6n1K4EmLxs3ZXxINbwEwR\nMB8GA1UdIwQYMBaAFE4C7qw+9hXITO0s9QXBj5yECEmDMA0GCSqGSIb3DQEBBQUA\nA4IBAQBezGbE9Rw/k2e25iGjj5n8r+M3dlye8ORfCE/dijHtxqAKasXHgKX8I9Tw\nJkBiGWiuzqn7gO5MJ0nMMro1+gq29qjZnYX1pDHPgsRjUX8R+juRhgJ3JSHijRbf\n4qNJrnwga7pj94MhcLq9u0f6dxH6dXbyMv21T4TZMTmcFduf1KgaiVx1PEyJjC6r\nM+Ru+A0eM+jJ7uCjUoZKcpX8xkj4nmSnz9NMPog3wdOSB9cAW7XIc5mHa656wr7I\nWJxVcYNHTXIjCcng2zMKd1aCcl2KSFfy56sRfT7J5Wp69QSr+jq8KM55gw8uqAwi\nVPrXn2899T1rcTtFYFP16WXjGuc0\n-----END CERTIFICATE-----\n",
        /**
         * Amazon RDS ap-northeast-2 certificate CA 2015 to 2020
         *
         *   CN = Amazon RDS ap-northeast-2 CA
         *   OU = Amazon RDS
         *   O = Amazon Web Services, Inc.
         *   L = Seattle
         *   ST = Washington
         *   C = US
         *   P = 2015-11-06T00:05:46Z/2020-03-05T00:05:46Z
         *   F = 77:D9:33:4E:CE:56:FC:42:7B:29:57:8D:67:59:ED:29:4E:18:CB:6B
         */
        "-----BEGIN CERTIFICATE-----\nMIIEATCCAumgAwIBAgIBTDANBgkqhkiG9w0BAQUFADCBijELMAkGA1UEBhMCVVMx\nEzARBgNVBAgMCldhc2hpbmd0b24xEDAOBgNVBAcMB1NlYXR0bGUxIjAgBgNVBAoM\nGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMx\nGzAZBgNVBAMMEkFtYXpvbiBSRFMgUm9vdCBDQTAeFw0xNTExMDYwMDA1NDZaFw0y\nMDAzMDUwMDA1NDZaMIGUMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2FzaGluZ3Rv\nbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNl\ncywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzElMCMGA1UEAwwcQW1hem9uIFJE\nUyBhcC1ub3J0aGVhc3QtMiBDQTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoC\nggEBAKSwd+RVUzTRH0FgnbwoTK8TMm/zMT4+2BvALpAUe6YXbkisg2goycWuuWLg\njOpFBB3GtyvXZnkqi7MkDWUmj1a2kf8l2oLyoaZ+Hm9x/sV+IJzOqPvj1XVUGjP6\nyYYnPJmUYqvZeI7fEkIGdFkP2m4/sgsSGsFvpD9FK1bL1Kx2UDpYX0kHTtr18Zm/\n1oN6irqWALSmXMDydb8hE0FB2A1VFyeKE6PnoDj/Y5cPHwPPdEi6/3gkDkSaOG30\nrWeQfL3pOcKqzbHaWTxMphd0DSL/quZ64Nr+Ly65Q5PRcTrtr55ekOUziuqXwk+o\n9QpACMwcJ7ROqOznZTqTzSFVXFECAwEAAaNmMGQwDgYDVR0PAQH/BAQDAgEGMBIG\nA1UdEwEB/wQIMAYBAf8CAQAwHQYDVR0OBBYEFM6Nox/QWbhzWVvzoJ/y0kGpNPK+\nMB8GA1UdIwQYMBaAFE4C7qw+9hXITO0s9QXBj5yECEmDMA0GCSqGSIb3DQEBBQUA\nA4IBAQCTkWBqNvyRf3Y/W21DwFx3oT/AIWrHt0BdGZO34tavummXemTH9LZ/mqv9\naljt6ZuDtf5DEQjdsAwXMsyo03ffnP7doWm8iaF1+Mui77ot0TmTsP/deyGwukvJ\ntkxX8bZjDh+EaNauWKr+CYnniNxCQLfFtXYJsfOdVBzK3xNL+Z3ucOQRhr2helWc\nCDQgwfhP1+3pRVKqHvWCPC4R3fT7RZHuRmZ38kndv476GxRntejh+ePffif78bFI\n3rIZCPBGobrrUMycafSbyXteoGca/kA+/IqrAPlk0pWQ4aEL0yTWN2h2dnjoD7oX\nbyIuL/g9AGRh97+ssn7D6bDRPTbW\n-----END CERTIFICATE-----\n",
        /**
         * Amazon RDS ap-southeast-1 certificate CA 2015 to 2020
         *
         *   CN = Amazon RDS ap-southeast-1 CA
         *   OU = Amazon RDS
         *   O = Amazon Web Services, Inc.
         *   L = Seattle
         *   ST = Washington
         *   C = US
         *   P = 2015-02-05T22:03:19Z/2020-03-05T22:03:19Z
         *   F = 0E:EC:5D:BD:F9:80:EE:A9:A0:8D:81:AC:37:D9:8D:34:1C:CD:27:D1
         */
        "-----BEGIN CERTIFICATE-----\nMIIEATCCAumgAwIBAgIBRTANBgkqhkiG9w0BAQUFADCBijELMAkGA1UEBhMCVVMx\nEzARBgNVBAgMCldhc2hpbmd0b24xEDAOBgNVBAcMB1NlYXR0bGUxIjAgBgNVBAoM\nGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMx\nGzAZBgNVBAMMEkFtYXpvbiBSRFMgUm9vdCBDQTAeFw0xNTAyMDUyMjAzMTlaFw0y\nMDAzMDUyMjAzMTlaMIGUMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2FzaGluZ3Rv\nbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNl\ncywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzElMCMGA1UEAwwcQW1hem9uIFJE\nUyBhcC1zb3V0aGVhc3QtMSBDQTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoC\nggEBANaXElmSEYt/UtxHFsARFhSUahTf1KNJzR0Dmay6hqOXQuRVbKRwPd19u5vx\nDdF1sLT7D69IK3VDnUiQScaCv2Dpu9foZt+rLx+cpx1qiQd1UHrvqq8xPzQOqCdC\nRFStq6yVYZ69yfpfoI67AjclMOjl2Vph3ftVnqP0IgVKZdzeC7fd+umGgR9xY0Qr\nUbhd/lWdsbNvzK3f1TPWcfIKQnpvSt85PIEDJir6/nuJUKMtmJRwTymJf0i+JZ4x\n7dJa341p2kHKcHMgOPW7nJQklGBA70ytjUV6/qebS3yIugr/28mwReflg3TJzVDl\nEOvi6pqbqNbkMuEwGDCmEQIVqgkCAwEAAaNmMGQwDgYDVR0PAQH/BAQDAgEGMBIG\nA1UdEwEB/wQIMAYBAf8CAQAwHQYDVR0OBBYEFAu93/4k5xbWOsgdCdn+/KdiRuit\nMB8GA1UdIwQYMBaAFE4C7qw+9hXITO0s9QXBj5yECEmDMA0GCSqGSIb3DQEBBQUA\nA4IBAQBlcjSyscpPjf5+MgzMuAsCxByqUt+WFspwcMCpwdaBeHOPSQrXNqX2Sk6P\nkth6oCivA64trWo8tFMvPYlUA1FYVD5WpN0kCK+P5pD4KHlaDsXhuhClJzp/OP8t\npOyUr5109RHLxqoKB5J5m1XA7rgcFjnMxwBSWFe3/4uMk/+4T53YfCVXuc6QV3i7\nI/2LAJwFf//pTtt6fZenYfCsahnr2nvrNRNyAxcfvGZ/4Opn/mJtR6R/AjvQZHiR\nbkRNKF2GW0ueK5W4FkZVZVhhX9xh1Aj2Ollb+lbOqADaVj+AT3PoJPZ3MPQHKCXm\nxwG0LOLlRr/TfD6li1AfOVTAJXv9\n-----END CERTIFICATE-----\n",
        /**
         * Amazon RDS ap-southeast-2 certificate CA 2015 to 2020
         *
         *   CN = Amazon RDS ap-southeast-2 CA
         *   OU = Amazon RDS
         *   O = Amazon Web Services, Inc.
         *   L = Seattle
         *   ST = Washington
         *   C = US
         *   P = 2015-02-05T22:03:24Z/2020-03-05T22:03:24Z
         *   F = 20:D9:A8:82:23:AB:B9:E5:C5:24:10:D3:4D:0F:3D:B1:31:DF:E5:14
         */
        "-----BEGIN CERTIFICATE-----\nMIIEATCCAumgAwIBAgIBRjANBgkqhkiG9w0BAQUFADCBijELMAkGA1UEBhMCVVMx\nEzARBgNVBAgMCldhc2hpbmd0b24xEDAOBgNVBAcMB1NlYXR0bGUxIjAgBgNVBAoM\nGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMx\nGzAZBgNVBAMMEkFtYXpvbiBSRFMgUm9vdCBDQTAeFw0xNTAyMDUyMjAzMjRaFw0y\nMDAzMDUyMjAzMjRaMIGUMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2FzaGluZ3Rv\nbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNl\ncywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzElMCMGA1UEAwwcQW1hem9uIFJE\nUyBhcC1zb3V0aGVhc3QtMiBDQTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoC\nggEBAJqBAJutz69hFOh3BtLHZTbwE8eejGGKayn9hu98YMDPzWzGXWCmW+ZYWELA\ncY3cNWNF8K4FqKXFr2ssorBYim1UtYFX8yhydT2hMD5zgQ2sCGUpuidijuPA6zaq\nZ3tdhVR94f0q8mpwpv2zqR9PcqaGDx2VR1x773FupRPRo7mEW1vC3IptHCQlP/zE\n7jQiLl28bDIH2567xg7e7E9WnZToRnhlYdTaDaJsHTzi5mwILi4cihSok7Shv/ME\nhnukvxeSPUpaVtFaBhfBqq055ePq9I+Ns4KGreTKMhU0O9fkkaBaBmPaFgmeX/XO\nn2AX7gMouo3mtv34iDTZ0h6YCGkCAwEAAaNmMGQwDgYDVR0PAQH/BAQDAgEGMBIG\nA1UdEwEB/wQIMAYBAf8CAQAwHQYDVR0OBBYEFIlQnY0KHYWn1jYumSdJYfwj/Nfw\nMB8GA1UdIwQYMBaAFE4C7qw+9hXITO0s9QXBj5yECEmDMA0GCSqGSIb3DQEBBQUA\nA4IBAQA0wVU6/l41cTzHc4azc4CDYY2Wd90DFWiH9C/mw0SgToYfCJ/5Cfi0NT/Y\nPRnk3GchychCJgoPA/k9d0//IhYEAIiIDjyFVgjbTkKV3sh4RbdldKVOUB9kumz/\nZpShplsGt3z4QQiVnKfrAgqxWDjR0I0pQKkxXa6Sjkicos9LQxVtJ0XA4ieG1E7z\nzJr+6t80wmzxvkInSaWP3xNJK9azVRTrgQZQlvkbpDbExl4mNTG66VD3bAp6t3Wa\nB49//uDdfZmPkqqbX+hsxp160OH0rxJppwO3Bh869PkDnaPEd/Pxw7PawC+li0gi\nNRV8iCEx85aFxcyOhqn0WZOasxee\n-----END CERTIFICATE-----\n",
        /**
         * Amazon RDS eu-central-1 certificate CA 2015 to 2020
         *
         *   CN = Amazon RDS eu-central-1 CA
         *   OU = Amazon RDS
         *   O = Amazon Web Services, Inc.
         *   L = Seattle
         *   ST = Washington
         *   C = US
         *   P = 2015-02-05T22:03:31Z/2020-03-05T22:03:31Z
         *   F = 94:B4:DF:B9:6D:7E:F7:C3:B7:BF:51:E9:A6:B7:44:A0:D0:82:11:84
         */
        "-----BEGIN CERTIFICATE-----\nMIID/zCCAuegAwIBAgIBRzANBgkqhkiG9w0BAQUFADCBijELMAkGA1UEBhMCVVMx\nEzARBgNVBAgMCldhc2hpbmd0b24xEDAOBgNVBAcMB1NlYXR0bGUxIjAgBgNVBAoM\nGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMx\nGzAZBgNVBAMMEkFtYXpvbiBSRFMgUm9vdCBDQTAeFw0xNTAyMDUyMjAzMzFaFw0y\nMDAzMDUyMjAzMzFaMIGSMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2FzaGluZ3Rv\nbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNl\ncywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEjMCEGA1UEAwwaQW1hem9uIFJE\nUyBldS1jZW50cmFsLTEgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIB\nAQDFtP2dhSLuaPOI4ZrrPWsK4OY9ocQBp3yApH1KJYmI9wpQKZG/KCH2E6Oo7JAw\nQORU519r033T+FO2Z7pFPlmz1yrxGXyHpJs8ySx3Yo5S8ncDCdZJCLmtPiq/hahg\n5/0ffexMFUCQaYicFZsrJ/cStdxUV+tSw2JQLD7UxS9J97LQWUPyyG+ZrjYVTVq+\nzudnFmNSe4QoecXMhAFTGJFQXxP7nhSL9Ao5FGgdXy7/JWeWdQIAj8ku6cBDKPa6\nY6kP+ak+In+Lye8z9qsCD/afUozfWjPR2aA4JoIZVF8dNRShIMo8l0XfgfM2q0+n\nApZWZ+BjhIO5XuoUgHS3D2YFAgMBAAGjZjBkMA4GA1UdDwEB/wQEAwIBBjASBgNV\nHRMBAf8ECDAGAQH/AgEAMB0GA1UdDgQWBBRm4GsWIA/M6q+tK8WGHWDGh2gcyTAf\nBgNVHSMEGDAWgBROAu6sPvYVyEztLPUFwY+chAhJgzANBgkqhkiG9w0BAQUFAAOC\nAQEAHpMmeVQNqcxgfQdbDIi5UIy+E7zZykmtAygN1XQrvga9nXTis4kOTN6g5/+g\nHCx7jIXeNJzAbvg8XFqBN84Quqgpl/tQkbpco9Jh1HDs558D5NnZQxNqH5qXQ3Mm\nuPgCw0pYcPOa7bhs07i+MdVwPBsX27CFDtsgAIru8HvKxY1oTZrWnyIRo93tt/pk\nWuItVMVHjaQZVfTCow0aDUbte6Vlw82KjUFq+n2NMSCJDiDKsDDHT6BJc4AJHIq3\n/4Z52MSC9KMr0yAaaoWfW/yMEj9LliQauAgwVjArF4q78rxpfKTG9Rfd8U1BZANP\n7FrFMN0ThjfA1IvmOYcgskY5bQ==\n-----END CERTIFICATE-----\n",
        /**
         * Amazon RDS eu-west-1 certificate CA 2015 to 2020
         *
         *   CN = Amazon RDS eu-west-1 CA
         *   OU = Amazon RDS
         *   O = Amazon Web Services, Inc.
         *   L = Seattle
         *   ST = Washington
         *   C = US
         *   P = 2015-02-05T22:03:35Z/2020-03-05T22:03:35Z
         *   F = 1A:95:F0:43:82:D2:5D:A6:AD:F5:13:27:0B:40:8A:72:D9:92:F3:E0
         */
        "-----BEGIN CERTIFICATE-----\nMIID/DCCAuSgAwIBAgIBSDANBgkqhkiG9w0BAQUFADCBijELMAkGA1UEBhMCVVMx\nEzARBgNVBAgMCldhc2hpbmd0b24xEDAOBgNVBAcMB1NlYXR0bGUxIjAgBgNVBAoM\nGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMx\nGzAZBgNVBAMMEkFtYXpvbiBSRFMgUm9vdCBDQTAeFw0xNTAyMDUyMjAzMzVaFw0y\nMDAzMDUyMjAzMzVaMIGPMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2FzaGluZ3Rv\nbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNl\ncywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEgMB4GA1UEAwwXQW1hem9uIFJE\nUyBldS13ZXN0LTEgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCx\nPdbqQ0HKRj79Pmocxvjc+P6i4Ux24kgFIl+ckiir1vzkmesc3a58gjrMlCksEObt\nYihs5IhzEq1ePT0gbfS9GYFp34Uj/MtPwlrfCBWG4d2TcrsKRHr1/EXUYhWqmdrb\nRhX8XqoRhVkbF/auzFSBhTzcGGvZpQ2KIaxRcQfcXlMVhj/pxxAjh8U4F350Fb0h\nnX1jw4/KvEreBL0Xb2lnlGTkwVxaKGSgXEnOgIyOFdOQc61vdome0+eeZsP4jqeR\nTGYJA9izJsRbe2YJxHuazD+548hsPlM3vFzKKEVURCha466rAaYAHy3rKur3HYQx\nYt+SoKcEz9PXuSGj96ejAgMBAAGjZjBkMA4GA1UdDwEB/wQEAwIBBjASBgNVHRMB\nAf8ECDAGAQH/AgEAMB0GA1UdDgQWBBTebg//h2oeXbZjQ4uuoiuLYzuiPDAfBgNV\nHSMEGDAWgBROAu6sPvYVyEztLPUFwY+chAhJgzANBgkqhkiG9w0BAQUFAAOCAQEA\nTikPaGeZasTPw+4RBemlsyPAjtFFQLo7ddaFdORLgdEysVf8aBqndvbA6MT/v4lj\nGtEtUdF59ZcbWOrVm+fBZ2h/jYJ59dYF/xzb09nyRbdMSzB9+mkSsnOMqluq5y8o\nDY/PfP2vGhEg/2ZncRC7nlQU1Dm8F4lFWEiQ2fi7O1cW852Vmbq61RIfcYsH/9Ma\nkpgk10VZ75b8m3UhmpZ/2uRY+JEHImH5WpcTJ7wNiPNJsciZMznGtrgOnPzYco8L\ncDleOASIZifNMQi9PKOJKvi0ITz0B/imr8KBsW0YjZVJ54HMa7W1lwugSM7aMAs+\nE3Sd5lS+SHwWaOCHwhOEVA==\n-----END CERTIFICATE-----\n",
        /**
         * Amazon RDS sa-east-1 certificate CA 2015 to 2020
         *
         *   CN = Amazon RDS sa-east-1 CA
         *   OU = Amazon RDS
         *   O = Amazon Web Services, Inc.
         *   L = Seattle
         *   ST = Washington
         *   C = US
         *   P = 2015-02-05T22:03:40Z/2020-03-05T22:03:40Z
         *   F = 32:10:3D:FA:6D:42:F5:35:98:40:15:F4:4C:74:74:27:CB:CE:D4:B5
         */
        "-----BEGIN CERTIFICATE-----\nMIID/DCCAuSgAwIBAgIBSTANBgkqhkiG9w0BAQUFADCBijELMAkGA1UEBhMCVVMx\nEzARBgNVBAgMCldhc2hpbmd0b24xEDAOBgNVBAcMB1NlYXR0bGUxIjAgBgNVBAoM\nGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMx\nGzAZBgNVBAMMEkFtYXpvbiBSRFMgUm9vdCBDQTAeFw0xNTAyMDUyMjAzNDBaFw0y\nMDAzMDUyMjAzNDBaMIGPMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2FzaGluZ3Rv\nbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNl\ncywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEgMB4GA1UEAwwXQW1hem9uIFJE\nUyBzYS1lYXN0LTEgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCU\nX4OBnQ5xA6TLJAiFEI6l7bUWjoVJBa/VbMdCCSs2i2dOKmqUaXu2ix2zcPILj3lZ\nGMk3d/2zvTK/cKhcFrewHUBamTeVHdEmynhMQamqNmkM4ptYzFcvEUw1TGxHT4pV\nQ6gSN7+/AJewQvyHexHo8D0+LDN0/Wa9mRm4ixCYH2CyYYJNKaZt9+EZfNu+PPS4\n8iB0TWH0DgQkbWMBfCRgolLLitAZklZ4dvdlEBS7evN1/7ttBxUK6SvkeeSx3zBl\nww3BlXqc3bvTQL0A+RRysaVyFbvtp9domFaDKZCpMmDFAN/ntx215xmQdrSt+K3F\ncXdGQYHx5q410CAclGnbAgMBAAGjZjBkMA4GA1UdDwEB/wQEAwIBBjASBgNVHRMB\nAf8ECDAGAQH/AgEAMB0GA1UdDgQWBBT6iVWnm/uakS+tEX2mzIfw+8JL0zAfBgNV\nHSMEGDAWgBROAu6sPvYVyEztLPUFwY+chAhJgzANBgkqhkiG9w0BAQUFAAOCAQEA\nFmDD+QuDklXn2EgShwQxV13+txPRuVdOSrutHhoCgMwFWCMtPPtBAKs6KPY7Guvw\nDpJoZSehDiOfsgMirjOWjvfkeWSNvKfjWTVneX7pZD9W5WPnsDBvTbCGezm+v87z\nb+ZM2ZMo98m/wkMcIEAgdSKilR2fuw8rLkAjhYFfs0A7tDgZ9noKwgHvoE4dsrI0\nKZYco6DlP/brASfHTPa2puBLN9McK3v+h0JaSqqm5Ro2Bh56tZkQh8AWy/miuDuK\n3+hNEVdxosxlkM1TPa1DGj0EzzK0yoeerXuH2HX7LlCrrxf6/wdKnjR12PMrLQ4A\npCqkcWw894z6bV9MAvKe6A==\n-----END CERTIFICATE-----\n",
        /**
         * Amazon RDS us-east-1 certificate CA 2015 to 2020
         *
         *   CN = Amazon RDS us-east-1 CA
         *   OU = Amazon RDS
         *   O = Amazon Web Services, Inc.
         *   L = Seattle
         *   ST = Washington
         *   C = US
         *   P = 2015-02-05T21:54:04Z/2020-03-05T21:54:04Z
         *   F = 34:47:8A:90:8A:83:AE:45:DC:B6:16:76:D2:35:EC:E9:75:C6:2C:63
         */
        "-----BEGIN CERTIFICATE-----\nMIID/DCCAuSgAwIBAgIBQzANBgkqhkiG9w0BAQUFADCBijELMAkGA1UEBhMCVVMx\nEzARBgNVBAgMCldhc2hpbmd0b24xEDAOBgNVBAcMB1NlYXR0bGUxIjAgBgNVBAoM\nGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMx\nGzAZBgNVBAMMEkFtYXpvbiBSRFMgUm9vdCBDQTAeFw0xNTAyMDUyMTU0MDRaFw0y\nMDAzMDUyMTU0MDRaMIGPMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2FzaGluZ3Rv\nbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNl\ncywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEgMB4GA1UEAwwXQW1hem9uIFJE\nUyB1cy1lYXN0LTEgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDI\nUIuwh8NusKHk1SqPXcP7OqxY3S/M2ZyQWD3w7Bfihpyyy/fc1w0/suIpX3kbMhAV\n2ESwged2/2zSx4pVnjp/493r4luhSqQYzru78TuPt9bhJIJ51WXunZW2SWkisSaf\nUSYUzVN9ezR/bjXTumSUQaLIouJt3OHLX49s+3NAbUyOI8EdvgBQWD68H1epsC0n\nCI5s+pIktyOZ59c4DCDLQcXErQ+tNbDC++oct1ANd/q8p9URonYwGCGOBy7sbCYq\n9eVHh1Iy2M+SNXddVOGw5EuruvHoCIQyOz5Lz4zSuZA9dRbrfztNOpezCNYu6NKM\nn+hzcvdiyxv77uNm8EaxAgMBAAGjZjBkMA4GA1UdDwEB/wQEAwIBBjASBgNVHRMB\nAf8ECDAGAQH/AgEAMB0GA1UdDgQWBBQSQG3TmMe6Sa3KufaPBa72v4QFDzAfBgNV\nHSMEGDAWgBROAu6sPvYVyEztLPUFwY+chAhJgzANBgkqhkiG9w0BAQUFAAOCAQEA\nL/mOZfB3187xTmjOHMqN2G2oSKHBKiQLM9uv8+97qT+XR+TVsBT6b3yoPpMAGhHA\nPc7nxAF5gPpuzatx0OTLPcmYucFmfqT/1qA5WlgCnMNtczyNMH97lKFTNV7Njtek\njWEzAEQSyEWrkNpNlC4j6kMYyPzVXQeXUeZTgJ9FNnVZqmvfjip2N22tawMjrCn5\n7KN/zN65EwY2oO9XsaTwwWmBu3NrDdMbzJnbxoWcFWj4RBwanR1XjQOVNhDwmCOl\n/1Et13b8CPyj69PC8BOVU6cfTSx8WUVy0qvYOKHNY9Bqa5BDnIL3IVmUkeTlM1mt\nenRpyBj+Bk9rh/ICdiRKmA==\n-----END CERTIFICATE-----\n",
        /**
         * Amazon RDS us-west-1 certificate CA 2015 to 2020
         *
         *   CN = Amazon RDS us-west-1 CA
         *   OU = Amazon RDS
         *   O = Amazon Web Services, Inc.
         *   L = Seattle
         *   ST = Washington
         *   C = US
         *   P = 2015-02-05T22:03:45Z/2020-03-05T22:03:45Z
         *   F = EF:94:2F:E3:58:0E:09:D6:79:C2:16:97:91:FB:37:EA:D7:70:A8:4B
         */
        "-----BEGIN CERTIFICATE-----\nMIID/DCCAuSgAwIBAgIBSjANBgkqhkiG9w0BAQUFADCBijELMAkGA1UEBhMCVVMx\nEzARBgNVBAgMCldhc2hpbmd0b24xEDAOBgNVBAcMB1NlYXR0bGUxIjAgBgNVBAoM\nGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMx\nGzAZBgNVBAMMEkFtYXpvbiBSRFMgUm9vdCBDQTAeFw0xNTAyMDUyMjAzNDVaFw0y\nMDAzMDUyMjAzNDVaMIGPMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2FzaGluZ3Rv\nbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNl\ncywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEgMB4GA1UEAwwXQW1hem9uIFJE\nUyB1cy13ZXN0LTEgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDE\nDhw+uw/ycaiIhhyu2pXFRimq0DlB8cNtIe8hdqndH8TV/TFrljNgR8QdzOgZtZ9C\nzzQ2GRpInN/qJF6slEd6wO+6TaDBQkPY+07TXNt52POFUhdVkhJXHpE2BS7Xn6J7\n7RFAOeG1IZmc2DDt+sR1BgXzUqHslQGfFYNS0/MBO4P+ya6W7IhruB1qfa4HiYQS\ndbe4MvGWnv0UzwAqdR7OF8+8/5c58YXZIXCO9riYF2ql6KNSL5cyDPcYK5VK0+Q9\nVI6vuJHSMYcF7wLePw8jtBktqAFE/wbdZiIHhZvNyiNWPPNTGUmQbaJ+TzQEHDs5\n8en+/W7JKnPyBOkxxENbAgMBAAGjZjBkMA4GA1UdDwEB/wQEAwIBBjASBgNVHRMB\nAf8ECDAGAQH/AgEAMB0GA1UdDgQWBBS0nw/tFR9bCjgqWTPJkyy4oOD8bzAfBgNV\nHSMEGDAWgBROAu6sPvYVyEztLPUFwY+chAhJgzANBgkqhkiG9w0BAQUFAAOCAQEA\nCXGAY3feAak6lHdqj6+YWjy6yyUnLK37bRxZDsyDVXrPRQaXRzPTzx79jvDwEb/H\nQ/bdQ7zQRWqJcbivQlwhuPJ4kWPUZgSt3JUUuqkMsDzsvj/bwIjlrEFDOdHGh0mi\neVIngFEjUXjMh+5aHPEF9BlQnB8LfVtKj18e15UDTXFa+xJPFxUR7wDzCfo4WI1m\nsUMG4q1FkGAZgsoyFPZfF8IVvgCuGdR8z30VWKklFxttlK0eGLlPAyIO0CQxPQlo\nsaNJrHf4tLOgZIWk+LpDhNd9Et5EzvJ3aURUsKY4pISPPF5WdvM9OE59bERwUErd\nnuOuQWQeeadMceZnauRzJQ==\n-----END CERTIFICATE-----\n",
        /**
         * Amazon RDS us-west-2 certificate CA 2015 to 2020
         *
         *   CN = Amazon RDS us-west-2 CA
         *   OU = Amazon RDS
         *   O = Amazon Web Services, Inc.
         *   L = Seattle
         *   ST = Washington
         *   C = US
         *   P = 2015-02-05T22:03:50Z/2020-03-05T22:03:50Z
         *   F = 94:2C:A8:B0:23:48:17:F0:CD:2F:19:7F:C1:E0:21:7C:65:79:13:3A
         */
        "-----BEGIN CERTIFICATE-----\nMIID/DCCAuSgAwIBAgIBSzANBgkqhkiG9w0BAQUFADCBijELMAkGA1UEBhMCVVMx\nEzARBgNVBAgMCldhc2hpbmd0b24xEDAOBgNVBAcMB1NlYXR0bGUxIjAgBgNVBAoM\nGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMx\nGzAZBgNVBAMMEkFtYXpvbiBSRFMgUm9vdCBDQTAeFw0xNTAyMDUyMjAzNTBaFw0y\nMDAzMDUyMjAzNTBaMIGPMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2FzaGluZ3Rv\nbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNl\ncywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEgMB4GA1UEAwwXQW1hem9uIFJE\nUyB1cy13ZXN0LTIgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDM\nH58SR48U6jyERC1vYTnub34smf5EQVXyzaTmspWGWGzT31NLNZGSDFaa7yef9kdO\nmzJsgebR5tXq6LdwlIoWkKYQ7ycUaadtVKVYdI40QcI3cHn0qLFlg2iBXmWp/B+i\nZ34VuVlCh31Uj5WmhaBoz8t/GRqh1V/aCsf3Wc6jCezH3QfuCjBpzxdOOHN6Ie2v\nxX09O5qmZTvMoRBAvPkxdaPg/Mi7fxueWTbEVk78kuFbF1jHYw8U1BLILIAhcqlq\nx4u8nl73t3O3l/soNUcIwUDK0/S+Kfqhwn9yQyPlhb4Wy3pfnZLJdkyHldktnQav\n9TB9u7KH5Lk0aAYslMLxAgMBAAGjZjBkMA4GA1UdDwEB/wQEAwIBBjASBgNVHRMB\nAf8ECDAGAQH/AgEAMB0GA1UdDgQWBBT8roM4lRnlFHWMPWRz0zkwFZog1jAfBgNV\nHSMEGDAWgBROAu6sPvYVyEztLPUFwY+chAhJgzANBgkqhkiG9w0BAQUFAAOCAQEA\nJwrxwgwmPtcdaU7O7WDdYa4hprpOMamI49NDzmE0s10oGrqmLwZygcWU0jT+fJ+Y\npJe1w0CVfKaeLYNsOBVW3X4ZPmffYfWBheZiaiEflq/P6t7/Eg81gaKYnZ/x1Dfa\nsUYkzPvCkXe9wEz5zdUTOCptDt89rBR9CstL9vE7WYUgiVVmBJffWbHQLtfjv6OF\nNMb0QME981kGRzc2WhgP71YS2hHd1kXtsoYP1yTu4vThSKsoN4bkiHsaC1cRkLoy\n0fFA4wpB3WloMEvCDaUvvH1LZlBXTNlwi9KtcwD4tDxkkBt4tQczKLGpQ/nF/W9n\n8YDWk3IIc1sd0bkZqoau2Q==\n-----END CERTIFICATE-----\n",
        /**
         * Amazon RDS ap-south-1 certificate CA 2016 to 2020
         *
         *   CN = Amazon RDS ap-south-1 CA
         *   OU = Amazon RDS
         *   O = Amazon Web Services, Inc.
         *   L = Seattle
         *   ST = Washington
         *   C = US
         *   P = 2016-05-03T21:29:22Z/2020-03-05T21:29:22Z
         *   F = F3:A3:C2:52:D9:82:20:AC:8C:62:31:2A:8C:AD:5D:7B:1C:31:F1:DD
         */
        "-----BEGIN CERTIFICATE-----\nMIID/TCCAuWgAwIBAgIBTTANBgkqhkiG9w0BAQsFADCBijELMAkGA1UEBhMCVVMx\nEzARBgNVBAgMCldhc2hpbmd0b24xEDAOBgNVBAcMB1NlYXR0bGUxIjAgBgNVBAoM\nGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMx\nGzAZBgNVBAMMEkFtYXpvbiBSRFMgUm9vdCBDQTAeFw0xNjA1MDMyMTI5MjJaFw0y\nMDAzMDUyMTI5MjJaMIGQMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2FzaGluZ3Rv\nbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNl\ncywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEhMB8GA1UEAwwYQW1hem9uIFJE\nUyBhcC1zb3V0aC0xIENBMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA\n06eWGLE0TeqL9kyWOLkS8q0fXO97z+xyBV3DKSB2lg2GkgBz3B98MkmkeB0SZy3G\nCe4uCpCPbFKiFEdiUclOlhZsrBuCeaimxLM3Ig2wuenElO/7TqgaYHYUbT3d+VQW\nGUbLn5GRZJZe1OAClYdOWm7A1CKpuo+cVV1vxbY2nGUQSJPpVn2sT9gnwvjdE60U\nJGYU/RLCTm8zmZBvlWaNIeKDnreIc4rKn6gUnJ2cQn1ryCVleEeyc3xjYDSrjgdn\nFLYGcp9mphqVT0byeQMOk0c7RHpxrCSA0V5V6/CreFV2LteK50qcDQzDSM18vWP/\np09FoN8O7QrtOeZJzH/lmwIDAQABo2YwZDAOBgNVHQ8BAf8EBAMCAQYwEgYDVR0T\nAQH/BAgwBgEB/wIBADAdBgNVHQ4EFgQU2i83QHuEl/d0keXF+69HNJph7cMwHwYD\nVR0jBBgwFoAUTgLurD72FchM7Sz1BcGPnIQISYMwDQYJKoZIhvcNAQELBQADggEB\nACqnH2VjApoDqoSQOky52QBwsGaj+xWYHW5Gm7EvCqvQuhWMkeBuD6YJmMvNyA9G\nI2lh6/o+sUk/RIsbYbxPRdhNPTOgDR9zsNRw6qxaHztq/CEC+mxDCLa3O1hHBaDV\nBmB3nCZb93BvO0EQSEk7aytKq/f+sjyxqOcs385gintdHGU9uM7gTZHnU9vByJsm\n/TL07Miq67X0NlhIoo3jAk+xHaeKJdxdKATQp0448P5cY20q4b8aMk1twcNaMvCP\ndG4M5doaoUA8OQ/0ukLLae/LBxLeTw04q1/a2SyFaVUX2Twbb1S3xVWwLA8vsyGr\nigXx7B5GgP+IHb6DTjPJAi0=\n-----END CERTIFICATE-----\n",
        /**
         * Amazon RDS us-east-2 certificate CA 2016 to 2020
         *
         *   CN = Amazon RDS us-east-2 CA
         *   OU = Amazon RDS
         *   O = Amazon Web Services, Inc.
         *   L = Seattle
         *   ST = Washington
         *   C = US
         *   P = 2016-08-11T19:58:45Z/2020-03-05T19:58:45Z
         *   F = 9B:78:E3:64:7F:74:BC:B2:52:18:CF:13:C3:62:B8:35:9D:3D:5F:B6
         */
        "-----BEGIN CERTIFICATE-----\nMIID/DCCAuSgAwIBAgIBTjANBgkqhkiG9w0BAQsFADCBijELMAkGA1UEBhMCVVMx\nEzARBgNVBAgMCldhc2hpbmd0b24xEDAOBgNVBAcMB1NlYXR0bGUxIjAgBgNVBAoM\nGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMx\nGzAZBgNVBAMMEkFtYXpvbiBSRFMgUm9vdCBDQTAeFw0xNjA4MTExOTU4NDVaFw0y\nMDAzMDUxOTU4NDVaMIGPMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2FzaGluZ3Rv\nbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNl\ncywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEgMB4GA1UEAwwXQW1hem9uIFJE\nUyB1cy1lYXN0LTIgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCp\nWnnUX7wM0zzstccX+4iXKJa9GR0a2PpvB1paEX4QRCgfhEdQWDaSqyrWNgdVCKkt\n1aQkWu5j6VAC2XIG7kKoonm1ZdBVyBLqW5lXNywlaiU9yhJkwo8BR+/OqgE+PLt/\nEO1mlN0PQudja/XkExCXTO29TG2j7F/O7hox6vTyHNHc0H88zS21uPuBE+jivViS\nyzj/BkyoQ85hnkues3f9R6gCGdc+J51JbZnmgzUkvXjAEuKhAm9JksVOxcOKUYe5\nERhn0U9zjzpfbAITIkul97VVa5IxskFFTHIPJbvRKHJkiF6wTJww/tc9wm+fSCJ1\n+DbQTGZgkQ3bJrqRN29/AgMBAAGjZjBkMA4GA1UdDwEB/wQEAwIBBjASBgNVHRMB\nAf8ECDAGAQH/AgEAMB0GA1UdDgQWBBSAHQzUYYZbepwKEMvGdHp8wzHnfDAfBgNV\nHSMEGDAWgBROAu6sPvYVyEztLPUFwY+chAhJgzANBgkqhkiG9w0BAQsFAAOCAQEA\nMbaEzSYZ+aZeTBxf8yi0ta8K4RdwEJsEmP6IhFFQHYUtva2Cynl4Q9tZg3RMsybT\n9mlnSQQlbN/wqIIXbkrcgFcHoXG9Odm/bDtUwwwDaiEhXVfeQom3G77QHOWMTCGK\nqadwuh5msrb17JdXZoXr4PYHDKP7j0ONfAyFNER2+uecblHfRSpVq5UeF3L6ZJb8\nfSw/GtAV6an+/0r+Qm+PiI2H5XuZ4GmRJYnGMhqWhBYrY7p3jtVnKcsh39wgfUnW\nAvZEZG/yhFyAZW0Essa39LiL5VSq14Y1DOj0wgnhSY/9WHxaAo1HB1T9OeZknYbD\nfl/EGSZ0TEvZkENrXcPlVA==\n-----END CERTIFICATE-----\n",
        /**
         * Amazon RDS ca-central-1 certificate CA 2016 to 2020
         *
         *   CN = Amazon RDS ca-central-1 CA
         *   OU = Amazon RDS
         *   O = Amazon Web Services, Inc.
         *   L = Seattle
         *   ST = Washington
         *   C = US
         *   P = 2016-09-15T00:10:11Z/2020-03-05T00:10:11Z
         *   F = D7:E0:16:AB:8A:0B:63:9F:67:1F:16:87:42:F4:0A:EE:73:A6:FC:04
         */
        "-----BEGIN CERTIFICATE-----\nMIID/zCCAuegAwIBAgIBTzANBgkqhkiG9w0BAQsFADCBijELMAkGA1UEBhMCVVMx\nEzARBgNVBAgMCldhc2hpbmd0b24xEDAOBgNVBAcMB1NlYXR0bGUxIjAgBgNVBAoM\nGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMx\nGzAZBgNVBAMMEkFtYXpvbiBSRFMgUm9vdCBDQTAeFw0xNjA5MTUwMDEwMTFaFw0y\nMDAzMDUwMDEwMTFaMIGSMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2FzaGluZ3Rv\nbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNl\ncywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEjMCEGA1UEAwwaQW1hem9uIFJE\nUyBjYS1jZW50cmFsLTEgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIB\nAQCZYI/iQ6DrS3ny3t1EwX1wAD+3LMgh7Fd01EW5LIuaK2kYIIQpsVKhxLCit/V5\nAGc/1qiJS1Qz9ODLTh0Na6bZW6EakRzuHJLe32KJtoFYPC7Z09UqzXrpA/XL+1hM\nP0ZmCWsU7Nn/EmvfBp9zX3dZp6P6ATrvDuYaVFr+SA7aT3FXpBroqBS1fyzUPs+W\nc6zTR6+yc4zkHX0XQxC5RH6xjgpeRkoOajA/sNo7AQF7KlWmKHbdVF44cvvAhRKZ\nXaoVs/C4GjkaAEPTCbopYdhzg+KLx9eB2BQnYLRrIOQZtRfbQI2Nbj7p3VsRuOW1\ntlcks2w1Gb0YC6w6SuIMFkl1AgMBAAGjZjBkMA4GA1UdDwEB/wQEAwIBBjASBgNV\nHRMBAf8ECDAGAQH/AgEAMB0GA1UdDgQWBBToYWxE1lawl6Ks6NsvpbHQ3GKEtzAf\nBgNVHSMEGDAWgBROAu6sPvYVyEztLPUFwY+chAhJgzANBgkqhkiG9w0BAQsFAAOC\nAQEAG/8tQ0ooi3hoQpa5EJz0/E5VYBsAz3YxA2HoIonn0jJyG16bzB4yZt4vNQMA\nKsNlQ1uwDWYL1nz63axieUUFIxqxl1KmwfhsmLgZ0Hd2mnTPIl2Hw3uj5+wdgGBg\nagnAZ0bajsBYgD2VGQbqjdk2Qn7Fjy3LEWIvGZx4KyZ99OJ2QxB7JOPdauURAtWA\nDKYkP4LLJxtj07DSzG8kuRWb9B47uqUD+eKDIyjfjbnzGtd9HqqzYFau7EX3HVD9\n9Qhnjl7bTZ6YfAEZ3nH2t3Vc0z76XfGh47rd0pNRhMV+xpok75asKf/lNh5mcUrr\nVKwflyMkQpSbDCmcdJ90N2xEXQ==\n-----END CERTIFICATE-----\n",
        /**
         * Amazon RDS eu-west-2 certificate CA 2016 to 2020
         *
         *   CN = Amazon RDS eu-west-2 CA
         *   OU = Amazon RDS
         *   O = Amazon Web Services, Inc.
         *   L = Seattle
         *   ST = Washington
         *   C = US
         *   P = 2016-10-10T17:44:42Z/2020-03-05T17:44:42Z
         *   F = 47:79:51:9F:FF:07:D3:F4:27:D3:AB:64:56:7F:00:45:BB:84:C1:71
         */
        "-----BEGIN CERTIFICATE-----\nMIID/DCCAuSgAwIBAgIBUDANBgkqhkiG9w0BAQsFADCBijELMAkGA1UEBhMCVVMx\nEzARBgNVBAgMCldhc2hpbmd0b24xEDAOBgNVBAcMB1NlYXR0bGUxIjAgBgNVBAoM\nGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMx\nGzAZBgNVBAMMEkFtYXpvbiBSRFMgUm9vdCBDQTAeFw0xNjEwMTAxNzQ0NDJaFw0y\nMDAzMDUxNzQ0NDJaMIGPMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2FzaGluZ3Rv\nbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNl\ncywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEgMB4GA1UEAwwXQW1hem9uIFJE\nUyBldS13ZXN0LTIgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDO\ncttLJfubB4XMMIGWNfJISkIdCMGJyOzLiMJaiWB5GYoXKhEl7YGotpy0qklwW3BQ\na0fmVdcCLX+dIuVQ9iFK+ZcK7zwm7HtdDTCHOCKeOh2IcnU4c/VIokFi6Gn8udM6\nN/Zi5M5OGpVwLVALQU7Yctsn3c95el6MdVx6mJiIPVu7tCVZn88Z2koBQ2gq9P4O\nSb249SHFqOb03lYDsaqy1NDsznEOhaRBw7DPJFpvmw1lA3/Y6qrExRI06H2VYR2i\n7qxwDV50N58fs10n7Ye1IOxTVJsgEA7X6EkRRXqYaM39Z76R894548WHfwXWjUsi\nMEX0RS0/t1GmnUQjvevDAgMBAAGjZjBkMA4GA1UdDwEB/wQEAwIBBjASBgNVHRMB\nAf8ECDAGAQH/AgEAMB0GA1UdDgQWBBQBxmcuRSxERYCtNnSr5xNfySokHjAfBgNV\nHSMEGDAWgBROAu6sPvYVyEztLPUFwY+chAhJgzANBgkqhkiG9w0BAQsFAAOCAQEA\nUyCUQjsF3nUAABjfEZmpksTuUo07aT3KGYt+EMMFdejnBQ0+2lJJFGtT+CDAk1SD\nRSgfEBon5vvKEtlnTf9a3pv8WXOAkhfxnryr9FH6NiB8obISHNQNPHn0ljT2/T+I\nY6ytfRvKHa0cu3V0NXbJm2B4KEOt4QCDiFxUIX9z6eB4Kditwu05OgQh6KcogOiP\nJesWxBMXXGoDC1rIYTFO7szwDyOHlCcVXJDNsTJhc32oDWYdeIbW7o/5I+aQsrXZ\nC96HykZcgWzz6sElrQxUaT3IoMw/5nmw4uWKKnZnxgI9bY4fpQwMeBZ96iHfFxvH\nmqfEEuC7uUoPofXdBp2ObQ==\n-----END CERTIFICATE-----\n",
        /**
         * Amazon RDS us-gov-west-1 CA 2017 to 2022
         *
         *   CN = Amazon RDS us-gov-west-1 CA
         *   OU = Amazon RDS
         *   O = Amazon Web Services, Inc.
         *   L = Seattle
         *   ST = Washington
         *   C = US
         *   P = 2017-05-19T22:31:19Z/2022-05-18T12:00:00Z
         *   F = 77:55:8C:C4:5E:71:1F:1B:57:E3:DA:6E:5B:74:27:12:4E:E8:69:E8
         */
        "-----BEGIN CERTIFICATE-----\nMIIECjCCAvKgAwIBAgICEAAwDQYJKoZIhvcNAQELBQAwgZMxCzAJBgNVBAYTAlVT\nMRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\nDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\nMSQwIgYDVQQDDBtBbWF6b24gUkRTIEdvdkNsb3VkIFJvb3QgQ0EwHhcNMTcwNTE5\nMjIzMTE5WhcNMjIwNTE4MTIwMDAwWjCBkzELMAkGA1UEBhMCVVMxEzARBgNVBAgM\nCldhc2hpbmd0b24xEDAOBgNVBAcMB1NlYXR0bGUxIjAgBgNVBAoMGUFtYXpvbiBX\nZWIgU2VydmljZXMsIEluYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxJDAiBgNVBAMM\nG0FtYXpvbiBSRFMgdXMtZ292LXdlc3QtMSBDQTCCASIwDQYJKoZIhvcNAQEBBQAD\nggEPADCCAQoCggEBAM8YZLKAzzOdNnoi7Klih26Zkj+OCpDfwx4ZYB6f8L8UoQi5\n8z9ZtIwMjiJ/kO08P1yl4gfc7YZcNFvhGruQZNat3YNpxwUpQcr4mszjuffbL4uz\n+/8FBxALdqCVOJ5Q0EVSfz3d9Bd1pUPL7ARtSpy7bn/tUPyQeI+lODYO906C0TQ3\nb9bjOsgAdBKkHfjLdsknsOZYYIzYWOJyFJJa0B11XjDUNBy/3IuC0KvDl6At0V5b\n8M6cWcKhte2hgjwTYepV+/GTadeube1z5z6mWsN5arOAQUtYDLH6Aztq9mCJzLHm\nRccBugnGl3fRLJ2VjioN8PoGoN9l9hFBy5fnFgsCAwEAAaNmMGQwDgYDVR0PAQH/\nBAQDAgEGMBIGA1UdEwEB/wQIMAYBAf8CAQAwHQYDVR0OBBYEFEG7+br8KkvwPd5g\n71Rvh2stclJbMB8GA1UdIwQYMBaAFEkQz6S4NS5lOYKcDjBSuCcVpdzjMA0GCSqG\nSIb3DQEBCwUAA4IBAQBMA327u5ABmhX+aPxljoIbxnydmAFWxW6wNp5+rZrvPig8\nzDRqGQWWr7wWOIjfcWugSElYtf/m9KZHG/Z6+NG7nAoUrdcd1h/IQhb+lFQ2b5g9\nsVzQv/H2JNkfZA8fL/Ko/Tm/f9tcqe0zrGCtT+5u0Nvz35Wl8CEUKLloS5xEb3k5\n7D9IhG3fsE3vHWlWrGCk1cKry3j12wdPG5cUsug0vt34u6rdhP+FsM0tHI15Kjch\nRuUCvyQecy2ZFNAa3jmd5ycNdL63RWe8oayRBpQBxPPCbHfILxGZEdJbCH9aJ2D/\nl8oHIDnvOLdv7/cBjyYuvmprgPtu3QEkbre5Hln/\n-----END CERTIFICATE-----\n",
        /**
         * Amazon RDS eu-west-3 certificate CA 2017 to 2020
         *
         *   CN = Amazon RDS eu-west-3 CA
         *   OU = Amazon RDS
         *   O = Amazon Web Services, Inc.
         *   L = Seattle
         *   ST = Washington
         *   C = US
         *   P = 2017-08-25T21:39:26Z/2020-03-05T21:39:26Z
         *   F = FD:35:A7:84:60:68:98:00:12:54:ED:34:26:8C:66:0F:72:DD:B2:F4
         */
        "-----BEGIN CERTIFICATE-----\nMIID/DCCAuSgAwIBAgIBUTANBgkqhkiG9w0BAQsFADCBijELMAkGA1UEBhMCVVMx\nEzARBgNVBAgMCldhc2hpbmd0b24xEDAOBgNVBAcMB1NlYXR0bGUxIjAgBgNVBAoM\nGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMx\nGzAZBgNVBAMMEkFtYXpvbiBSRFMgUm9vdCBDQTAeFw0xNzA4MjUyMTM5MjZaFw0y\nMDAzMDUyMTM5MjZaMIGPMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2FzaGluZ3Rv\nbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNl\ncywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEgMB4GA1UEAwwXQW1hem9uIFJE\nUyBldS13ZXN0LTMgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQC+\nxmlEC/3a4cJH+UPwXCE02lC7Zq5NHd0dn6peMeLN8agb6jW4VfSY0NydjRj2DJZ8\nK7wV6sub5NUGT1NuFmvSmdbNR2T59KX0p2dVvxmXHHtIpQ9Y8Aq3ZfhmC5q5Bqgw\ntMA1xayDi7HmoPX3R8kk9ktAZQf6lDeksCvok8idjTu9tiSpDiMwds5BjMsWfyjZ\nd13PTGGNHYVdP692BSyXzSP1Vj84nJKnciW8tAqwIiadreJt5oXyrCXi8ekUMs80\ncUTuGm3aA3Q7PB5ljJMPqz0eVddaiIvmTJ9O3Ez3Du/HpImyMzXjkFaf+oNXf/Hx\n/EW5jCRR6vEiXJcDRDS7AgMBAAGjZjBkMA4GA1UdDwEB/wQEAwIBBjASBgNVHRMB\nAf8ECDAGAQH/AgEAMB0GA1UdDgQWBBRZ9mRtS5fHk3ZKhG20Oack4cAqMTAfBgNV\nHSMEGDAWgBROAu6sPvYVyEztLPUFwY+chAhJgzANBgkqhkiG9w0BAQsFAAOCAQEA\nF/u/9L6ExQwD73F/bhCw7PWcwwqsK1mypIdrjdIsu0JSgwWwGCXmrIspA3n3Dqxq\nsMhAJD88s9Em7337t+naar2VyLO63MGwjj+vA4mtvQRKq8ScIpiEc7xN6g8HUMsd\ngPG9lBGfNjuAZsrGJflrko4HyuSM7zHExMjXLH+CXcv/m3lWOZwnIvlVMa4x0Tz0\nA4fklaawryngzeEjuW6zOiYCzjZtPlP8Fw0SpzppJ8VpQfrZ751RDo4yudmPqoPK\n5EUe36L8U+oYBXnC5TlYs9bpVv9o5wJQI5qA9oQE2eFWxF1E0AyZ4V5sgGUBStaX\nBjDDWul0wSo7rt1Tq7XpnA==\n-----END CERTIFICATE-----\n",
        /**
         * Amazon RDS ap-northeast-3 certificate CA 2017 to 2020
         *
         *   CN = Amazon RDS ap-northeast-3 CA
         *   OU = Amazon RDS
         *   O = Amazon Web Services, Inc.
         *   L = Seattle
         *   ST = Washington
         *   C = US
         *   P = 2017-12-01T00:55:42Z/2020-03-05T00:55:42Z
         *   F = C0:C7:D4:B3:91:40:A0:77:43:28:BF:AF:77:57:DF:FD:98:FB:10:3F
         */
        "-----BEGIN CERTIFICATE-----\nMIIEATCCAumgAwIBAgIBTjANBgkqhkiG9w0BAQUFADCBijELMAkGA1UEBhMCVVMx\nEzARBgNVBAgMCldhc2hpbmd0b24xEDAOBgNVBAcMB1NlYXR0bGUxIjAgBgNVBAoM\nGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMx\nGzAZBgNVBAMMEkFtYXpvbiBSRFMgUm9vdCBDQTAeFw0xNzEyMDEwMDU1NDJaFw0y\nMDAzMDUwMDU1NDJaMIGUMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2FzaGluZ3Rv\nbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNl\ncywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzElMCMGA1UEAwwcQW1hem9uIFJE\nUyBhcC1ub3J0aGVhc3QtMyBDQTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoC\nggEBAMZtQNnm/XT19mTa10ftHLzg5UhajoI65JHv4TQNdGXdsv+CQdGYU49BJ9Eu\n3bYgiEtTzR2lQe9zGMvtuJobLhOWuavzp7IixoIQcHkFHN6wJ1CvqrxgvJfBq6Hy\nEuCDCiU+PPDLUNA6XM6Qx3IpHd1wrJkjRB80dhmMSpxmRmx849uFafhN+P1QybsM\nTI0o48VON2+vj+mNuQTyLMMP8D4odSQHjaoG+zyJfJGZeAyqQyoOUOFEyQaHC3TT\n3IDSNCQlpxb9LerbCoKu79WFBBq3CS5cYpg8/fsnV2CniRBFFUumBt5z4dhw9RJU\nqlUXXO1ZyzpGd+c5v6FtrfXtnIUCAwEAAaNmMGQwDgYDVR0PAQH/BAQDAgEGMBIG\nA1UdEwEB/wQIMAYBAf8CAQAwHQYDVR0OBBYEFETv7ELNplYy/xTeIOInl6nzeiHg\nMB8GA1UdIwQYMBaAFE4C7qw+9hXITO0s9QXBj5yECEmDMA0GCSqGSIb3DQEBBQUA\nA4IBAQCpKxOQcd0tEKb3OtsOY8q/MPwTyustGk2Rt7t9G68idADp8IytB7M0SDRo\nwWZqynEq7orQVKdVOanhEWksNDzGp0+FPAf/KpVvdYCd7ru3+iI+V4ZEp2JFdjuZ\nZz0PIjS6AgsZqE5Ri1J+NmfmjGZCPhsHnGZiBaenX6K5VRwwwmLN6xtoqrrfR5zL\nQfBeeZNJG6KiM3R/DxJ5rAa6Fz+acrhJ60L7HprhB7SFtj1RCijau3+ZwiGmUOMr\nyKlMv+VgmzSw7o4Hbxy1WVrA6zQsTHHSGf+vkQn2PHvnFMUEu/ZLbTDYFNmTLK91\nK6o4nMsEvhBKgo4z7H1EqqxXhvN2\n-----END CERTIFICATE-----\n",
        /**
         * Amazon RDS GovCloud Root CA 2017 to 2022
         *
         *   CN = Amazon RDS GovCloud Root CA
         *   OU = Amazon RDS
         *   O = Amazon Web Services, Inc.
         *   L = Seattle
         *   ST = Washington
         *   C = US
         *   P = 2017-05-19T22:29:11Z/2022-05-18T22:29:11Z
         *   F = A3:61:F9:C9:A2:5B:91:FE:73:A6:52:E3:59:14:8E:CE:35:12:0F:FD
         */
        "-----BEGIN CERTIFICATE-----\nMIIEDjCCAvagAwIBAgIJAMM61RQn3/kdMA0GCSqGSIb3DQEBCwUAMIGTMQswCQYD\nVQQGEwJVUzEQMA4GA1UEBwwHU2VhdHRsZTETMBEGA1UECAwKV2FzaGluZ3RvbjEi\nMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1h\nem9uIFJEUzEkMCIGA1UEAwwbQW1hem9uIFJEUyBHb3ZDbG91ZCBSb290IENBMB4X\nDTE3MDUxOTIyMjkxMVoXDTIyMDUxODIyMjkxMVowgZMxCzAJBgNVBAYTAlVTMRAw\nDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQKDBlB\nbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMSQw\nIgYDVQQDDBtBbWF6b24gUkRTIEdvdkNsb3VkIFJvb3QgQ0EwggEiMA0GCSqGSIb3\nDQEBAQUAA4IBDwAwggEKAoIBAQDGS9bh1FGiJPT+GRb3C5aKypJVDC1H2gbh6n3u\nj8cUiyMXfmm+ak402zdLpSYMaxiQ7oL/B3wEmumIpRDAsQrSp3B/qEeY7ipQGOfh\nq2TXjXGIUjiJ/FaoGqkymHRLG+XkNNBtb7MRItsjlMVNELXECwSiMa3nJL2/YyHW\nnTr1+11/weeZEKgVbCUrOugFkMXnfZIBSn40j6EnRlO2u/NFU5ksK5ak2+j8raZ7\nxW7VXp9S1Tgf1IsWHjGZZZguwCkkh1tHOlHC9gVA3p63WecjrIzcrR/V27atul4m\ntn56s5NwFvYPUIx1dbC8IajLUrepVm6XOwdQCfd02DmOyjWJAgMBAAGjYzBhMA4G\nA1UdDwEB/wQEAwIBBjAPBgNVHRMBAf8EBTADAQH/MB0GA1UdDgQWBBRJEM+kuDUu\nZTmCnA4wUrgnFaXc4zAfBgNVHSMEGDAWgBRJEM+kuDUuZTmCnA4wUrgnFaXc4zAN\nBgkqhkiG9w0BAQsFAAOCAQEAcfA7uirXsNZyI2j4AJFVtOTKOZlQwqbyNducnmlg\n/5nug9fAkwM4AgvF5bBOD1Hw6khdsccMwIj+1S7wpL+EYb/nSc8G0qe1p/9lZ/mZ\nff5g4JOa26lLuCrZDqAk4TzYnt6sQKfa5ZXVUUn0BK3okhiXS0i+NloMyaBCL7vk\nkDwkHwEqflRKfZ9/oFTcCfoiHPA7AdBtaPVr0/Kj9L7k+ouz122huqG5KqX0Zpo8\nS0IGvcd2FZjNSNPttNAK7YuBVsZ0m2nIH1SLp//00v7yAHIgytQwwB17PBcp4NXD\npCfTa27ng9mMMC2YLqWQpW4TkqjDin2ZC+5X/mbrjzTvVg==\n-----END CERTIFICATE-----\n",
        /**
         * Amazon RDS ap-east-1 certificate CA 2019 to 2022
         *
         *   CN = Amazon RDS ap-east-1 CA
         *   OU = Amazon RDS
         *   O = Amazon Web Services, Inc.
         *   L = Seattle
         *   ST = Washington
         *   C = US
         *   P = 2019-02-17T02:47:00Z/2022-06-01T12:00:00Z
         *   F = BC:F8:70:75:1F:93:3F:A7:82:86:67:63:A8:86:1F:A4:E8:07:CE:06
         */
        "-----BEGIN CERTIFICATE-----\nMIIEBzCCAu+gAwIBAgICEAAwDQYJKoZIhvcNAQELBQAwgZQxCzAJBgNVBAYTAlVT\nMRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\nDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\nMSUwIwYDVQQDDBxBbWF6b24gUkRTIGFwLWVhc3QtMSBSb290IENBMB4XDTE5MDIx\nNzAyNDcwMFoXDTIyMDYwMTEyMDAwMFowgY8xCzAJBgNVBAYTAlVTMRMwEQYDVQQI\nDApXYXNoaW5ndG9uMRAwDgYDVQQHDAdTZWF0dGxlMSIwIAYDVQQKDBlBbWF6b24g\nV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMSAwHgYDVQQD\nDBdBbWF6b24gUkRTIGFwLWVhc3QtMSBDQTCCASIwDQYJKoZIhvcNAQEBBQADggEP\nADCCAQoCggEBAOcJAUofyJuBuPr5ISHi/Ha5ed8h3eGdzn4MBp6rytPOg9NVGRQs\nO93fNGCIKsUT6gPuk+1f1ncMTV8Y0Fdf4aqGWme+Khm3ZOP3V1IiGnVq0U2xiOmn\nSQ4Q7LoeQC4lC6zpoCHVJyDjZ4pAknQQfsXb77Togdt/tK5ahev0D+Q3gCwAoBoO\nDHKJ6t820qPi63AeGbJrsfNjLKiXlFPDUj4BGir4dUzjEeH7/hx37na1XG/3EcxP\n399cT5k7sY/CR9kctMlUyEEUNQOmhi/ly1Lgtihm3QfjL6K9aGLFNwX35Bkh9aL2\nF058u+n8DP/dPeKUAcJKiQZUmzuen5n57x8CAwEAAaNmMGQwDgYDVR0PAQH/BAQD\nAgEGMBIGA1UdEwEB/wQIMAYBAf8CAQAwHQYDVR0OBBYEFFlqgF4FQlb9yP6c+Q3E\nO3tXv+zOMB8GA1UdIwQYMBaAFK9T6sY/PBZVbnHcNcQXf58P4OuPMA0GCSqGSIb3\nDQEBCwUAA4IBAQDeXiS3v1z4jWAo1UvVyKDeHjtrtEH1Rida1eOXauFuEQa5tuOk\nE53Os4haZCW4mOlKjigWs4LN+uLIAe1aFXGo92nGIqyJISHJ1L+bopx/JmIbHMCZ\n0lTNJfR12yBma5VQy7vzeFku/SisKwX0Lov1oHD4MVhJoHbUJYkmAjxorcIHORvh\nI3Vj5XrgDWtLDPL8/Id/roul/L+WX5ir+PGScKBfQIIN2lWdZoqdsx8YWqhm/ikL\nC6qNieSwcvWL7C03ri0DefTQMY54r5wP33QU5hJ71JoaZI3YTeT0Nf+NRL4hM++w\nQ0veeNzBQXg1f/JxfeA39IDIX1kiCf71tGlT\n-----END CERTIFICATE-----\n",
        /**
         * Amazon RDS ap-northeast-1 certificate CA 2019 to 2024
         *
         *   CN = Amazon RDS ap-northeast-1 2019 CA
         *   OU = Amazon RDS
         *   O = Amazon Web Services, Inc.
         *   L = Seattle
         *   ST = Washington
         *   C = US
         *   P = 2019-09-18T16:56:20Z/2024-08-22T17:08:50Z
         *   F = 47:A3:F9:20:64:5C:9F:9D:48:8C:7D:E6:0B:86:D6:05:13:00:16:A1
         */
        "-----BEGIN CERTIFICATE-----\nMIIEDDCCAvSgAwIBAgICcEUwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT\nMRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\nDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\nMSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MTgxNjU2\nMjBaFw0yNDA4MjIxNzA4NTBaMIGZMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz\naGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT\nZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEqMCgGA1UEAwwhQW1h\nem9uIFJEUyBhcC1ub3J0aGVhc3QtMSAyMDE5IENBMIIBIjANBgkqhkiG9w0BAQEF\nAAOCAQ8AMIIBCgKCAQEAndtkldmHtk4TVQAyqhAvtEHSMb6pLhyKrIFved1WO3S7\n+I+bWwv9b2W/ljJxLq9kdT43bhvzonNtI4a1LAohS6bqyirmk8sFfsWT3akb+4Sx\n1sjc8Ovc9eqIWJCrUiSvv7+cS7ZTA9AgM1PxvHcsqrcUXiK3Jd/Dax9jdZE1e15s\nBEhb2OEPE+tClFZ+soj8h8Pl2Clo5OAppEzYI4LmFKtp1X/BOf62k4jviXuCSst3\nUnRJzE/CXtjmN6oZySVWSe0rQYuyqRl6//9nK40cfGKyxVnimB8XrrcxUN743Vud\nQQVU0Esm8OVTX013mXWQXJHP2c0aKkog8LOga0vobQIDAQABo2YwZDAOBgNVHQ8B\nAf8EBAMCAQYwEgYDVR0TAQH/BAgwBgEB/wIBADAdBgNVHQ4EFgQULmoOS1mFSjj+\nsnUPx4DgS3SkLFYwHwYDVR0jBBgwFoAUc19g2LzLA5j0Kxc0LjZapmD/vB8wDQYJ\nKoZIhvcNAQELBQADggEBAAkVL2P1M2/G9GM3DANVAqYOwmX0Xk58YBHQu6iiQg4j\nb4Ky/qsZIsgT7YBsZA4AOcPKQFgGTWhe9pvhmXqoN3RYltN8Vn7TbUm/ZVDoMsrM\ngwv0+TKxW1/u7s8cXYfHPiTzVSJuOogHx99kBW6b2f99GbP7O1Sv3sLq4j6lVvBX\nFiacf5LAWC925nvlTzLlBgIc3O9xDtFeAGtZcEtxZJ4fnGXiqEnN4539+nqzIyYq\nnvlgCzyvcfRAxwltrJHuuRu6Maw5AGcd2Y0saMhqOVq9KYKFKuD/927BTrbd2JVf\n2sGWyuPZPCk3gq+5pCjbD0c6DkhcMGI6WwxvM5V/zSM=\n-----END CERTIFICATE-----\n",
        /**
         * Amazon RDS ap-northeast-2 certificate CA 2019 to 2024
         *
         *   CN = Amazon RDS ap-northeast-2 2019 CA
         *   OU = Amazon RDS
         *   O = Amazon Web Services, Inc.
         *   L = Seattle
         *   ST = Washington
         *   C = US
         *   P = 2019-09-10T17:46:21Z/2024-08-22T17:08:50Z
         *   F = 8E:1C:70:C1:64:BD:FC:F9:93:9B:A2:67:CA:CF:52:F0:E1:F7:B4:F0
         */
        "-----BEGIN CERTIFICATE-----\nMIIEDDCCAvSgAwIBAgICOFAwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT\nMRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\nDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\nMSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MTAxNzQ2\nMjFaFw0yNDA4MjIxNzA4NTBaMIGZMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz\naGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT\nZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEqMCgGA1UEAwwhQW1h\nem9uIFJEUyBhcC1ub3J0aGVhc3QtMiAyMDE5IENBMIIBIjANBgkqhkiG9w0BAQEF\nAAOCAQ8AMIIBCgKCAQEAzU72e6XbaJbi4HjJoRNjKxzUEuChKQIt7k3CWzNnmjc5\n8I1MjCpa2W1iw1BYVysXSNSsLOtUsfvBZxi/1uyMn5ZCaf9aeoA9UsSkFSZBjOCN\nDpKPCmfV1zcEOvJz26+1m8WDg+8Oa60QV0ou2AU1tYcw98fOQjcAES0JXXB80P2s\n3UfkNcnDz+l4k7j4SllhFPhH6BQ4lD2NiFAP4HwoG6FeJUn45EPjzrydxjq6v5Fc\ncQ8rGuHADVXotDbEhaYhNjIrsPL+puhjWfhJjheEw8c4whRZNp6gJ/b6WEes/ZhZ\nh32DwsDsZw0BfRDUMgUn8TdecNexHUw8vQWeC181hwIDAQABo2YwZDAOBgNVHQ8B\nAf8EBAMCAQYwEgYDVR0TAQH/BAgwBgEB/wIBADAdBgNVHQ4EFgQUwW9bWgkWkr0U\nlrOsq2kvIdrECDgwHwYDVR0jBBgwFoAUc19g2LzLA5j0Kxc0LjZapmD/vB8wDQYJ\nKoZIhvcNAQELBQADggEBAEugF0Gj7HVhX0ehPZoGRYRt3PBuI2YjfrrJRTZ9X5wc\n9T8oHmw07mHmNy1qqWvooNJg09bDGfB0k5goC2emDiIiGfc/kvMLI7u+eQOoMKj6\nmkfCncyRN3ty08Po45vTLBFZGUvtQmjM6yKewc4sXiASSBmQUpsMbiHRCL72M5qV\nobcJOjGcIdDTmV1BHdWT+XcjynsGjUqOvQWWhhLPrn4jWe6Xuxll75qlrpn3IrIx\nCRBv/5r7qbcQJPOgwQsyK4kv9Ly8g7YT1/vYBlR3cRsYQjccw5ceWUj2DrMVWhJ4\nprf+E3Aa4vYmLLOUUvKnDQ1k3RGNu56V0tonsQbfsaM=\n-----END CERTIFICATE-----\n",
        /**
         * Amazon RDS ap-northeast-3 certificate CA 2019 to 2024
         *
         *   CN = Amazon RDS ap-northeast-3 2019 CA
         *   OU = Amazon RDS
         *   O = Amazon Web Services, Inc.
         *   L = Seattle
         *   ST = Washington
         *   C = US
         *   P = 2019-09-17T20:05:29Z/2024-08-22T17:08:50Z
         *   F = D1:08:B1:40:6D:6C:80:8E:F4:C1:2C:8A:1F:66:17:01:54:CD:1A:4E
         */
        "-----BEGIN CERTIFICATE-----\nMIIEDDCCAvSgAwIBAgICOYIwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT\nMRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\nDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\nMSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MTcyMDA1\nMjlaFw0yNDA4MjIxNzA4NTBaMIGZMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz\naGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT\nZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEqMCgGA1UEAwwhQW1h\nem9uIFJEUyBhcC1ub3J0aGVhc3QtMyAyMDE5IENBMIIBIjANBgkqhkiG9w0BAQEF\nAAOCAQ8AMIIBCgKCAQEA4dMak8W+XW8y/2F6nRiytFiA4XLwePadqWebGtlIgyCS\nkbug8Jv5w7nlMkuxOxoUeD4WhI6A9EkAn3r0REM/2f0aYnd2KPxeqS2MrtdxxHw1\nxoOxk2x0piNSlOz6yog1idsKR5Wurf94fvM9FdTrMYPPrDabbGqiBMsZZmoHLvA3\nZ+57HEV2tU0Ei3vWeGIqnNjIekS+E06KhASxrkNU5vi611UsnYZlSi0VtJsH4UGV\nLhnHl53aZL0YFO5mn/fzuNG/51qgk/6EFMMhaWInXX49Dia9FnnuWXwVwi6uX1Wn\n7kjoHi5VtmC8ZlGEHroxX2DxEr6bhJTEpcLMnoQMqwIDAQABo2YwZDAOBgNVHQ8B\nAf8EBAMCAQYwEgYDVR0TAQH/BAgwBgEB/wIBADAdBgNVHQ4EFgQUsUI5Cb3SWB8+\ngv1YLN/ABPMdxSAwHwYDVR0jBBgwFoAUc19g2LzLA5j0Kxc0LjZapmD/vB8wDQYJ\nKoZIhvcNAQELBQADggEBAJAF3E9PM1uzVL8YNdzb6fwJrxxqI2shvaMVmC1mXS+w\nG0zh4v2hBZOf91l1EO0rwFD7+fxoI6hzQfMxIczh875T6vUXePKVOCOKI5wCrDad\nzQbVqbFbdhsBjF4aUilOdtw2qjjs9JwPuB0VXN4/jY7m21oKEOcnpe36+7OiSPjN\nxngYewCXKrSRqoj3mw+0w/+exYj3Wsush7uFssX18av78G+ehKPIVDXptOCP/N7W\n8iKVNeQ2QGTnu2fzWsGUSvMGyM7yqT+h1ILaT//yQS8er511aHMLc142bD4D9VSy\nDgactwPDTShK/PXqhvNey9v/sKXm4XatZvwcc8KYlW4=\n-----END CERTIFICATE-----\n",
        /**
         * Amazon RDS ap-south-1 certificate CA 2019 to 2024
         *
         *   CN = Amazon RDS ap-south-1 2019 CA
         *   OU = Amazon RDS
         *   O = Amazon Web Services, Inc.
         *   L = Seattle
         *   ST = Washington
         *   C = US
         *   P = 2019-09-04T17:13:04Z/2024-08-22T17:08:50Z
         *   F = D6:AD:45:A9:54:36:E4:BA:9C:B7:9B:06:8C:0C:CD:CC:1E:81:B5:00
         */
        "-----BEGIN CERTIFICATE-----\nMIIECDCCAvCgAwIBAgICVIYwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT\nMRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\nDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\nMSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MDQxNzEz\nMDRaFw0yNDA4MjIxNzA4NTBaMIGVMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz\naGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT\nZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEmMCQGA1UEAwwdQW1h\nem9uIFJEUyBhcC1zb3V0aC0xIDIwMTkgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IB\nDwAwggEKAoIBAQDUYOz1hGL42yUCrcsMSOoU8AeD/3KgZ4q7gP+vAz1WnY9K/kim\neWN/2Qqzlo3+mxSFQFyD4MyV3+CnCPnBl9Sh1G/F6kThNiJ7dEWSWBQGAB6HMDbC\nBaAsmUc1UIz8sLTL3fO+S9wYhA63Wun0Fbm/Rn2yk/4WnJAaMZcEtYf6e0KNa0LM\np/kN/70/8cD3iz3dDR8zOZFpHoCtf0ek80QqTich0A9n3JLxR6g6tpwoYviVg89e\nqCjQ4axxOkWWeusLeTJCcY6CkVyFvDAKvcUl1ytM5AiaUkXblE7zDFXRM4qMMRdt\nlPm8d3pFxh0fRYk8bIKnpmtOpz3RIctDrZZxAgMBAAGjZjBkMA4GA1UdDwEB/wQE\nAwIBBjASBgNVHRMBAf8ECDAGAQH/AgEAMB0GA1UdDgQWBBT99wKJftD3jb4sHoHG\ni3uGlH6W6TAfBgNVHSMEGDAWgBRzX2DYvMsDmPQrFzQuNlqmYP+8HzANBgkqhkiG\n9w0BAQsFAAOCAQEAZ17hhr3dII3hUfuHQ1hPWGrpJOX/G9dLzkprEIcCidkmRYl+\nhu1Pe3caRMh/17+qsoEErmnVq5jNY9X1GZL04IZH8YbHc7iRHw3HcWAdhN8633+K\njYEB2LbJ3vluCGnCejq9djDb6alOugdLMJzxOkHDhMZ6/gYbECOot+ph1tQuZXzD\ntZ7prRsrcuPBChHlPjmGy8M9z8u+kF196iNSUGC4lM8vLkHM7ycc1/ZOwRq9aaTe\niOghbQQyAEe03MWCyDGtSmDfr0qEk+CHN+6hPiaL8qKt4s+V9P7DeK4iW08ny8Ox\nAVS7u0OK/5+jKMAMrKwpYrBydOjTUTHScocyNw==\n-----END CERTIFICATE-----\n",
        /**
         * Amazon RDS ap-southeast-1 certificate CA 2019 to 2024
         *
         *   CN = Amazon RDS ap-southeast-1 2019 CA
         *   OU = Amazon RDS
         *   O = Amazon Web Services, Inc.
         *   L = Seattle
         *   ST = Washington
         *   C = US
         *   P = 2019-09-13T20:11:42Z/2024-08-22T17:08:50Z
         *   F = 0D:20:FB:91:DE:BE:D2:CF:F3:F8:F8:43:AF:68:C6:03:76:F3:DD:B8
         */
        "-----BEGIN CERTIFICATE-----\nMIIEDDCCAvSgAwIBAgICY4kwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT\nMRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\nDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\nMSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MTMyMDEx\nNDJaFw0yNDA4MjIxNzA4NTBaMIGZMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz\naGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT\nZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEqMCgGA1UEAwwhQW1h\nem9uIFJEUyBhcC1zb3V0aGVhc3QtMSAyMDE5IENBMIIBIjANBgkqhkiG9w0BAQEF\nAAOCAQ8AMIIBCgKCAQEAr5u9OuLL/OF/fBNUX2kINJLzFl4DnmrhnLuSeSnBPgbb\nqddjf5EFFJBfv7IYiIWEFPDbDG5hoBwgMup5bZDbas+ZTJTotnnxVJTQ6wlhTmns\neHECcg2pqGIKGrxZfbQhlj08/4nNAPvyYCTS0bEcmQ1emuDPyvJBYDDLDU6AbCB5\n6Z7YKFQPTiCBblvvNzchjLWF9IpkqiTsPHiEt21sAdABxj9ityStV3ja/W9BfgxH\nwzABSTAQT6FbDwmQMo7dcFOPRX+hewQSic2Rn1XYjmNYzgEHisdUsH7eeXREAcTw\n61TRvaLH8AiOWBnTEJXPAe6wYfrcSd1pD0MXpoB62wIDAQABo2YwZDAOBgNVHQ8B\nAf8EBAMCAQYwEgYDVR0TAQH/BAgwBgEB/wIBADAdBgNVHQ4EFgQUytwMiomQOgX5\nIchd+2lDWRUhkikwHwYDVR0jBBgwFoAUc19g2LzLA5j0Kxc0LjZapmD/vB8wDQYJ\nKoZIhvcNAQELBQADggEBACf6lRDpfCD7BFRqiWM45hqIzffIaysmVfr+Jr+fBTjP\nuYe/ba1omSrNGG23bOcT9LJ8hkQJ9d+FxUwYyICQNWOy6ejicm4z0C3VhphbTPqj\nyjpt9nG56IAcV8BcRJh4o/2IfLNzC/dVuYJV8wj7XzwlvjysenwdrJCoLadkTr1h\neIdG6Le07sB9IxrGJL9e04afk37h7c8ESGSE4E+oS4JQEi3ATq8ne1B9DQ9SasXi\nIRmhNAaISDzOPdyLXi9N9V9Lwe/DHcja7hgLGYx3UqfjhLhOKwp8HtoZORixAmOI\nHfILgNmwyugAbuZoCazSKKBhQ0wgO0WZ66ZKTMG8Oho=\n-----END CERTIFICATE-----\n",
        /**
         * Amazon RDS ap-southeast-2 certificate CA 2019 to 2024
         *
         *   CN = Amazon RDS ap-southeast-2 2019 CA
         *   OU = Amazon RDS
         *   O = Amazon Web Services, Inc.
         *   L = Seattle
         *   ST = Washington
         *   C = US
         *   P = 2019-09-16T19:53:47Z/2024-08-22T17:08:50Z
         *   F = D5:D4:51:83:D9:A3:AC:47:B0:0A:5A:77:D8:A0:79:A9:6A:3F:6D:96
         */
        "-----BEGIN CERTIFICATE-----\nMIIEDDCCAvSgAwIBAgICEkYwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT\nMRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\nDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\nMSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MTYxOTUz\nNDdaFw0yNDA4MjIxNzA4NTBaMIGZMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz\naGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT\nZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEqMCgGA1UEAwwhQW1h\nem9uIFJEUyBhcC1zb3V0aGVhc3QtMiAyMDE5IENBMIIBIjANBgkqhkiG9w0BAQEF\nAAOCAQ8AMIIBCgKCAQEAufodI2Flker8q7PXZG0P0vmFSlhQDw907A6eJuF/WeMo\nGHnll3b4S6nC3oRS3nGeRMHbyU2KKXDwXNb3Mheu+ox+n5eb/BJ17eoj9HbQR1cd\ngEkIciiAltf8gpMMQH4anP7TD+HNFlZnP7ii3geEJB2GGXSxgSWvUzH4etL67Zmn\nTpGDWQMB0T8lK2ziLCMF4XAC/8xDELN/buHCNuhDpxpPebhct0T+f6Arzsiswt2j\n7OeNeLLZwIZvVwAKF7zUFjC6m7/VmTQC8nidVY559D6l0UhhU0Co/txgq3HVsMOH\nPbxmQUwJEKAzQXoIi+4uZzHFZrvov/nDTNJUhC6DqwIDAQABo2YwZDAOBgNVHQ8B\nAf8EBAMCAQYwEgYDVR0TAQH/BAgwBgEB/wIBADAdBgNVHQ4EFgQUwaZpaCme+EiV\nM5gcjeHZSTgOn4owHwYDVR0jBBgwFoAUc19g2LzLA5j0Kxc0LjZapmD/vB8wDQYJ\nKoZIhvcNAQELBQADggEBAAR6a2meCZuXO2TF9bGqKGtZmaah4pH2ETcEVUjkvXVz\nsl+ZKbYjrun+VkcMGGKLUjS812e7eDF726ptoku9/PZZIxlJB0isC/0OyixI8N4M\nNsEyvp52XN9QundTjkl362bomPnHAApeU0mRbMDRR2JdT70u6yAzGLGsUwMkoNnw\n1VR4XKhXHYGWo7KMvFrZ1KcjWhubxLHxZWXRulPVtGmyWg/MvE6KF+2XMLhojhUL\n+9jB3Fpn53s6KMx5tVq1x8PukHmowcZuAF8k+W4gk8Y68wIwynrdZrKRyRv6CVtR\nFZ8DeJgoNZT3y/GT254VqMxxfuy2Ccb/RInd16tEvVk=\n-----END CERTIFICATE-----\n",
        /**
         * Amazon RDS ca-central-1 certificate CA 2019 to 2024
         *
         *   CN = Amazon RDS ca-central-1 2019 CA
         *   OU = Amazon RDS
         *   O = Amazon Web Services, Inc.
         *   L = Seattle
         *   ST = Washington
         *   C = US
         *   P = 2019-09-10T20:52:25Z/2024-08-22T17:08:50Z
         *   F = A1:03:46:F2:BB:29:BF:4F:EC:04:7E:82:9A:A6:C0:11:4D:AB:82:25
         */
        "-----BEGIN CERTIFICATE-----\nMIIECjCCAvKgAwIBAgICEzUwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT\nMRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\nDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\nMSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MTAyMDUy\nMjVaFw0yNDA4MjIxNzA4NTBaMIGXMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz\naGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT\nZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEoMCYGA1UEAwwfQW1h\nem9uIFJEUyBjYS1jZW50cmFsLTEgMjAxOSBDQTCCASIwDQYJKoZIhvcNAQEBBQAD\nggEPADCCAQoCggEBAOxHqdcPSA2uBjsCP4DLSlqSoPuQ/X1kkJLusVRKiQE2zayB\nviuCBt4VB9Qsh2rW3iYGM+usDjltGnI1iUWA5KHcvHszSMkWAOYWLiMNKTlg6LCp\nXnE89tvj5dIH6U8WlDvXLdjB/h30gW9JEX7S8supsBSci2GxEzb5mRdKaDuuF/0O\nqvz4YE04pua3iZ9QwmMFuTAOYzD1M72aOpj+7Ac+YLMM61qOtU+AU6MndnQkKoQi\nqmUN2A9IFaqHFzRlSdXwKCKUA4otzmz+/N3vFwjb5F4DSsbsrMfjeHMo6o/nb6Nh\nYDb0VJxxPee6TxSuN7CQJ2FxMlFUezcoXqwqXD0CAwEAAaNmMGQwDgYDVR0PAQH/\nBAQDAgEGMBIGA1UdEwEB/wQIMAYBAf8CAQAwHQYDVR0OBBYEFDGGpon9WfIpsggE\nCxHq8hZ7E2ESMB8GA1UdIwQYMBaAFHNfYNi8ywOY9CsXNC42WqZg/7wfMA0GCSqG\nSIb3DQEBCwUAA4IBAQAvpeQYEGZvoTVLgV9rd2+StPYykMsmFjWQcyn3dBTZRXC2\nlKq7QhQczMAOhEaaN29ZprjQzsA2X/UauKzLR2Uyqc2qOeO9/YOl0H3qauo8C/W9\nr8xqPbOCDLEXlOQ19fidXyyEPHEq5WFp8j+fTh+s8WOx2M7IuC0ANEetIZURYhSp\nxl9XOPRCJxOhj7JdelhpweX0BJDNHeUFi0ClnFOws8oKQ7sQEv66d5ddxqqZ3NVv\nRbCvCtEutQMOUMIuaygDlMn1anSM8N7Wndx8G6+Uy67AnhjGx7jw/0YPPxopEj6x\nJXP8j0sJbcT9K/9/fPVLNT25RvQ/93T2+IQL4Ca2\n-----END CERTIFICATE-----\n",
        /**
         * Amazon RDS eu-central-1 certificate CA 2019 to 2024
         *
         *   CN = Amazon RDS eu-central-1 2019 CA
         *   OU = Amazon RDS
         *   O = Amazon Web Services, Inc.
         *   L = Seattle
         *   ST = Washington
         *   C = US
         *   P = 2019-09-11T19:36:20Z/2024-08-22T17:08:50Z
         *   F = 53:46:18:4A:42:65:A2:8C:5F:5B:0A:AD:E2:2C:80:E5:E6:8A:6D:2F
         */
        "-----BEGIN CERTIFICATE-----\nMIIECjCCAvKgAwIBAgICV2YwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT\nMRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\nDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\nMSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MTExOTM2\nMjBaFw0yNDA4MjIxNzA4NTBaMIGXMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz\naGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT\nZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEoMCYGA1UEAwwfQW1h\nem9uIFJEUyBldS1jZW50cmFsLTEgMjAxOSBDQTCCASIwDQYJKoZIhvcNAQEBBQAD\nggEPADCCAQoCggEBAMEx54X2pHVv86APA0RWqxxRNmdkhAyp2R1cFWumKQRofoFv\nn+SPXdkpIINpMuEIGJANozdiEz7SPsrAf8WHyD93j/ZxrdQftRcIGH41xasetKGl\nI67uans8d+pgJgBKGb/Z+B5m+UsIuEVekpvgpwKtmmaLFC/NCGuSsJoFsRqoa6Gh\nm34W6yJoY87UatddCqLY4IIXaBFsgK9Q/wYzYLbnWM6ZZvhJ52VMtdhcdzeTHNW0\n5LGuXJOF7Ahb4JkEhoo6TS2c0NxB4l4MBfBPgti+O7WjR3FfZHpt18A6Zkq6A2u6\nD/oTSL6c9/3sAaFTFgMyL3wHb2YlW0BPiljZIqECAwEAAaNmMGQwDgYDVR0PAQH/\nBAQDAgEGMBIGA1UdEwEB/wQIMAYBAf8CAQAwHQYDVR0OBBYEFOcAToAc6skWffJa\nTnreaswAfrbcMB8GA1UdIwQYMBaAFHNfYNi8ywOY9CsXNC42WqZg/7wfMA0GCSqG\nSIb3DQEBCwUAA4IBAQA1d0Whc1QtspK496mFWfFEQNegLh0a9GWYlJm+Htcj5Nxt\nDAIGXb+8xrtOZFHmYP7VLCT5Zd2C+XytqseK/+s07iAr0/EPF+O2qcyQWMN5KhgE\ncXw2SwuP9FPV3i+YAm11PBVeenrmzuk9NrdHQ7TxU4v7VGhcsd2C++0EisrmquWH\nmgIfmVDGxphwoES52cY6t3fbnXmTkvENvR+h3rj+fUiSz0aSo+XZUGHPgvuEKM/W\nCBD9Smc9CBoBgvy7BgHRgRUmwtABZHFUIEjHI5rIr7ZvYn+6A0O6sogRfvVYtWFc\nqpyrW1YX8mD0VlJ8fGKM3G+aCOsiiPKDV/Uafrm+\n-----END CERTIFICATE-----\n",
        /**
         * Amazon RDS eu-north-1 certificate CA 2019 to 2024
         *
         *   CN = Amazon RDS eu-north-1 2019 CA
         *   OU = Amazon RDS
         *   O = Amazon Web Services, Inc.
         *   L = Seattle
         *   ST = Washington
         *   C = US
         *   P = 2019-09-12T18:19:44Z/2024-08-22T17:08:50Z
         *   F = D0:CA:9C:6E:47:4C:4F:DB:85:28:03:4A:60:AC:14:E0:E6:DF:D4:42
         */
        "-----BEGIN CERTIFICATE-----\nMIIECDCCAvCgAwIBAgICGAcwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT\nMRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\nDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\nMSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MTIxODE5\nNDRaFw0yNDA4MjIxNzA4NTBaMIGVMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz\naGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT\nZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEmMCQGA1UEAwwdQW1h\nem9uIFJEUyBldS1ub3J0aC0xIDIwMTkgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IB\nDwAwggEKAoIBAQCiIYnhe4UNBbdBb/nQxl5giM0XoVHWNrYV5nB0YukA98+TPn9v\nAoj1RGYmtryjhrf01Kuv8SWO+Eom95L3zquoTFcE2gmxCfk7bp6qJJ3eHOJB+QUO\nXsNRh76fwDzEF1yTeZWH49oeL2xO13EAx4PbZuZpZBttBM5zAxgZkqu4uWQczFEs\nJXfla7z2fvWmGcTagX10O5C18XaFroV0ubvSyIi75ue9ykg/nlFAeB7O0Wxae88e\nuhiBEFAuLYdqWnsg3459NfV8Yi1GnaitTym6VI3tHKIFiUvkSiy0DAlAGV2iiyJE\nq+DsVEO4/hSINJEtII4TMtysOsYPpINqeEzRAgMBAAGjZjBkMA4GA1UdDwEB/wQE\nAwIBBjASBgNVHRMBAf8ECDAGAQH/AgEAMB0GA1UdDgQWBBRR0UpnbQyjnHChgmOc\nhnlc0PogzTAfBgNVHSMEGDAWgBRzX2DYvMsDmPQrFzQuNlqmYP+8HzANBgkqhkiG\n9w0BAQsFAAOCAQEAKJD4xVzSf4zSGTBJrmamo86jl1NHQxXUApAZuBZEc8tqC6TI\nT5CeoSr9CMuVC8grYyBjXblC4OsM5NMvmsrXl/u5C9dEwtBFjo8mm53rOOIm1fxl\nI1oYB/9mtO9ANWjkykuLzWeBlqDT/i7ckaKwalhLODsRDO73vRhYNjsIUGloNsKe\npxw3dzHwAZx4upSdEVG4RGCZ1D0LJ4Gw40OfD69hfkDfRVVxKGrbEzqxXRvovmDc\ntKLdYZO/6REoca36v4BlgIs1CbUXJGLSXUwtg7YXGLSVBJ/U0+22iGJmBSNcoyUN\ncjPFD9JQEhDDIYYKSGzIYpvslvGc4T5ISXFiuQ==\n-----END CERTIFICATE-----\n",
        /**
         * Amazon RDS eu-west-1 certificate CA 2019 to 2024
         *
         *   CN = Amazon RDS eu-west-1 2019 CA
         *   OU = Amazon RDS
         *   O = Amazon Web Services, Inc.
         *   L = Seattle
         *   ST = Washington
         *   C = US
         *   P = 2019-09-11T17:31:48Z/2024-08-22T17:08:50Z
         *   F = 2D:1A:A6:3E:0D:EB:D6:26:03:3E:A1:8A:0A:DF:14:80:78:EC:B6:63
         */
        "-----BEGIN CERTIFICATE-----\nMIIEBzCCAu+gAwIBAgICYpgwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT\nMRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\nDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\nMSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MTExNzMx\nNDhaFw0yNDA4MjIxNzA4NTBaMIGUMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz\naGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT\nZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzElMCMGA1UEAwwcQW1h\nem9uIFJEUyBldS13ZXN0LTEgMjAxOSBDQTCCASIwDQYJKoZIhvcNAQEBBQADggEP\nADCCAQoCggEBAMk3YdSZ64iAYp6MyyKtYJtNzv7zFSnnNf6vv0FB4VnfITTMmOyZ\nLXqKAT2ahZ00hXi34ewqJElgU6eUZT/QlzdIu359TEZyLVPwURflL6SWgdG01Q5X\nO++7fSGcBRyIeuQWs9FJNIIqK8daF6qw0Rl5TXfu7P9dBc3zkgDXZm2DHmxGDD69\n7liQUiXzoE1q2Z9cA8+jirDioJxN9av8hQt12pskLQumhlArsMIhjhHRgF03HOh5\ntvi+RCfihVOxELyIRTRpTNiIwAqfZxxTWFTgfn+gijTmd0/1DseAe82aYic8JbuS\nEMbrDduAWsqrnJ4GPzxHKLXX0JasCUcWyMECAwEAAaNmMGQwDgYDVR0PAQH/BAQD\nAgEGMBIGA1UdEwEB/wQIMAYBAf8CAQAwHQYDVR0OBBYEFPLtsq1NrwJXO13C9eHt\nsLY11AGwMB8GA1UdIwQYMBaAFHNfYNi8ywOY9CsXNC42WqZg/7wfMA0GCSqGSIb3\nDQEBCwUAA4IBAQAnWBKj5xV1A1mYd0kIgDdkjCwQkiKF5bjIbGkT3YEFFbXoJlSP\n0lZZ/hDaOHI8wbLT44SzOvPEEmWF9EE7SJzkvSdQrUAWR9FwDLaU427ALI3ngNHy\nlGJ2hse1fvSRNbmg8Sc9GBv8oqNIBPVuw+AJzHTacZ1OkyLZrz1c1QvwvwN2a+Jd\nvH0V0YIhv66llKcYDMUQJAQi4+8nbRxXWv6Gq3pvrFoorzsnkr42V3JpbhnYiK+9\nnRKd4uWl62KRZjGkfMbmsqZpj2fdSWMY1UGyN1k+kDmCSWYdrTRDP0xjtIocwg+A\nJ116n4hV/5mbA0BaPiS2krtv17YAeHABZcvz\n-----END CERTIFICATE-----\n",
        /**
         * Amazon RDS eu-west-2 certificate CA 2019 to 2024
         *
         *   CN = Amazon RDS eu-west-2 2019 CA
         *   OU = Amazon RDS
         *   O = Amazon Web Services, Inc.
         *   L = Seattle
         *   ST = Washington
         *   C = US
         *   P = 2019-09-12T21:32:32Z/2024-08-22T17:08:50Z
         *   F = 60:65:44:F4:74:6E:2E:29:50:19:38:7C:4B:BE:18:B9:5B:D4:CD:23
         */
        "-----BEGIN CERTIFICATE-----\nMIIEBzCCAu+gAwIBAgICZIEwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT\nMRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\nDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\nMSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MTIyMTMy\nMzJaFw0yNDA4MjIxNzA4NTBaMIGUMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz\naGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT\nZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzElMCMGA1UEAwwcQW1h\nem9uIFJEUyBldS13ZXN0LTIgMjAxOSBDQTCCASIwDQYJKoZIhvcNAQEBBQADggEP\nADCCAQoCggEBALGiwqjiF7xIjT0Sx7zB3764K2T2a1DHnAxEOr+/EIftWKxWzT3u\nPFwS2eEZcnKqSdRQ+vRzonLBeNLO4z8aLjQnNbkizZMBuXGm4BqRm1Kgq3nlLDQn\n7YqdijOq54SpShvR/8zsO4sgMDMmHIYAJJOJqBdaus2smRt0NobIKc0liy7759KB\n6kmQ47Gg+kfIwxrQA5zlvPLeQImxSoPi9LdbRoKvu7Iot7SOa+jGhVBh3VdqndJX\n7tm/saj4NE375csmMETFLAOXjat7zViMRwVorX4V6AzEg1vkzxXpA9N7qywWIT5Y\nfYaq5M8i6vvLg0CzrH9fHORtnkdjdu1y+0MCAwEAAaNmMGQwDgYDVR0PAQH/BAQD\nAgEGMBIGA1UdEwEB/wQIMAYBAf8CAQAwHQYDVR0OBBYEFFOhOx1yt3Z7mvGB9jBv\n2ymdZwiOMB8GA1UdIwQYMBaAFHNfYNi8ywOY9CsXNC42WqZg/7wfMA0GCSqGSIb3\nDQEBCwUAA4IBAQBehqY36UGDvPVU9+vtaYGr38dBbp+LzkjZzHwKT1XJSSUc2wqM\nhnCIQKilonrTIvP1vmkQi8qHPvDRtBZKqvz/AErW/ZwQdZzqYNFd+BmOXaeZWV0Q\noHtDzXmcwtP8aUQpxN0e1xkWb1E80qoy+0uuRqb/50b/R4Q5qqSfJhkn6z8nwB10\n7RjLtJPrK8igxdpr3tGUzfAOyiPrIDncY7UJaL84GFp7WWAkH0WG3H8Y8DRcRXOU\nmqDxDLUP3rNuow3jnGxiUY+gGX5OqaZg4f4P6QzOSmeQYs6nLpH0PiN00+oS1BbD\nbpWdZEttILPI+vAYkU4QuBKKDjJL6HbSd+cn\n-----END CERTIFICATE-----\n",
        /**
         * Amazon RDS eu-west-3 certificate CA 2019 to 2024
         *
         *   CN = Amazon RDS eu-west-3 2019 CA
         *   OU = Amazon RDS
         *   O = Amazon Web Services, Inc.
         *   L = Seattle
         *   ST = Washington
         *   C = US
         *   P = 2019-09-18T17:03:15Z/2024-08-22T17:08:50Z
         *   F = 6F:79:56:B0:74:9C:C6:3E:3B:50:26:C8:51:55:08:F0:BB:7E:32:04
         */
        "-----BEGIN CERTIFICATE-----\nMIIEBzCCAu+gAwIBAgICJDQwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT\nMRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\nDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\nMSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MTgxNzAz\nMTVaFw0yNDA4MjIxNzA4NTBaMIGUMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz\naGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT\nZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzElMCMGA1UEAwwcQW1h\nem9uIFJEUyBldS13ZXN0LTMgMjAxOSBDQTCCASIwDQYJKoZIhvcNAQEBBQADggEP\nADCCAQoCggEBAL9bL7KE0n02DLVtlZ2PL+g/BuHpMYFq2JnE2RgompGurDIZdjmh\n1pxfL3nT+QIVMubuAOy8InRfkRxfpxyjKYdfLJTPJG+jDVL+wDcPpACFVqoV7Prg\npVYEV0lc5aoYw4bSeYFhdzgim6F8iyjoPnObjll9mo4XsHzSoqJLCd0QC+VG9Fw2\nq+GDRZrLRmVM2oNGDRbGpGIFg77aRxRapFZa8SnUgs2AqzuzKiprVH5i0S0M6dWr\ni+kk5epmTtkiDHceX+dP/0R1NcnkCPoQ9TglyXyPdUdTPPRfKCq12dftqll+u4mV\nARdN6WFjovxax8EAP2OAUTi1afY+1JFMj+sCAwEAAaNmMGQwDgYDVR0PAQH/BAQD\nAgEGMBIGA1UdEwEB/wQIMAYBAf8CAQAwHQYDVR0OBBYEFLfhrbrO5exkCVgxW0x3\nY2mAi8lNMB8GA1UdIwQYMBaAFHNfYNi8ywOY9CsXNC42WqZg/7wfMA0GCSqGSIb3\nDQEBCwUAA4IBAQAigQ5VBNGyw+OZFXwxeJEAUYaXVoP/qrhTOJ6mCE2DXUVEoJeV\nSxScy/TlFA9tJXqmit8JH8VQ/xDL4ubBfeMFAIAo4WzNWDVoeVMqphVEcDWBHsI1\nAETWzfsapRS9yQekOMmxg63d/nV8xewIl8aNVTHdHYXMqhhik47VrmaVEok1UQb3\nO971RadLXIEbVd9tjY5bMEHm89JsZDnDEw1hQXBb67Elu64OOxoKaHBgUH8AZn/2\nzFsL1ynNUjOhCSAA15pgd1vjwc0YsBbAEBPcHBWYBEyME6NLNarjOzBl4FMtATSF\nwWCKRGkvqN8oxYhwR2jf2rR5Mu4DWkK5Q8Ep\n-----END CERTIFICATE-----\n",
        /**
         * Amazon RDS me-south-1 certificate CA 2019 to 2024
         *
         *   CN = Amazon RDS me-south-1 Root CA
         *   OU = Amazon RDS
         *   O = Amazon Web Services, Inc.
         *   L = Seattle
         *   ST = Washington
         *   C = US
         *   P = 2019-05-10T21:48:27Z/2024-05-08T21:48:27Z
         *   F = 8A:69:D7:00:FB:5D:62:9C:B0:D1:75:6F:B7:B6:38:AA:76:C4:BD:1F
         */
        "-----BEGIN CERTIFICATE-----\nMIIEEjCCAvqgAwIBAgIJANew34ehz5l8MA0GCSqGSIb3DQEBCwUAMIGVMQswCQYD\nVQQGEwJVUzEQMA4GA1UEBwwHU2VhdHRsZTETMBEGA1UECAwKV2FzaGluZ3RvbjEi\nMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1h\nem9uIFJEUzEmMCQGA1UEAwwdQW1hem9uIFJEUyBtZS1zb3V0aC0xIFJvb3QgQ0Ew\nHhcNMTkwNTEwMjE0ODI3WhcNMjQwNTA4MjE0ODI3WjCBlTELMAkGA1UEBhMCVVMx\nEDAOBgNVBAcMB1NlYXR0bGUxEzARBgNVBAgMCldhc2hpbmd0b24xIjAgBgNVBAoM\nGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMx\nJjAkBgNVBAMMHUFtYXpvbiBSRFMgbWUtc291dGgtMSBSb290IENBMIIBIjANBgkq\nhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAp7BYV88MukcY+rq0r79+C8UzkT30fEfT\naPXbx1d6M7uheGN4FMaoYmL+JE1NZPaMRIPTHhFtLSdPccInvenRDIatcXX+jgOk\nUA6lnHQ98pwN0pfDUyz/Vph4jBR9LcVkBbe0zdoKKp+HGbMPRU0N2yNrog9gM5O8\ngkU/3O2csJ/OFQNnj4c2NQloGMUpEmedwJMOyQQfcUyt9CvZDfIPNnheUS29jGSw\nERpJe/AENu8Pxyc72jaXQuD+FEi2Ck6lBkSlWYQFhTottAeGvVFNCzKszCntrtqd\nrdYUwurYsLTXDHv9nW2hfDUQa0mhXf9gNDOBIVAZugR9NqNRNyYLHQIDAQABo2Mw\nYTAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQU54cf\nDjgwBx4ycBH8+/r8WXdaiqYwHwYDVR0jBBgwFoAU54cfDjgwBx4ycBH8+/r8WXda\niqYwDQYJKoZIhvcNAQELBQADggEBAIIMTSPx/dR7jlcxggr+O6OyY49Rlap2laKA\neC/XI4ySP3vQkIFlP822U9Kh8a9s46eR0uiwV4AGLabcu0iKYfXjPkIprVCqeXV7\nny9oDtrbflyj7NcGdZLvuzSwgl9SYTJp7PVCZtZutsPYlbJrBPHwFABvAkMvRtDB\nhitIg4AESDGPoCl94sYHpfDfjpUDMSrAMDUyO6DyBdZH5ryRMAs3lGtsmkkNUrso\naTW6R05681Z0mvkRdb+cdXtKOSuDZPoe2wJJIaz3IlNQNSrB5TImMYgmt6iAsFhv\n3vfTSTKrZDNTJn4ybG6pq1zWExoXsktZPylJly6R3RBwV6nwqBM=\n-----END CERTIFICATE-----\n",
        /**
         * Amazon RDS sa-east-1 certificate CA 2019 to 2024
         *
         *   CN = Amazon RDS sa-east-1 2019 CA
         *   OU = Amazon RDS
         *   O = Amazon Web Services, Inc.
         *   L = Seattle
         *   ST = Washington
         *   C = US
         *   P = 2019-09-05T18:46:29Z/2024-08-22T17:08:50Z
         *   F = 8C:34:0F:AA:FB:10:80:9C:05:CE:D7:BF:0B:12:4D:07:42:39:74:7A
         */
        "-----BEGIN CERTIFICATE-----\nMIIEBzCCAu+gAwIBAgICQ2QwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT\nMRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\nDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\nMSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MDUxODQ2\nMjlaFw0yNDA4MjIxNzA4NTBaMIGUMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz\naGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT\nZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzElMCMGA1UEAwwcQW1h\nem9uIFJEUyBzYS1lYXN0LTEgMjAxOSBDQTCCASIwDQYJKoZIhvcNAQEBBQADggEP\nADCCAQoCggEBAMMvR+ReRnOzqJzoaPipNTt1Z2VA968jlN1+SYKUrYM3No+Vpz0H\nM6Tn0oYB66ByVsXiGc28ulsqX1HbHsxqDPwvQTKvO7SrmDokoAkjJgLocOLUAeld\n5AwvUjxGRP6yY90NV7X786MpnYb2Il9DIIaV9HjCmPt+rjy2CZjS0UjPjCKNfB8J\nbFjgW6GGscjeyGb/zFwcom5p4j0rLydbNaOr9wOyQrtt3ZQWLYGY9Zees/b8pmcc\nJt+7jstZ2UMV32OO/kIsJ4rMUn2r/uxccPwAc1IDeRSSxOrnFKhW3Cu69iB3bHp7\nJbawY12g7zshE4I14sHjv3QoXASoXjx4xgMCAwEAAaNmMGQwDgYDVR0PAQH/BAQD\nAgEGMBIGA1UdEwEB/wQIMAYBAf8CAQAwHQYDVR0OBBYEFI1Fc/Ql2jx+oJPgBVYq\nccgP0pQ8MB8GA1UdIwQYMBaAFHNfYNi8ywOY9CsXNC42WqZg/7wfMA0GCSqGSIb3\nDQEBCwUAA4IBAQB4VVVabVp70myuYuZ3vltQIWqSUMhkaTzehMgGcHjMf9iLoZ/I\n93KiFUSGnek5cRePyS9wcpp0fcBT3FvkjpUdCjVtdttJgZFhBxgTd8y26ImdDDMR\n4+BUuhI5msvjL08f+Vkkpu1GQcGmyFVPFOy/UY8iefu+QyUuiBUnUuEDd49Hw0Fn\n/kIPII6Vj82a2mWV/Q8e+rgN8dIRksRjKI03DEoP8lhPlsOkhdwU6Uz9Vu6NOB2Q\nLs1kbcxAc7cFSyRVJEhh12Sz9d0q/CQSTFsVJKOjSNQBQfVnLz1GwO/IieUEAr4C\njkTntH0r1LX5b/GwN4R887LvjAEdTbg1his7\n-----END CERTIFICATE-----\n",
        /**
         * Amazon RDS us-east-1 certificate CA 2019 to 2024
         *
         *   CN = Amazon RDS us-east-1 2019 CA
         *   OU = Amazon RDS
         *   O = Amazon Web Services, Inc.
         *   L = Seattle
         *   ST = Washington
         *   C = US
         *   P = 2019-09-19T18:16:53Z/2024-08-22T17:08:50Z
         *   F = F0:ED:82:3E:D1:44:47:BA:B5:57:FD:F3:E4:92:74:66:98:8C:1C:78
         */
        "-----BEGIN CERTIFICATE-----\nMIIEBzCCAu+gAwIBAgICJVUwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT\nMRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\nDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\nMSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MTkxODE2\nNTNaFw0yNDA4MjIxNzA4NTBaMIGUMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz\naGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT\nZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzElMCMGA1UEAwwcQW1h\nem9uIFJEUyB1cy1lYXN0LTEgMjAxOSBDQTCCASIwDQYJKoZIhvcNAQEBBQADggEP\nADCCAQoCggEBAM3i/k2u6cqbMdcISGRvh+m+L0yaSIoOXjtpNEoIftAipTUYoMhL\nInXGlQBVA4shkekxp1N7HXe1Y/iMaPEyb3n+16pf3vdjKl7kaSkIhjdUz3oVUEYt\ni8Z/XeJJ9H2aEGuiZh3kHixQcZczn8cg3dA9aeeyLSEnTkl/npzLf//669Ammyhs\nXcAo58yvT0D4E0D/EEHf2N7HRX7j/TlyWvw/39SW0usiCrHPKDLxByLojxLdHzso\nQIp/S04m+eWn6rmD+uUiRteN1hI5ncQiA3wo4G37mHnUEKo6TtTUh+sd/ku6a8HK\nglMBcgqudDI90s1OpuIAWmuWpY//8xEG2YECAwEAAaNmMGQwDgYDVR0PAQH/BAQD\nAgEGMBIGA1UdEwEB/wQIMAYBAf8CAQAwHQYDVR0OBBYEFPqhoWZcrVY9mU7tuemR\nRBnQIj1jMB8GA1UdIwQYMBaAFHNfYNi8ywOY9CsXNC42WqZg/7wfMA0GCSqGSIb3\nDQEBCwUAA4IBAQB6zOLZ+YINEs72heHIWlPZ8c6WY8MDU+Be5w1M+BK2kpcVhCUK\nPJO4nMXpgamEX8DIiaO7emsunwJzMSvavSPRnxXXTKIc0i/g1EbiDjnYX9d85DkC\nE1LaAUCmCZBVi9fIe0H2r9whIh4uLWZA41oMnJx/MOmo3XyMfQoWcqaSFlMqfZM4\n0rNoB/tdHLNuV4eIdaw2mlHxdWDtF4oH+HFm+2cVBUVC1jXKrFv/euRVtsTT+A6i\nh2XBHKxQ1Y4HgAn0jACP2QSPEmuoQEIa57bEKEcZsBR8SDY6ZdTd2HLRIApcCOSF\nMRM8CKLeF658I0XgF8D5EsYoKPsA+74Z+jDH\n-----END CERTIFICATE-----\n",
        /**
         * Amazon RDS us-east-2 certificate CA 2019 to 2024
         *
         *   CN = Amazon RDS us-east-2 2019 CA
         *   OU = Amazon RDS
         *   O = Amazon Web Services, Inc.
         *   L = Seattle
         *   ST = Washington
         *   C = US
         *   P = 2019-09-13T17:06:41Z/2024-08-22T17:08:50Z
         *   F = E9:FE:27:2A:A0:0F:CE:DF:AD:51:03:A6:94:F7:1F:6F:BD:1E:28:D3
         */
        "-----BEGIN CERTIFICATE-----\nMIIECDCCAvCgAwIBAgIDAIVCMA0GCSqGSIb3DQEBCwUAMIGPMQswCQYDVQQGEwJV\nUzEQMA4GA1UEBwwHU2VhdHRsZTETMBEGA1UECAwKV2FzaGluZ3RvbjEiMCAGA1UE\nCgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJE\nUzEgMB4GA1UEAwwXQW1hem9uIFJEUyBSb290IDIwMTkgQ0EwHhcNMTkwOTEzMTcw\nNjQxWhcNMjQwODIyMTcwODUwWjCBlDELMAkGA1UEBhMCVVMxEzARBgNVBAgMCldh\nc2hpbmd0b24xEDAOBgNVBAcMB1NlYXR0bGUxIjAgBgNVBAoMGUFtYXpvbiBXZWIg\nU2VydmljZXMsIEluYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxJTAjBgNVBAMMHEFt\nYXpvbiBSRFMgdXMtZWFzdC0yIDIwMTkgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IB\nDwAwggEKAoIBAQDE+T2xYjUbxOp+pv+gRA3FO24+1zCWgXTDF1DHrh1lsPg5k7ht\n2KPYzNc+Vg4E+jgPiW0BQnA6jStX5EqVh8BU60zELlxMNvpg4KumniMCZ3krtMUC\nau1NF9rM7HBh+O+DYMBLK5eSIVt6lZosOb7bCi3V6wMLA8YqWSWqabkxwN4w0vXI\n8lu5uXXFRemHnlNf+yA/4YtN4uaAyd0ami9+klwdkZfkrDOaiy59haOeBGL8EB/c\ndbJJlguHH5CpCscs3RKtOOjEonXnKXldxarFdkMzi+aIIjQ8GyUOSAXHtQHb3gZ4\nnS6Ey0CMlwkB8vUObZU9fnjKJcL5QCQqOfwvAgMBAAGjZjBkMA4GA1UdDwEB/wQE\nAwIBBjASBgNVHRMBAf8ECDAGAQH/AgEAMB0GA1UdDgQWBBQUPuRHohPxx4VjykmH\n6usGrLL1ETAfBgNVHSMEGDAWgBRzX2DYvMsDmPQrFzQuNlqmYP+8HzANBgkqhkiG\n9w0BAQsFAAOCAQEAUdR9Vb3y33Yj6X6KGtuthZ08SwjImVQPtknzpajNE5jOJAh8\nquvQnU9nlnMO85fVDU1Dz3lLHGJ/YG1pt1Cqq2QQ200JcWCvBRgdvH6MjHoDQpqZ\nHvQ3vLgOGqCLNQKFuet9BdpsHzsctKvCVaeBqbGpeCtt3Hh/26tgx0rorPLw90A2\nV8QSkZJjlcKkLa58N5CMM8Xz8KLWg3MZeT4DmlUXVCukqK2RGuP2L+aME8dOxqNv\nOnOz1zrL5mR2iJoDpk8+VE/eBDmJX40IJk6jBjWoxAO/RXq+vBozuF5YHN1ujE92\ntO8HItgTp37XT8bJBAiAnt5mxw+NLSqtxk2QdQ==\n-----END CERTIFICATE-----\n",
        /**
         * Amazon RDS us-west-1 certificate CA 2019 to 2024
         *
         *   CN = Amazon RDS us-west-1 2019 CA
         *   OU = Amazon RDS
         *   O = Amazon Web Services, Inc.
         *   L = Seattle
         *   ST = Washington
         *   C = US
         *   P = 2019-09-06T17:40:21Z/2024-08-22T17:08:50Z
         *   F = 1C:9F:DF:84:E6:13:32:F3:91:12:2D:0D:A5:9A:16:5D:AC:DC:E8:93
         */
        "-----BEGIN CERTIFICATE-----\nMIIECDCCAvCgAwIBAgIDAIkHMA0GCSqGSIb3DQEBCwUAMIGPMQswCQYDVQQGEwJV\nUzEQMA4GA1UEBwwHU2VhdHRsZTETMBEGA1UECAwKV2FzaGluZ3RvbjEiMCAGA1UE\nCgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJE\nUzEgMB4GA1UEAwwXQW1hem9uIFJEUyBSb290IDIwMTkgQ0EwHhcNMTkwOTA2MTc0\nMDIxWhcNMjQwODIyMTcwODUwWjCBlDELMAkGA1UEBhMCVVMxEzARBgNVBAgMCldh\nc2hpbmd0b24xEDAOBgNVBAcMB1NlYXR0bGUxIjAgBgNVBAoMGUFtYXpvbiBXZWIg\nU2VydmljZXMsIEluYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxJTAjBgNVBAMMHEFt\nYXpvbiBSRFMgdXMtd2VzdC0xIDIwMTkgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IB\nDwAwggEKAoIBAQDD2yzbbAl77OofTghDMEf624OvU0eS9O+lsdO0QlbfUfWa1Kd6\n0WkgjkLZGfSRxEHMCnrv4UPBSK/Qwn6FTjkDLgemhqBtAnplN4VsoDL+BkRX4Wwq\n/dSQJE2b+0hm9w9UMVGFDEq1TMotGGTD2B71eh9HEKzKhGzqiNeGsiX4VV+LJzdH\nuM23eGisNqmd4iJV0zcAZ+Gbh2zK6fqTOCvXtm7Idccv8vZZnyk1FiWl3NR4WAgK\nAkvWTIoFU3Mt7dIXKKClVmvssG8WHCkd3Xcb4FHy/G756UZcq67gMMTX/9fOFM/v\nl5C0+CHl33Yig1vIDZd+fXV1KZD84dEJfEvHAgMBAAGjZjBkMA4GA1UdDwEB/wQE\nAwIBBjASBgNVHRMBAf8ECDAGAQH/AgEAMB0GA1UdDgQWBBR+ap20kO/6A7pPxo3+\nT3CfqZpQWjAfBgNVHSMEGDAWgBRzX2DYvMsDmPQrFzQuNlqmYP+8HzANBgkqhkiG\n9w0BAQsFAAOCAQEAHCJky2tPjPttlDM/RIqExupBkNrnSYnOK4kr9xJ3sl8UF2DA\nPAnYsjXp3rfcjN/k/FVOhxwzi3cXJF/2Tjj39Bm/OEfYTOJDNYtBwB0VVH4ffa/6\ntZl87jaIkrxJcreeeHqYMnIxeN0b/kliyA+a5L2Yb0VPjt9INq34QDc1v74FNZ17\n4z8nr1nzg4xsOWu0Dbjo966lm4nOYIGBRGOKEkHZRZ4mEiMgr3YLkv8gSmeitx57\nZ6dVemNtUic/LVo5Iqw4n3TBS0iF2C1Q1xT/s3h+0SXZlfOWttzSluDvoMv5PvCd\npFjNn+aXLAALoihL1MJSsxydtsLjOBro5eK0Vw==\n-----END CERTIFICATE-----\n",
        /**
         * Amazon RDS us-west-2 certificate CA 2019 to 2024
         *
         *   CN = Amazon RDS us-west-2 2019 CA
         *   OU = Amazon RDS
         *   O = Amazon Web Services, Inc.
         *   L = Seattle
         *   ST = Washington
         *   C = US
         *   P = 2019-09-16T18:21:15Z/2024-08-22T17:08:50Z
         *   F = C8:DE:1D:13:AD:35:9B:3D:EA:18:2A:DC:B4:79:6D:22:47:75:3C:4A
         */
        "-----BEGIN CERTIFICATE-----\nMIIEBzCCAu+gAwIBAgICUYkwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT\nMRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\nDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\nMSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MTYxODIx\nMTVaFw0yNDA4MjIxNzA4NTBaMIGUMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz\naGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT\nZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzElMCMGA1UEAwwcQW1h\nem9uIFJEUyB1cy13ZXN0LTIgMjAxOSBDQTCCASIwDQYJKoZIhvcNAQEBBQADggEP\nADCCAQoCggEBANCEZBZyu6yJQFZBJmSUZfSZd3Ui2gitczMKC4FLr0QzkbxY+cLa\nuVONIOrPt4Rwi+3h/UdnUg917xao3S53XDf1TDMFEYp4U8EFPXqCn/GXBIWlU86P\nPvBN+gzw3nS+aco7WXb+woTouvFVkk8FGU7J532llW8o/9ydQyDIMtdIkKTuMfho\nOiNHSaNc+QXQ32TgvM9A/6q7ksUoNXGCP8hDOkSZ/YOLiI5TcdLh/aWj00ziL5bj\npvytiMZkilnc9dLY9QhRNr0vGqL0xjmWdoEXz9/OwjmCihHqJq+20MJPsvFm7D6a\n2NKybR9U+ddrjb8/iyLOjURUZnj5O+2+OPcCAwEAAaNmMGQwDgYDVR0PAQH/BAQD\nAgEGMBIGA1UdEwEB/wQIMAYBAf8CAQAwHQYDVR0OBBYEFEBxMBdv81xuzqcK5TVu\npHj+Aor8MB8GA1UdIwQYMBaAFHNfYNi8ywOY9CsXNC42WqZg/7wfMA0GCSqGSIb3\nDQEBCwUAA4IBAQBZkfiVqGoJjBI37aTlLOSjLcjI75L5wBrwO39q+B4cwcmpj58P\n3sivv+jhYfAGEbQnGRzjuFoyPzWnZ1DesRExX+wrmHsLLQbF2kVjLZhEJMHF9eB7\nGZlTPdTzHErcnuXkwA/OqyXMpj9aghcQFuhCNguEfnROY9sAoK2PTfnTz9NJHL+Q\nUpDLEJEUfc0GZMVWYhahc0x38ZnSY2SKacIPECQrTI0KpqZv/P+ijCEcMD9xmYEb\njL4en+XKS1uJpw5fIU5Sj0MxhdGstH6S84iAE5J3GM3XHklGSFwwqPYvuTXvANH6\nuboynxRgSae59jIlAK6Jrr6GWMwQRbgcaAlW\n-----END CERTIFICATE-----\n"
      ]
    };
  }
});

// node_modules/mysql/lib/ConnectionConfig.js
var require_ConnectionConfig = __commonJS({
  "node_modules/mysql/lib/ConnectionConfig.js"(exports2, module2) {
    var urlParse = require_url().parse;
    var ClientConstants = require_client();
    var Charsets = require_charsets();
    var SSLProfiles = null;
    module2.exports = ConnectionConfig;
    function ConnectionConfig(options) {
      if (typeof options === "string") {
        options = ConnectionConfig.parseUrl(options);
      }
      this.host = options.host || "localhost";
      this.port = options.port || 3306;
      this.localAddress = options.localAddress;
      this.socketPath = options.socketPath;
      this.user = options.user || void 0;
      this.password = options.password || void 0;
      this.database = options.database;
      this.connectTimeout = options.connectTimeout === void 0 ? 10 * 1e3 : options.connectTimeout;
      this.insecureAuth = options.insecureAuth || false;
      this.supportBigNumbers = options.supportBigNumbers || false;
      this.bigNumberStrings = options.bigNumberStrings || false;
      this.dateStrings = options.dateStrings || false;
      this.debug = options.debug;
      this.trace = options.trace !== false;
      this.stringifyObjects = options.stringifyObjects || false;
      this.timezone = options.timezone || "local";
      this.flags = options.flags || "";
      this.queryFormat = options.queryFormat;
      this.pool = options.pool || void 0;
      this.ssl = typeof options.ssl === "string" ? ConnectionConfig.getSSLProfile(options.ssl) : options.ssl || false;
      this.localInfile = options.localInfile === void 0 ? true : options.localInfile;
      this.multipleStatements = options.multipleStatements || false;
      this.typeCast = options.typeCast === void 0 ? true : options.typeCast;
      if (this.timezone[0] === " ") {
        this.timezone = "+" + this.timezone.substr(1);
      }
      if (this.ssl) {
        this.ssl.rejectUnauthorized = this.ssl.rejectUnauthorized !== false;
      }
      this.maxPacketSize = 0;
      this.charsetNumber = options.charset ? ConnectionConfig.getCharsetNumber(options.charset) : options.charsetNumber || Charsets.UTF8_GENERAL_CI;
      var defaultFlags = ConnectionConfig.getDefaultFlags(options);
      this.clientFlags = ConnectionConfig.mergeFlags(defaultFlags, options.flags);
    }
    ConnectionConfig.mergeFlags = function mergeFlags(defaultFlags, userFlags) {
      var allFlags = ConnectionConfig.parseFlagList(defaultFlags);
      var newFlags = ConnectionConfig.parseFlagList(userFlags);
      for (var flag in newFlags) {
        if (allFlags[flag] !== false) {
          allFlags[flag] = newFlags[flag];
        }
      }
      var flags = 0;
      for (var flag in allFlags) {
        if (allFlags[flag]) {
          flags |= ClientConstants["CLIENT_" + flag] || 0;
        }
      }
      return flags;
    };
    ConnectionConfig.getCharsetNumber = function getCharsetNumber(charset) {
      var num = Charsets[charset.toUpperCase()];
      if (num === void 0) {
        throw new TypeError("Unknown charset '" + charset + "'");
      }
      return num;
    };
    ConnectionConfig.getDefaultFlags = function getDefaultFlags(options) {
      var defaultFlags = [
        "-COMPRESS",
        // Compression protocol *NOT* supported
        "-CONNECT_ATTRS",
        // Does *NOT* send connection attributes in Protocol::HandshakeResponse41
        "+CONNECT_WITH_DB",
        // One can specify db on connect in Handshake Response Packet
        "+FOUND_ROWS",
        // Send found rows instead of affected rows
        "+IGNORE_SIGPIPE",
        // Don't issue SIGPIPE if network failures
        "+IGNORE_SPACE",
        // Let the parser ignore spaces before '('
        "+LOCAL_FILES",
        // Can use LOAD DATA LOCAL
        "+LONG_FLAG",
        // Longer flags in Protocol::ColumnDefinition320
        "+LONG_PASSWORD",
        // Use the improved version of Old Password Authentication
        "+MULTI_RESULTS",
        // Can handle multiple resultsets for COM_QUERY
        "+ODBC",
        // Special handling of ODBC behaviour
        "-PLUGIN_AUTH",
        // Does *NOT* support auth plugins
        "+PROTOCOL_41",
        // Uses the 4.1 protocol
        "+PS_MULTI_RESULTS",
        // Can handle multiple resultsets for COM_STMT_EXECUTE
        "+RESERVED",
        // Unused
        "+SECURE_CONNECTION",
        // Supports Authentication::Native41
        "+TRANSACTIONS"
        // Expects status flags
      ];
      if (options && options.localInfile !== void 0 && !options.localInfile) {
        defaultFlags.push("-LOCAL_FILES");
      }
      if (options && options.multipleStatements) {
        defaultFlags.push("+MULTI_STATEMENTS");
      }
      return defaultFlags;
    };
    ConnectionConfig.getSSLProfile = function getSSLProfile(name) {
      if (!SSLProfiles) {
        SSLProfiles = require_ssl_profiles();
      }
      var ssl = SSLProfiles[name];
      if (ssl === void 0) {
        throw new TypeError("Unknown SSL profile '" + name + "'");
      }
      return ssl;
    };
    ConnectionConfig.parseFlagList = function parseFlagList(flagList) {
      var allFlags = /* @__PURE__ */ Object.create(null);
      if (!flagList) {
        return allFlags;
      }
      var flags = !Array.isArray(flagList) ? String(flagList || "").toUpperCase().split(/\s*,+\s*/) : flagList;
      for (var i = 0; i < flags.length; i++) {
        var flag = flags[i];
        var offset = 1;
        var state = flag[0];
        if (state === void 0) {
          continue;
        }
        if (state !== "-" && state !== "+") {
          offset = 0;
          state = "+";
        }
        allFlags[flag.substr(offset)] = state === "+";
      }
      return allFlags;
    };
    ConnectionConfig.parseUrl = function(url) {
      url = urlParse(url, true);
      var options = {
        host: url.hostname,
        port: url.port,
        database: url.pathname.substr(1)
      };
      if (url.auth) {
        var auth = url.auth.split(":");
        options.user = auth.shift();
        options.password = auth.join(":");
      }
      if (url.query) {
        for (var key in url.query) {
          var value = url.query[key];
          try {
            options[key] = JSON.parse(value);
          } catch (err) {
            options[key] = value;
          }
        }
      }
      return options;
    };
  }
});

// node_modules/mysql/lib/protocol/PacketHeader.js
var require_PacketHeader = __commonJS({
  "node_modules/mysql/lib/protocol/PacketHeader.js"(exports2, module2) {
    module2.exports = PacketHeader;
    function PacketHeader(length, number) {
      this.length = length;
      this.number = number;
    }
  }
});

// node_modules/bignumber.js/bignumber.js
var require_bignumber = __commonJS({
  "node_modules/bignumber.js/bignumber.js"(exports2, module2) {
    (function(globalObject2) {
      "use strict";
      var BigNumber, isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, mathceil = Math.ceil, mathfloor = Math.floor, bignumberError = "[BigNumber Error] ", tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ", BASE = 1e14, LOG_BASE = 14, MAX_SAFE_INTEGER = 9007199254740991, POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], SQRT_BASE = 1e7, MAX = 1e9;
      function clone(configObject) {
        var div, convertBase, parseNumeric, P = BigNumber2.prototype = { constructor: BigNumber2, toString: null, valueOf: null }, ONE = new BigNumber2(1), DECIMAL_PLACES = 20, ROUNDING_MODE = 4, TO_EXP_NEG = -7, TO_EXP_POS = 21, MIN_EXP = -1e7, MAX_EXP = 1e7, CRYPTO = false, MODULO_MODE = 1, POW_PRECISION = 0, FORMAT = {
          prefix: "",
          groupSize: 3,
          secondaryGroupSize: 0,
          groupSeparator: ",",
          decimalSeparator: ".",
          fractionGroupSize: 0,
          fractionGroupSeparator: " ",
          // non-breaking space
          suffix: ""
        }, ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz";
        function BigNumber2(v, b) {
          var alphabet, c, caseChanged, e, i, isNum, len, str, x = this;
          if (!(x instanceof BigNumber2))
            return new BigNumber2(v, b);
          if (b == null) {
            if (v && v._isBigNumber === true) {
              x.s = v.s;
              if (!v.c || v.e > MAX_EXP) {
                x.c = x.e = null;
              } else if (v.e < MIN_EXP) {
                x.c = [x.e = 0];
              } else {
                x.e = v.e;
                x.c = v.c.slice();
              }
              return;
            }
            if ((isNum = typeof v == "number") && v * 0 == 0) {
              x.s = 1 / v < 0 ? (v = -v, -1) : 1;
              if (v === ~~v) {
                for (e = 0, i = v; i >= 10; i /= 10, e++)
                  ;
                if (e > MAX_EXP) {
                  x.c = x.e = null;
                } else {
                  x.e = e;
                  x.c = [v];
                }
                return;
              }
              str = String(v);
            } else {
              if (!isNumeric.test(str = String(v)))
                return parseNumeric(x, str, isNum);
              x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
            }
            if ((e = str.indexOf(".")) > -1)
              str = str.replace(".", "");
            if ((i = str.search(/e/i)) > 0) {
              if (e < 0)
                e = i;
              e += +str.slice(i + 1);
              str = str.substring(0, i);
            } else if (e < 0) {
              e = str.length;
            }
          } else {
            intCheck(b, 2, ALPHABET.length, "Base");
            if (b == 10) {
              x = new BigNumber2(v);
              return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
            }
            str = String(v);
            if (isNum = typeof v == "number") {
              if (v * 0 != 0)
                return parseNumeric(x, str, isNum, b);
              x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;
              if (BigNumber2.DEBUG && str.replace(/^0\.0*|\./, "").length > 15) {
                throw Error(tooManyDigits + v);
              }
            } else {
              x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
            }
            alphabet = ALPHABET.slice(0, b);
            e = i = 0;
            for (len = str.length; i < len; i++) {
              if (alphabet.indexOf(c = str.charAt(i)) < 0) {
                if (c == ".") {
                  if (i > e) {
                    e = len;
                    continue;
                  }
                } else if (!caseChanged) {
                  if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {
                    caseChanged = true;
                    i = -1;
                    e = 0;
                    continue;
                  }
                }
                return parseNumeric(x, String(v), isNum, b);
              }
            }
            isNum = false;
            str = convertBase(str, b, 10, x.s);
            if ((e = str.indexOf(".")) > -1)
              str = str.replace(".", "");
            else
              e = str.length;
          }
          for (i = 0; str.charCodeAt(i) === 48; i++)
            ;
          for (len = str.length; str.charCodeAt(--len) === 48; )
            ;
          if (str = str.slice(i, ++len)) {
            len -= i;
            if (isNum && BigNumber2.DEBUG && len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {
              throw Error(tooManyDigits + x.s * v);
            }
            if ((e = e - i - 1) > MAX_EXP) {
              x.c = x.e = null;
            } else if (e < MIN_EXP) {
              x.c = [x.e = 0];
            } else {
              x.e = e;
              x.c = [];
              i = (e + 1) % LOG_BASE;
              if (e < 0)
                i += LOG_BASE;
              if (i < len) {
                if (i)
                  x.c.push(+str.slice(0, i));
                for (len -= LOG_BASE; i < len; ) {
                  x.c.push(+str.slice(i, i += LOG_BASE));
                }
                i = LOG_BASE - (str = str.slice(i)).length;
              } else {
                i -= len;
              }
              for (; i--; str += "0")
                ;
              x.c.push(+str);
            }
          } else {
            x.c = [x.e = 0];
          }
        }
        BigNumber2.clone = clone;
        BigNumber2.ROUND_UP = 0;
        BigNumber2.ROUND_DOWN = 1;
        BigNumber2.ROUND_CEIL = 2;
        BigNumber2.ROUND_FLOOR = 3;
        BigNumber2.ROUND_HALF_UP = 4;
        BigNumber2.ROUND_HALF_DOWN = 5;
        BigNumber2.ROUND_HALF_EVEN = 6;
        BigNumber2.ROUND_HALF_CEIL = 7;
        BigNumber2.ROUND_HALF_FLOOR = 8;
        BigNumber2.EUCLID = 9;
        BigNumber2.config = BigNumber2.set = function(obj2) {
          var p, v;
          if (obj2 != null) {
            if (typeof obj2 == "object") {
              if (obj2.hasOwnProperty(p = "DECIMAL_PLACES")) {
                v = obj2[p];
                intCheck(v, 0, MAX, p);
                DECIMAL_PLACES = v;
              }
              if (obj2.hasOwnProperty(p = "ROUNDING_MODE")) {
                v = obj2[p];
                intCheck(v, 0, 8, p);
                ROUNDING_MODE = v;
              }
              if (obj2.hasOwnProperty(p = "EXPONENTIAL_AT")) {
                v = obj2[p];
                if (v && v.pop) {
                  intCheck(v[0], -MAX, 0, p);
                  intCheck(v[1], 0, MAX, p);
                  TO_EXP_NEG = v[0];
                  TO_EXP_POS = v[1];
                } else {
                  intCheck(v, -MAX, MAX, p);
                  TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
                }
              }
              if (obj2.hasOwnProperty(p = "RANGE")) {
                v = obj2[p];
                if (v && v.pop) {
                  intCheck(v[0], -MAX, -1, p);
                  intCheck(v[1], 1, MAX, p);
                  MIN_EXP = v[0];
                  MAX_EXP = v[1];
                } else {
                  intCheck(v, -MAX, MAX, p);
                  if (v) {
                    MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
                  } else {
                    throw Error(bignumberError + p + " cannot be zero: " + v);
                  }
                }
              }
              if (obj2.hasOwnProperty(p = "CRYPTO")) {
                v = obj2[p];
                if (v === !!v) {
                  if (v) {
                    if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                      CRYPTO = v;
                    } else {
                      CRYPTO = !v;
                      throw Error(bignumberError + "crypto unavailable");
                    }
                  } else {
                    CRYPTO = v;
                  }
                } else {
                  throw Error(bignumberError + p + " not true or false: " + v);
                }
              }
              if (obj2.hasOwnProperty(p = "MODULO_MODE")) {
                v = obj2[p];
                intCheck(v, 0, 9, p);
                MODULO_MODE = v;
              }
              if (obj2.hasOwnProperty(p = "POW_PRECISION")) {
                v = obj2[p];
                intCheck(v, 0, MAX, p);
                POW_PRECISION = v;
              }
              if (obj2.hasOwnProperty(p = "FORMAT")) {
                v = obj2[p];
                if (typeof v == "object")
                  FORMAT = v;
                else
                  throw Error(bignumberError + p + " not an object: " + v);
              }
              if (obj2.hasOwnProperty(p = "ALPHABET")) {
                v = obj2[p];
                if (typeof v == "string" && !/^.$|[+-.\s]|(.).*\1/.test(v)) {
                  ALPHABET = v;
                } else {
                  throw Error(bignumberError + p + " invalid: " + v);
                }
              }
            } else {
              throw Error(bignumberError + "Object expected: " + obj2);
            }
          }
          return {
            DECIMAL_PLACES,
            ROUNDING_MODE,
            EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
            RANGE: [MIN_EXP, MAX_EXP],
            CRYPTO,
            MODULO_MODE,
            POW_PRECISION,
            FORMAT,
            ALPHABET
          };
        };
        BigNumber2.isBigNumber = function(v) {
          if (!v || v._isBigNumber !== true)
            return false;
          if (!BigNumber2.DEBUG)
            return true;
          var i, n, c = v.c, e = v.e, s = v.s;
          out:
            if ({}.toString.call(c) == "[object Array]") {
              if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {
                if (c[0] === 0) {
                  if (e === 0 && c.length === 1)
                    return true;
                  break out;
                }
                i = (e + 1) % LOG_BASE;
                if (i < 1)
                  i += LOG_BASE;
                if (String(c[0]).length == i) {
                  for (i = 0; i < c.length; i++) {
                    n = c[i];
                    if (n < 0 || n >= BASE || n !== mathfloor(n))
                      break out;
                  }
                  if (n !== 0)
                    return true;
                }
              }
            } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {
              return true;
            }
          throw Error(bignumberError + "Invalid BigNumber: " + v);
        };
        BigNumber2.maximum = BigNumber2.max = function() {
          return maxOrMin(arguments, P.lt);
        };
        BigNumber2.minimum = BigNumber2.min = function() {
          return maxOrMin(arguments, P.gt);
        };
        BigNumber2.random = function() {
          var pow2_53 = 9007199254740992;
          var random53bitInt = Math.random() * pow2_53 & 2097151 ? function() {
            return mathfloor(Math.random() * pow2_53);
          } : function() {
            return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
          };
          return function(dp) {
            var a, b, e, k, v, i = 0, c = [], rand = new BigNumber2(ONE);
            if (dp == null)
              dp = DECIMAL_PLACES;
            else
              intCheck(dp, 0, MAX);
            k = mathceil(dp / LOG_BASE);
            if (CRYPTO) {
              if (crypto.getRandomValues) {
                a = crypto.getRandomValues(new Uint32Array(k *= 2));
                for (; i < k; ) {
                  v = a[i] * 131072 + (a[i + 1] >>> 11);
                  if (v >= 9e15) {
                    b = crypto.getRandomValues(new Uint32Array(2));
                    a[i] = b[0];
                    a[i + 1] = b[1];
                  } else {
                    c.push(v % 1e14);
                    i += 2;
                  }
                }
                i = k / 2;
              } else if (crypto.randomBytes) {
                a = crypto.randomBytes(k *= 7);
                for (; i < k; ) {
                  v = (a[i] & 31) * 281474976710656 + a[i + 1] * 1099511627776 + a[i + 2] * 4294967296 + a[i + 3] * 16777216 + (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];
                  if (v >= 9e15) {
                    crypto.randomBytes(7).copy(a, i);
                  } else {
                    c.push(v % 1e14);
                    i += 7;
                  }
                }
                i = k / 7;
              } else {
                CRYPTO = false;
                throw Error(bignumberError + "crypto unavailable");
              }
            }
            if (!CRYPTO) {
              for (; i < k; ) {
                v = random53bitInt();
                if (v < 9e15)
                  c[i++] = v % 1e14;
              }
            }
            k = c[--i];
            dp %= LOG_BASE;
            if (k && dp) {
              v = POWS_TEN[LOG_BASE - dp];
              c[i] = mathfloor(k / v) * v;
            }
            for (; c[i] === 0; c.pop(), i--)
              ;
            if (i < 0) {
              c = [e = 0];
            } else {
              for (e = -1; c[0] === 0; c.splice(0, 1), e -= LOG_BASE)
                ;
              for (i = 1, v = c[0]; v >= 10; v /= 10, i++)
                ;
              if (i < LOG_BASE)
                e -= LOG_BASE - i;
            }
            rand.e = e;
            rand.c = c;
            return rand;
          };
        }();
        BigNumber2.sum = function() {
          var i = 1, args = arguments, sum = new BigNumber2(args[0]);
          for (; i < args.length; )
            sum = sum.plus(args[i++]);
          return sum;
        };
        convertBase = function() {
          var decimal = "0123456789";
          function toBaseOut(str, baseIn, baseOut, alphabet) {
            var j, arr = [0], arrL, i = 0, len = str.length;
            for (; i < len; ) {
              for (arrL = arr.length; arrL--; arr[arrL] *= baseIn)
                ;
              arr[0] += alphabet.indexOf(str.charAt(i++));
              for (j = 0; j < arr.length; j++) {
                if (arr[j] > baseOut - 1) {
                  if (arr[j + 1] == null)
                    arr[j + 1] = 0;
                  arr[j + 1] += arr[j] / baseOut | 0;
                  arr[j] %= baseOut;
                }
              }
            }
            return arr.reverse();
          }
          return function(str, baseIn, baseOut, sign, callerIsToString) {
            var alphabet, d, e, k, r, x, xc, y, i = str.indexOf("."), dp = DECIMAL_PLACES, rm = ROUNDING_MODE;
            if (i >= 0) {
              k = POW_PRECISION;
              POW_PRECISION = 0;
              str = str.replace(".", "");
              y = new BigNumber2(baseIn);
              x = y.pow(str.length - i);
              POW_PRECISION = k;
              y.c = toBaseOut(
                toFixedPoint(coeffToString(x.c), x.e, "0"),
                10,
                baseOut,
                decimal
              );
              y.e = y.c.length;
            }
            xc = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet = ALPHABET, decimal) : (alphabet = decimal, ALPHABET));
            e = k = xc.length;
            for (; xc[--k] == 0; xc.pop())
              ;
            if (!xc[0])
              return alphabet.charAt(0);
            if (i < 0) {
              --e;
            } else {
              x.c = xc;
              x.e = e;
              x.s = sign;
              x = div(x, y, dp, rm, baseOut);
              xc = x.c;
              r = x.r;
              e = x.e;
            }
            d = e + dp + 1;
            i = xc[d];
            k = baseOut / 2;
            r = r || d < 0 || xc[d + 1] != null;
            r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : i > k || i == k && (rm == 4 || r || rm == 6 && xc[d - 1] & 1 || rm == (x.s < 0 ? 8 : 7));
            if (d < 1 || !xc[0]) {
              str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
            } else {
              xc.length = d;
              if (r) {
                for (--baseOut; ++xc[--d] > baseOut; ) {
                  xc[d] = 0;
                  if (!d) {
                    ++e;
                    xc = [1].concat(xc);
                  }
                }
              }
              for (k = xc.length; !xc[--k]; )
                ;
              for (i = 0, str = ""; i <= k; str += alphabet.charAt(xc[i++]))
                ;
              str = toFixedPoint(str, e, alphabet.charAt(0));
            }
            return str;
          };
        }();
        div = function() {
          function multiply(x, k, base) {
            var m, temp, xlo, xhi, carry = 0, i = x.length, klo = k % SQRT_BASE, khi = k / SQRT_BASE | 0;
            for (x = x.slice(); i--; ) {
              xlo = x[i] % SQRT_BASE;
              xhi = x[i] / SQRT_BASE | 0;
              m = khi * xlo + xhi * klo;
              temp = klo * xlo + m % SQRT_BASE * SQRT_BASE + carry;
              carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;
              x[i] = temp % base;
            }
            if (carry)
              x = [carry].concat(x);
            return x;
          }
          function compare2(a, b, aL, bL) {
            var i, cmp;
            if (aL != bL) {
              cmp = aL > bL ? 1 : -1;
            } else {
              for (i = cmp = 0; i < aL; i++) {
                if (a[i] != b[i]) {
                  cmp = a[i] > b[i] ? 1 : -1;
                  break;
                }
              }
            }
            return cmp;
          }
          function subtract(a, b, aL, base) {
            var i = 0;
            for (; aL--; ) {
              a[aL] -= i;
              i = a[aL] < b[aL] ? 1 : 0;
              a[aL] = i * base + a[aL] - b[aL];
            }
            for (; !a[0] && a.length > 1; a.splice(0, 1))
              ;
          }
          return function(x, y, dp, rm, base) {
            var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0, yL, yz, s = x.s == y.s ? 1 : -1, xc = x.c, yc = y.c;
            if (!xc || !xc[0] || !yc || !yc[0]) {
              return new BigNumber2(
                // Return NaN if either NaN, or both Infinity or 0.
                !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN : (
                  // Return ±0 if x is ±0 or y is ±Infinity, or return ±Infinity as y is ±0.
                  xc && xc[0] == 0 || !yc ? s * 0 : s / 0
                )
              );
            }
            q = new BigNumber2(s);
            qc = q.c = [];
            e = x.e - y.e;
            s = dp + e + 1;
            if (!base) {
              base = BASE;
              e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
              s = s / LOG_BASE | 0;
            }
            for (i = 0; yc[i] == (xc[i] || 0); i++)
              ;
            if (yc[i] > (xc[i] || 0))
              e--;
            if (s < 0) {
              qc.push(1);
              more = true;
            } else {
              xL = xc.length;
              yL = yc.length;
              i = 0;
              s += 2;
              n = mathfloor(base / (yc[0] + 1));
              if (n > 1) {
                yc = multiply(yc, n, base);
                xc = multiply(xc, n, base);
                yL = yc.length;
                xL = xc.length;
              }
              xi = yL;
              rem = xc.slice(0, yL);
              remL = rem.length;
              for (; remL < yL; rem[remL++] = 0)
                ;
              yz = yc.slice();
              yz = [0].concat(yz);
              yc0 = yc[0];
              if (yc[1] >= base / 2)
                yc0++;
              do {
                n = 0;
                cmp = compare2(yc, rem, yL, remL);
                if (cmp < 0) {
                  rem0 = rem[0];
                  if (yL != remL)
                    rem0 = rem0 * base + (rem[1] || 0);
                  n = mathfloor(rem0 / yc0);
                  if (n > 1) {
                    if (n >= base)
                      n = base - 1;
                    prod = multiply(yc, n, base);
                    prodL = prod.length;
                    remL = rem.length;
                    while (compare2(prod, rem, prodL, remL) == 1) {
                      n--;
                      subtract(prod, yL < prodL ? yz : yc, prodL, base);
                      prodL = prod.length;
                      cmp = 1;
                    }
                  } else {
                    if (n == 0) {
                      cmp = n = 1;
                    }
                    prod = yc.slice();
                    prodL = prod.length;
                  }
                  if (prodL < remL)
                    prod = [0].concat(prod);
                  subtract(rem, prod, remL, base);
                  remL = rem.length;
                  if (cmp == -1) {
                    while (compare2(yc, rem, yL, remL) < 1) {
                      n++;
                      subtract(rem, yL < remL ? yz : yc, remL, base);
                      remL = rem.length;
                    }
                  }
                } else if (cmp === 0) {
                  n++;
                  rem = [0];
                }
                qc[i++] = n;
                if (rem[0]) {
                  rem[remL++] = xc[xi] || 0;
                } else {
                  rem = [xc[xi]];
                  remL = 1;
                }
              } while ((xi++ < xL || rem[0] != null) && s--);
              more = rem[0] != null;
              if (!qc[0])
                qc.splice(0, 1);
            }
            if (base == BASE) {
              for (i = 1, s = qc[0]; s >= 10; s /= 10, i++)
                ;
              round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);
            } else {
              q.e = e;
              q.r = +more;
            }
            return q;
          };
        }();
        function format(n, i, rm, id) {
          var c0, e, ne, len, str;
          if (rm == null)
            rm = ROUNDING_MODE;
          else
            intCheck(rm, 0, 8);
          if (!n.c)
            return n.toString();
          c0 = n.c[0];
          ne = n.e;
          if (i == null) {
            str = coeffToString(n.c);
            str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS) ? toExponential(str, ne) : toFixedPoint(str, ne, "0");
          } else {
            n = round(new BigNumber2(n), i, rm);
            e = n.e;
            str = coeffToString(n.c);
            len = str.length;
            if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {
              for (; len < i; str += "0", len++)
                ;
              str = toExponential(str, e);
            } else {
              i -= ne;
              str = toFixedPoint(str, e, "0");
              if (e + 1 > len) {
                if (--i > 0)
                  for (str += "."; i--; str += "0")
                    ;
              } else {
                i += e - len;
                if (i > 0) {
                  if (e + 1 == len)
                    str += ".";
                  for (; i--; str += "0")
                    ;
                }
              }
            }
          }
          return n.s < 0 && c0 ? "-" + str : str;
        }
        function maxOrMin(args, method) {
          var n, i = 1, m = new BigNumber2(args[0]);
          for (; i < args.length; i++) {
            n = new BigNumber2(args[i]);
            if (!n.s) {
              m = n;
              break;
            } else if (method.call(m, n)) {
              m = n;
            }
          }
          return m;
        }
        function normalise(n, c, e) {
          var i = 1, j = c.length;
          for (; !c[--j]; c.pop())
            ;
          for (j = c[0]; j >= 10; j /= 10, i++)
            ;
          if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {
            n.c = n.e = null;
          } else if (e < MIN_EXP) {
            n.c = [n.e = 0];
          } else {
            n.e = e;
            n.c = c;
          }
          return n;
        }
        parseNumeric = function() {
          var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i, dotAfter = /^([^.]+)\.$/, dotBefore = /^\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
          return function(x, str, isNum, b) {
            var base, s = isNum ? str : str.replace(whitespaceOrPlus, "");
            if (isInfinityOrNaN.test(s)) {
              x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
            } else {
              if (!isNum) {
                s = s.replace(basePrefix, function(m, p1, p2) {
                  base = (p2 = p2.toLowerCase()) == "x" ? 16 : p2 == "b" ? 2 : 8;
                  return !b || b == base ? p1 : m;
                });
                if (b) {
                  base = b;
                  s = s.replace(dotAfter, "$1").replace(dotBefore, "0.$1");
                }
                if (str != s)
                  return new BigNumber2(s, base);
              }
              if (BigNumber2.DEBUG) {
                throw Error(bignumberError + "Not a" + (b ? " base " + b : "") + " number: " + str);
              }
              x.s = null;
            }
            x.c = x.e = null;
          };
        }();
        function round(x, sd, rm, r) {
          var d, i, j, k, n, ni, rd, xc = x.c, pows10 = POWS_TEN;
          if (xc) {
            out: {
              for (d = 1, k = xc[0]; k >= 10; k /= 10, d++)
                ;
              i = sd - d;
              if (i < 0) {
                i += LOG_BASE;
                j = sd;
                n = xc[ni = 0];
                rd = n / pows10[d - j - 1] % 10 | 0;
              } else {
                ni = mathceil((i + 1) / LOG_BASE);
                if (ni >= xc.length) {
                  if (r) {
                    for (; xc.length <= ni; xc.push(0))
                      ;
                    n = rd = 0;
                    d = 1;
                    i %= LOG_BASE;
                    j = i - LOG_BASE + 1;
                  } else {
                    break out;
                  }
                } else {
                  n = k = xc[ni];
                  for (d = 1; k >= 10; k /= 10, d++)
                    ;
                  i %= LOG_BASE;
                  j = i - LOG_BASE + d;
                  rd = j < 0 ? 0 : n / pows10[d - j - 1] % 10 | 0;
                }
              }
              r = r || sd < 0 || // Are there any non-zero digits after the rounding digit?
              // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
              // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
              xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);
              r = rm < 4 ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
              (i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
              if (sd < 1 || !xc[0]) {
                xc.length = 0;
                if (r) {
                  sd -= x.e + 1;
                  xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
                  x.e = -sd || 0;
                } else {
                  xc[0] = x.e = 0;
                }
                return x;
              }
              if (i == 0) {
                xc.length = ni;
                k = 1;
                ni--;
              } else {
                xc.length = ni + 1;
                k = pows10[LOG_BASE - i];
                xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
              }
              if (r) {
                for (; ; ) {
                  if (ni == 0) {
                    for (i = 1, j = xc[0]; j >= 10; j /= 10, i++)
                      ;
                    j = xc[0] += k;
                    for (k = 1; j >= 10; j /= 10, k++)
                      ;
                    if (i != k) {
                      x.e++;
                      if (xc[0] == BASE)
                        xc[0] = 1;
                    }
                    break;
                  } else {
                    xc[ni] += k;
                    if (xc[ni] != BASE)
                      break;
                    xc[ni--] = 0;
                    k = 1;
                  }
                }
              }
              for (i = xc.length; xc[--i] === 0; xc.pop())
                ;
            }
            if (x.e > MAX_EXP) {
              x.c = x.e = null;
            } else if (x.e < MIN_EXP) {
              x.c = [x.e = 0];
            }
          }
          return x;
        }
        function valueOf(n) {
          var str, e = n.e;
          if (e === null)
            return n.toString();
          str = coeffToString(n.c);
          str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(str, e) : toFixedPoint(str, e, "0");
          return n.s < 0 ? "-" + str : str;
        }
        P.absoluteValue = P.abs = function() {
          var x = new BigNumber2(this);
          if (x.s < 0)
            x.s = 1;
          return x;
        };
        P.comparedTo = function(y, b) {
          return compare(this, new BigNumber2(y, b));
        };
        P.decimalPlaces = P.dp = function(dp, rm) {
          var c, n, v, x = this;
          if (dp != null) {
            intCheck(dp, 0, MAX);
            if (rm == null)
              rm = ROUNDING_MODE;
            else
              intCheck(rm, 0, 8);
            return round(new BigNumber2(x), dp + x.e + 1, rm);
          }
          if (!(c = x.c))
            return null;
          n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;
          if (v = c[v])
            for (; v % 10 == 0; v /= 10, n--)
              ;
          if (n < 0)
            n = 0;
          return n;
        };
        P.dividedBy = P.div = function(y, b) {
          return div(this, new BigNumber2(y, b), DECIMAL_PLACES, ROUNDING_MODE);
        };
        P.dividedToIntegerBy = P.idiv = function(y, b) {
          return div(this, new BigNumber2(y, b), 0, 1);
        };
        P.exponentiatedBy = P.pow = function(n, m) {
          var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y, x = this;
          n = new BigNumber2(n);
          if (n.c && !n.isInteger()) {
            throw Error(bignumberError + "Exponent not an integer: " + valueOf(n));
          }
          if (m != null)
            m = new BigNumber2(m);
          nIsBig = n.e > 14;
          if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {
            y = new BigNumber2(Math.pow(+valueOf(x), nIsBig ? 2 - isOdd(n) : +valueOf(n)));
            return m ? y.mod(m) : y;
          }
          nIsNeg = n.s < 0;
          if (m) {
            if (m.c ? !m.c[0] : !m.s)
              return new BigNumber2(NaN);
            isModExp = !nIsNeg && x.isInteger() && m.isInteger();
            if (isModExp)
              x = x.mod(m);
          } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0 ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7 : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {
            k = x.s < 0 && isOdd(n) ? -0 : 0;
            if (x.e > -1)
              k = 1 / k;
            return new BigNumber2(nIsNeg ? 1 / k : k);
          } else if (POW_PRECISION) {
            k = mathceil(POW_PRECISION / LOG_BASE + 2);
          }
          if (nIsBig) {
            half = new BigNumber2(0.5);
            if (nIsNeg)
              n.s = 1;
            nIsOdd = isOdd(n);
          } else {
            i = Math.abs(+valueOf(n));
            nIsOdd = i % 2;
          }
          y = new BigNumber2(ONE);
          for (; ; ) {
            if (nIsOdd) {
              y = y.times(x);
              if (!y.c)
                break;
              if (k) {
                if (y.c.length > k)
                  y.c.length = k;
              } else if (isModExp) {
                y = y.mod(m);
              }
            }
            if (i) {
              i = mathfloor(i / 2);
              if (i === 0)
                break;
              nIsOdd = i % 2;
            } else {
              n = n.times(half);
              round(n, n.e + 1, 1);
              if (n.e > 14) {
                nIsOdd = isOdd(n);
              } else {
                i = +valueOf(n);
                if (i === 0)
                  break;
                nIsOdd = i % 2;
              }
            }
            x = x.times(x);
            if (k) {
              if (x.c && x.c.length > k)
                x.c.length = k;
            } else if (isModExp) {
              x = x.mod(m);
            }
          }
          if (isModExp)
            return y;
          if (nIsNeg)
            y = ONE.div(y);
          return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;
        };
        P.integerValue = function(rm) {
          var n = new BigNumber2(this);
          if (rm == null)
            rm = ROUNDING_MODE;
          else
            intCheck(rm, 0, 8);
          return round(n, n.e + 1, rm);
        };
        P.isEqualTo = P.eq = function(y, b) {
          return compare(this, new BigNumber2(y, b)) === 0;
        };
        P.isFinite = function() {
          return !!this.c;
        };
        P.isGreaterThan = P.gt = function(y, b) {
          return compare(this, new BigNumber2(y, b)) > 0;
        };
        P.isGreaterThanOrEqualTo = P.gte = function(y, b) {
          return (b = compare(this, new BigNumber2(y, b))) === 1 || b === 0;
        };
        P.isInteger = function() {
          return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
        };
        P.isLessThan = P.lt = function(y, b) {
          return compare(this, new BigNumber2(y, b)) < 0;
        };
        P.isLessThanOrEqualTo = P.lte = function(y, b) {
          return (b = compare(this, new BigNumber2(y, b))) === -1 || b === 0;
        };
        P.isNaN = function() {
          return !this.s;
        };
        P.isNegative = function() {
          return this.s < 0;
        };
        P.isPositive = function() {
          return this.s > 0;
        };
        P.isZero = function() {
          return !!this.c && this.c[0] == 0;
        };
        P.minus = function(y, b) {
          var i, j, t, xLTy, x = this, a = x.s;
          y = new BigNumber2(y, b);
          b = y.s;
          if (!a || !b)
            return new BigNumber2(NaN);
          if (a != b) {
            y.s = -b;
            return x.plus(y);
          }
          var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
          if (!xe || !ye) {
            if (!xc || !yc)
              return xc ? (y.s = -b, y) : new BigNumber2(yc ? x : NaN);
            if (!xc[0] || !yc[0]) {
              return yc[0] ? (y.s = -b, y) : new BigNumber2(xc[0] ? x : (
                // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
                ROUNDING_MODE == 3 ? -0 : 0
              ));
            }
          }
          xe = bitFloor(xe);
          ye = bitFloor(ye);
          xc = xc.slice();
          if (a = xe - ye) {
            if (xLTy = a < 0) {
              a = -a;
              t = xc;
            } else {
              ye = xe;
              t = yc;
            }
            t.reverse();
            for (b = a; b--; t.push(0))
              ;
            t.reverse();
          } else {
            j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;
            for (a = b = 0; b < j; b++) {
              if (xc[b] != yc[b]) {
                xLTy = xc[b] < yc[b];
                break;
              }
            }
          }
          if (xLTy)
            t = xc, xc = yc, yc = t, y.s = -y.s;
          b = (j = yc.length) - (i = xc.length);
          if (b > 0)
            for (; b--; xc[i++] = 0)
              ;
          b = BASE - 1;
          for (; j > a; ) {
            if (xc[--j] < yc[j]) {
              for (i = j; i && !xc[--i]; xc[i] = b)
                ;
              --xc[i];
              xc[j] += BASE;
            }
            xc[j] -= yc[j];
          }
          for (; xc[0] == 0; xc.splice(0, 1), --ye)
            ;
          if (!xc[0]) {
            y.s = ROUNDING_MODE == 3 ? -1 : 1;
            y.c = [y.e = 0];
            return y;
          }
          return normalise(y, xc, ye);
        };
        P.modulo = P.mod = function(y, b) {
          var q, s, x = this;
          y = new BigNumber2(y, b);
          if (!x.c || !y.s || y.c && !y.c[0]) {
            return new BigNumber2(NaN);
          } else if (!y.c || x.c && !x.c[0]) {
            return new BigNumber2(x);
          }
          if (MODULO_MODE == 9) {
            s = y.s;
            y.s = 1;
            q = div(x, y, 0, 3);
            y.s = s;
            q.s *= s;
          } else {
            q = div(x, y, 0, MODULO_MODE);
          }
          y = x.minus(q.times(y));
          if (!y.c[0] && MODULO_MODE == 1)
            y.s = x.s;
          return y;
        };
        P.multipliedBy = P.times = function(y, b) {
          var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc, base, sqrtBase, x = this, xc = x.c, yc = (y = new BigNumber2(y, b)).c;
          if (!xc || !yc || !xc[0] || !yc[0]) {
            if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
              y.c = y.e = y.s = null;
            } else {
              y.s *= x.s;
              if (!xc || !yc) {
                y.c = y.e = null;
              } else {
                y.c = [0];
                y.e = 0;
              }
            }
            return y;
          }
          e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
          y.s *= x.s;
          xcL = xc.length;
          ycL = yc.length;
          if (xcL < ycL)
            zc = xc, xc = yc, yc = zc, i = xcL, xcL = ycL, ycL = i;
          for (i = xcL + ycL, zc = []; i--; zc.push(0))
            ;
          base = BASE;
          sqrtBase = SQRT_BASE;
          for (i = ycL; --i >= 0; ) {
            c = 0;
            ylo = yc[i] % sqrtBase;
            yhi = yc[i] / sqrtBase | 0;
            for (k = xcL, j = i + k; j > i; ) {
              xlo = xc[--k] % sqrtBase;
              xhi = xc[k] / sqrtBase | 0;
              m = yhi * xlo + xhi * ylo;
              xlo = ylo * xlo + m % sqrtBase * sqrtBase + zc[j] + c;
              c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;
              zc[j--] = xlo % base;
            }
            zc[j] = c;
          }
          if (c) {
            ++e;
          } else {
            zc.splice(0, 1);
          }
          return normalise(y, zc, e);
        };
        P.negated = function() {
          var x = new BigNumber2(this);
          x.s = -x.s || null;
          return x;
        };
        P.plus = function(y, b) {
          var t, x = this, a = x.s;
          y = new BigNumber2(y, b);
          b = y.s;
          if (!a || !b)
            return new BigNumber2(NaN);
          if (a != b) {
            y.s = -b;
            return x.minus(y);
          }
          var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
          if (!xe || !ye) {
            if (!xc || !yc)
              return new BigNumber2(a / 0);
            if (!xc[0] || !yc[0])
              return yc[0] ? y : new BigNumber2(xc[0] ? x : a * 0);
          }
          xe = bitFloor(xe);
          ye = bitFloor(ye);
          xc = xc.slice();
          if (a = xe - ye) {
            if (a > 0) {
              ye = xe;
              t = yc;
            } else {
              a = -a;
              t = xc;
            }
            t.reverse();
            for (; a--; t.push(0))
              ;
            t.reverse();
          }
          a = xc.length;
          b = yc.length;
          if (a - b < 0)
            t = yc, yc = xc, xc = t, b = a;
          for (a = 0; b; ) {
            a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
            xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
          }
          if (a) {
            xc = [a].concat(xc);
            ++ye;
          }
          return normalise(y, xc, ye);
        };
        P.precision = P.sd = function(sd, rm) {
          var c, n, v, x = this;
          if (sd != null && sd !== !!sd) {
            intCheck(sd, 1, MAX);
            if (rm == null)
              rm = ROUNDING_MODE;
            else
              intCheck(rm, 0, 8);
            return round(new BigNumber2(x), sd, rm);
          }
          if (!(c = x.c))
            return null;
          v = c.length - 1;
          n = v * LOG_BASE + 1;
          if (v = c[v]) {
            for (; v % 10 == 0; v /= 10, n--)
              ;
            for (v = c[0]; v >= 10; v /= 10, n++)
              ;
          }
          if (sd && x.e + 1 > n)
            n = x.e + 1;
          return n;
        };
        P.shiftedBy = function(k) {
          intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
          return this.times("1e" + k);
        };
        P.squareRoot = P.sqrt = function() {
          var m, n, r, rep, t, x = this, c = x.c, s = x.s, e = x.e, dp = DECIMAL_PLACES + 4, half = new BigNumber2("0.5");
          if (s !== 1 || !c || !c[0]) {
            return new BigNumber2(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
          }
          s = Math.sqrt(+valueOf(x));
          if (s == 0 || s == 1 / 0) {
            n = coeffToString(c);
            if ((n.length + e) % 2 == 0)
              n += "0";
            s = Math.sqrt(+n);
            e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);
            if (s == 1 / 0) {
              n = "1e" + e;
            } else {
              n = s.toExponential();
              n = n.slice(0, n.indexOf("e") + 1) + e;
            }
            r = new BigNumber2(n);
          } else {
            r = new BigNumber2(s + "");
          }
          if (r.c[0]) {
            e = r.e;
            s = e + dp;
            if (s < 3)
              s = 0;
            for (; ; ) {
              t = r;
              r = half.times(t.plus(div(x, t, dp, 1)));
              if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {
                if (r.e < e)
                  --s;
                n = n.slice(s - 3, s + 1);
                if (n == "9999" || !rep && n == "4999") {
                  if (!rep) {
                    round(t, t.e + DECIMAL_PLACES + 2, 0);
                    if (t.times(t).eq(x)) {
                      r = t;
                      break;
                    }
                  }
                  dp += 4;
                  s += 4;
                  rep = 1;
                } else {
                  if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
                    round(r, r.e + DECIMAL_PLACES + 2, 1);
                    m = !r.times(r).eq(x);
                  }
                  break;
                }
              }
            }
          }
          return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
        };
        P.toExponential = function(dp, rm) {
          if (dp != null) {
            intCheck(dp, 0, MAX);
            dp++;
          }
          return format(this, dp, rm, 1);
        };
        P.toFixed = function(dp, rm) {
          if (dp != null) {
            intCheck(dp, 0, MAX);
            dp = dp + this.e + 1;
          }
          return format(this, dp, rm);
        };
        P.toFormat = function(dp, rm, format2) {
          var str, x = this;
          if (format2 == null) {
            if (dp != null && rm && typeof rm == "object") {
              format2 = rm;
              rm = null;
            } else if (dp && typeof dp == "object") {
              format2 = dp;
              dp = rm = null;
            } else {
              format2 = FORMAT;
            }
          } else if (typeof format2 != "object") {
            throw Error(bignumberError + "Argument not an object: " + format2);
          }
          str = x.toFixed(dp, rm);
          if (x.c) {
            var i, arr = str.split("."), g1 = +format2.groupSize, g2 = +format2.secondaryGroupSize, groupSeparator = format2.groupSeparator || "", intPart = arr[0], fractionPart = arr[1], isNeg = x.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len = intDigits.length;
            if (g2)
              i = g1, g1 = g2, g2 = i, len -= i;
            if (g1 > 0 && len > 0) {
              i = len % g1 || g1;
              intPart = intDigits.substr(0, i);
              for (; i < len; i += g1)
                intPart += groupSeparator + intDigits.substr(i, g1);
              if (g2 > 0)
                intPart += groupSeparator + intDigits.slice(i);
              if (isNeg)
                intPart = "-" + intPart;
            }
            str = fractionPart ? intPart + (format2.decimalSeparator || "") + ((g2 = +format2.fractionGroupSize) ? fractionPart.replace(
              new RegExp("\\d{" + g2 + "}\\B", "g"),
              "$&" + (format2.fractionGroupSeparator || "")
            ) : fractionPart) : intPart;
          }
          return (format2.prefix || "") + str + (format2.suffix || "");
        };
        P.toFraction = function(md) {
          var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s, x = this, xc = x.c;
          if (md != null) {
            n = new BigNumber2(md);
            if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {
              throw Error(bignumberError + "Argument " + (n.isInteger() ? "out of range: " : "not an integer: ") + valueOf(n));
            }
          }
          if (!xc)
            return new BigNumber2(x);
          d = new BigNumber2(ONE);
          n1 = d0 = new BigNumber2(ONE);
          d1 = n0 = new BigNumber2(ONE);
          s = coeffToString(xc);
          e = d.e = s.length - x.e - 1;
          d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
          md = !md || n.comparedTo(d) > 0 ? e > 0 ? d : n1 : n;
          exp = MAX_EXP;
          MAX_EXP = 1 / 0;
          n = new BigNumber2(s);
          n0.c[0] = 0;
          for (; ; ) {
            q = div(n, d, 0, 1);
            d2 = d0.plus(q.times(d1));
            if (d2.comparedTo(md) == 1)
              break;
            d0 = d1;
            d1 = d2;
            n1 = n0.plus(q.times(d2 = n1));
            n0 = d2;
            d = n.minus(q.times(d2 = d));
            n = d2;
          }
          d2 = div(md.minus(d0), d1, 0, 1);
          n0 = n0.plus(d2.times(n1));
          d0 = d0.plus(d2.times(d1));
          n0.s = n1.s = x.s;
          e = e * 2;
          r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(
            div(n0, d0, e, ROUNDING_MODE).minus(x).abs()
          ) < 1 ? [n1, d1] : [n0, d0];
          MAX_EXP = exp;
          return r;
        };
        P.toNumber = function() {
          return +valueOf(this);
        };
        P.toPrecision = function(sd, rm) {
          if (sd != null)
            intCheck(sd, 1, MAX);
          return format(this, sd, rm, 2);
        };
        P.toString = function(b) {
          var str, n = this, s = n.s, e = n.e;
          if (e === null) {
            if (s) {
              str = "Infinity";
              if (s < 0)
                str = "-" + str;
            } else {
              str = "NaN";
            }
          } else {
            if (b == null) {
              str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(coeffToString(n.c), e) : toFixedPoint(coeffToString(n.c), e, "0");
            } else if (b === 10) {
              n = round(new BigNumber2(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
              str = toFixedPoint(coeffToString(n.c), n.e, "0");
            } else {
              intCheck(b, 2, ALPHABET.length, "Base");
              str = convertBase(toFixedPoint(coeffToString(n.c), e, "0"), 10, b, s, true);
            }
            if (s < 0 && n.c[0])
              str = "-" + str;
          }
          return str;
        };
        P.valueOf = P.toJSON = function() {
          return valueOf(this);
        };
        P._isBigNumber = true;
        if (configObject != null)
          BigNumber2.set(configObject);
        return BigNumber2;
      }
      function bitFloor(n) {
        var i = n | 0;
        return n > 0 || n === i ? i : i - 1;
      }
      function coeffToString(a) {
        var s, z, i = 1, j = a.length, r = a[0] + "";
        for (; i < j; ) {
          s = a[i++] + "";
          z = LOG_BASE - s.length;
          for (; z--; s = "0" + s)
            ;
          r += s;
        }
        for (j = r.length; r.charCodeAt(--j) === 48; )
          ;
        return r.slice(0, j + 1 || 1);
      }
      function compare(x, y) {
        var a, b, xc = x.c, yc = y.c, i = x.s, j = y.s, k = x.e, l = y.e;
        if (!i || !j)
          return null;
        a = xc && !xc[0];
        b = yc && !yc[0];
        if (a || b)
          return a ? b ? 0 : -j : i;
        if (i != j)
          return i;
        a = i < 0;
        b = k == l;
        if (!xc || !yc)
          return b ? 0 : !xc ^ a ? 1 : -1;
        if (!b)
          return k > l ^ a ? 1 : -1;
        j = (k = xc.length) < (l = yc.length) ? k : l;
        for (i = 0; i < j; i++)
          if (xc[i] != yc[i])
            return xc[i] > yc[i] ^ a ? 1 : -1;
        return k == l ? 0 : k > l ^ a ? 1 : -1;
      }
      function intCheck(n, min, max, name) {
        if (n < min || n > max || n !== mathfloor(n)) {
          throw Error(bignumberError + (name || "Argument") + (typeof n == "number" ? n < min || n > max ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(n));
        }
      }
      function isOdd(n) {
        var k = n.c.length - 1;
        return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
      }
      function toExponential(str, e) {
        return (str.length > 1 ? str.charAt(0) + "." + str.slice(1) : str) + (e < 0 ? "e" : "e+") + e;
      }
      function toFixedPoint(str, e, z) {
        var len, zs;
        if (e < 0) {
          for (zs = z + "."; ++e; zs += z)
            ;
          str = zs + str;
        } else {
          len = str.length;
          if (++e > len) {
            for (zs = z, e -= len; --e; zs += z)
              ;
            str += zs;
          } else if (e < len) {
            str = str.slice(0, e) + "." + str.slice(e);
          }
        }
        return str;
      }
      BigNumber = clone();
      BigNumber["default"] = BigNumber.BigNumber = BigNumber;
      if (typeof define == "function" && define.amd) {
        define(function() {
          return BigNumber;
        });
      } else if (typeof module2 != "undefined" && module2.exports) {
        module2.exports = BigNumber;
      } else {
        if (!globalObject2) {
          globalObject2 = typeof self != "undefined" && self ? self : window;
        }
        globalObject2.BigNumber = BigNumber;
      }
    })(exports2);
  }
});

// node_modules/base64-js/index.js
var require_base64_js = __commonJS({
  "node_modules/base64-js/index.js"(exports2) {
    "use strict";
    exports2.byteLength = byteLength;
    exports2.toByteArray = toByteArray;
    exports2.fromByteArray = fromByteArray;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i = 0, len = code.length; i < len; ++i) {
      lookup[i] = code[i];
      revLookup[code.charCodeAt(i)] = i;
    }
    var i;
    var len;
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1)
        validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i2;
      for (i2 = 0; i2 < len2; i2 += 4) {
        tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase64(num) {
      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i2 = start; i2 < end; i2 += 3) {
        tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
        );
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
        );
      }
      return parts.join("");
    }
  }
});

// node_modules/ieee754/index.js
var require_ieee754 = __commonJS({
  "node_modules/ieee754/index.js"(exports2) {
    exports2.read = function(buffer, offset, isLE, mLen, nBytes) {
      var e, m;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i = isLE ? nBytes - 1 : 0;
      var d = isLE ? -1 : 1;
      var s = buffer[offset + i];
      i += d;
      e = s & (1 << -nBits) - 1;
      s >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
      }
      m = e & (1 << -nBits) - 1;
      e >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
      }
      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : (s ? -1 : 1) * Infinity;
      } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
    };
    exports2.write = function(buffer, value, offset, isLE, mLen, nBytes) {
      var e, m, c;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i = isLE ? 0 : nBytes - 1;
      var d = isLE ? 1 : -1;
      var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
          e++;
          c /= 2;
        }
        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value * c - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }
      for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
      }
      e = e << mLen | m;
      eLen += mLen;
      for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
      }
      buffer[offset + i - d] |= s * 128;
    };
  }
});

// node_modules/buffer/index.js
var require_buffer = __commonJS({
  "node_modules/buffer/index.js"(exports2) {
    "use strict";
    var base64 = require_base64_js();
    var ieee754 = require_ieee754();
    var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports2.Buffer = Buffer2;
    exports2.SlowBuffer = SlowBuffer;
    exports2.INSPECT_MAX_BYTES = 50;
    var K_MAX_LENGTH = 2147483647;
    exports2.kMaxLength = K_MAX_LENGTH;
    Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error(
        "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
      );
    }
    function typedArraySupport() {
      try {
        var arr = new Uint8Array(1);
        var proto = { foo: function() {
          return 42;
        } };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e) {
        return false;
      }
    }
    Object.defineProperty(Buffer2.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this))
          return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer2.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this))
          return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length) {
      if (length > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
      }
      var buf = new Uint8Array(length);
      Object.setPrototypeOf(buf, Buffer2.prototype);
      return buf;
    }
    function Buffer2(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        }
        return allocUnsafe(arg);
      }
      return from(arg, encodingOrOffset, length);
    }
    Buffer2.poolSize = 8192;
    function from(value, encodingOrOffset, length) {
      if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }
      if (value == null) {
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof value === "number") {
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      }
      var valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer2.from(valueOf, encodingOrOffset, length);
      }
      var b = fromObject(value);
      if (b)
        return b;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
        return Buffer2.from(
          value[Symbol.toPrimitive]("string"),
          encodingOrOffset,
          length
        );
      }
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    Buffer2.from = function(value, encodingOrOffset, length) {
      return from(value, encodingOrOffset, length);
    };
    Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer2, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    function alloc(size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    Buffer2.alloc = function(size, fill, encoding) {
      return alloc(size, fill, encoding);
    };
    function allocUnsafe(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    Buffer2.allocUnsafe = function(size) {
      return allocUnsafe(size);
    };
    Buffer2.allocUnsafeSlow = function(size) {
      return allocUnsafe(size);
    };
    function fromString(string, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer2.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      var length = byteLength(string, encoding) | 0;
      var buf = createBuffer(length);
      var actual = buf.write(string, encoding);
      if (actual !== length) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    function fromArrayLike(array) {
      var length = array.length < 0 ? 0 : checked(array.length) | 0;
      var buf = createBuffer(length);
      for (var i = 0; i < length; i += 1) {
        buf[i] = array[i] & 255;
      }
      return buf;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        var copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    function fromArrayBuffer(array, byteOffset, length) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      var buf;
      if (byteOffset === void 0 && length === void 0) {
        buf = new Uint8Array(array);
      } else if (length === void 0) {
        buf = new Uint8Array(array, byteOffset);
      } else {
        buf = new Uint8Array(array, byteOffset, length);
      }
      Object.setPrototypeOf(buf, Buffer2.prototype);
      return buf;
    }
    function fromObject(obj2) {
      if (Buffer2.isBuffer(obj2)) {
        var len = checked(obj2.length) | 0;
        var buf = createBuffer(len);
        if (buf.length === 0) {
          return buf;
        }
        obj2.copy(buf, 0, 0, len);
        return buf;
      }
      if (obj2.length !== void 0) {
        if (typeof obj2.length !== "number" || numberIsNaN(obj2.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj2);
      }
      if (obj2.type === "Buffer" && Array.isArray(obj2.data)) {
        return fromArrayLike(obj2.data);
      }
    }
    function checked(length) {
      if (length >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length | 0;
    }
    function SlowBuffer(length) {
      if (+length != length) {
        length = 0;
      }
      return Buffer2.alloc(+length);
    }
    Buffer2.isBuffer = function isBuffer(b) {
      return b != null && b._isBuffer === true && b !== Buffer2.prototype;
    };
    Buffer2.compare = function compare(a, b) {
      if (isInstance(a, Uint8Array))
        a = Buffer2.from(a, a.offset, a.byteLength);
      if (isInstance(b, Uint8Array))
        b = Buffer2.from(b, b.offset, b.byteLength);
      if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      }
      if (a === b)
        return 0;
      var x = a.length;
      var y = b.length;
      for (var i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    Buffer2.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer2.concat = function concat(list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer2.alloc(0);
      }
      var i;
      if (length === void 0) {
        length = 0;
        for (i = 0; i < list.length; ++i) {
          length += list[i].length;
        }
      }
      var buffer = Buffer2.allocUnsafe(length);
      var pos = 0;
      for (i = 0; i < list.length; ++i) {
        var buf = list[i];
        if (isInstance(buf, Uint8Array)) {
          if (pos + buf.length > buffer.length) {
            Buffer2.from(buf).copy(buffer, pos);
          } else {
            Uint8Array.prototype.set.call(
              buffer,
              buf,
              pos
            );
          }
        } else if (!Buffer2.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer, pos);
        }
        pos += buf.length;
      }
      return buffer;
    };
    function byteLength(string, encoding) {
      if (Buffer2.isBuffer(string)) {
        return string.length;
      }
      if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
        return string.byteLength;
      }
      if (typeof string !== "string") {
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
        );
      }
      var len = string.length;
      var mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0)
        return 0;
      var loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes(string).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.byteLength = byteLength;
    function slowToString(encoding, start, end) {
      var loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding)
        encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.prototype._isBuffer = true;
    function swap(b, n, m) {
      var i = b[n];
      b[n] = b[m];
      b[m] = i;
    }
    Buffer2.prototype.swap16 = function swap16() {
      var len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (var i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
      }
      return this;
    };
    Buffer2.prototype.swap32 = function swap32() {
      var len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (var i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }
      return this;
    };
    Buffer2.prototype.swap64 = function swap64() {
      var len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (var i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }
      return this;
    };
    Buffer2.prototype.toString = function toString() {
      var length = this.length;
      if (length === 0)
        return "";
      if (arguments.length === 0)
        return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };
    Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
    Buffer2.prototype.equals = function equals(b) {
      if (!Buffer2.isBuffer(b))
        throw new TypeError("Argument must be a Buffer");
      if (this === b)
        return true;
      return Buffer2.compare(this, b) === 0;
    };
    Buffer2.prototype.inspect = function inspect() {
      var str = "";
      var max = exports2.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max)
        str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
    }
    Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer2.from(target, target.offset, target.byteLength);
      }
      if (!Buffer2.isBuffer(target)) {
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
        );
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target)
        return 0;
      var x = thisEnd - thisStart;
      var y = end - start;
      var len = Math.min(x, y);
      var thisCopy = this.slice(thisStart, thisEnd);
      var targetCopy = target.slice(start, end);
      for (var i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i];
          y = targetCopy[i];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
      if (buffer.length === 0)
        return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer.length - 1;
      }
      if (byteOffset < 0)
        byteOffset = buffer.length + byteOffset;
      if (byteOffset >= buffer.length) {
        if (dir)
          return -1;
        else
          byteOffset = buffer.length - 1;
      } else if (byteOffset < 0) {
        if (dir)
          byteOffset = 0;
        else
          return -1;
      }
      if (typeof val === "string") {
        val = Buffer2.from(val, encoding);
      }
      if (Buffer2.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      var indexSize = 1;
      var arrLength = arr.length;
      var valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read(buf, i2) {
        if (indexSize === 1) {
          return buf[i2];
        } else {
          return buf.readUInt16BE(i2 * indexSize);
        }
      }
      var i;
      if (dir) {
        var foundIndex = -1;
        for (i = byteOffset; i < arrLength; i++) {
          if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1)
              foundIndex = i;
            if (i - foundIndex + 1 === valLength)
              return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1)
              i -= i - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength)
          byteOffset = arrLength - valLength;
        for (i = byteOffset; i >= 0; i--) {
          var found = true;
          for (var j = 0; j < valLength; j++) {
            if (read(arr, i + j) !== read(val, j)) {
              found = false;
              break;
            }
          }
          if (found)
            return i;
        }
      }
      return -1;
    }
    Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf, string, offset, length) {
      offset = Number(offset) || 0;
      var remaining = buf.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }
      var strLen = string.length;
      if (length > strLen / 2) {
        length = strLen / 2;
      }
      for (var i = 0; i < length; ++i) {
        var parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed))
          return i;
        buf[offset + i] = parsed;
      }
      return i;
    }
    function utf8Write(buf, string, offset, length) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
    }
    function asciiWrite(buf, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf, offset, length);
    }
    function base64Write(buf, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf, offset, length);
    }
    function ucs2Write(buf, string, offset, length) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
    }
    Buffer2.prototype.write = function write(string, offset, length, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
          length = length >>> 0;
          if (encoding === void 0)
            encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      }
      var remaining = this.length - offset;
      if (length === void 0 || length > remaining)
        length = remaining;
      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding)
        encoding = "utf8";
      var loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string, offset, length);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string, offset, length);
          case "base64":
            return base64Write(this, string, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string, offset, length);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer2.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf);
      } else {
        return base64.fromByteArray(buf.slice(start, end));
      }
    }
    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      var res = [];
      var i = start;
      while (i < end) {
        var firstByte = buf[i];
        var codePoint = null;
        var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i + bytesPerSequence <= end) {
          var secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              fourthByte = buf[i + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    var MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      var len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      var res = "";
      var i = 0;
      while (i < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
        );
      }
      return res;
    }
    function asciiSlice(buf, start, end) {
      var ret2 = "";
      end = Math.min(buf.length, end);
      for (var i = start; i < end; ++i) {
        ret2 += String.fromCharCode(buf[i] & 127);
      }
      return ret2;
    }
    function latin1Slice(buf, start, end) {
      var ret2 = "";
      end = Math.min(buf.length, end);
      for (var i = start; i < end; ++i) {
        ret2 += String.fromCharCode(buf[i]);
      }
      return ret2;
    }
    function hexSlice(buf, start, end) {
      var len = buf.length;
      if (!start || start < 0)
        start = 0;
      if (!end || end < 0 || end > len)
        end = len;
      var out = "";
      for (var i = start; i < end; ++i) {
        out += hexSliceLookupTable[buf[i]];
      }
      return out;
    }
    function utf16leSlice(buf, start, end) {
      var bytes = buf.slice(start, end);
      var res = "";
      for (var i = 0; i < bytes.length - 1; i += 2) {
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
      }
      return res;
    }
    Buffer2.prototype.slice = function slice(start, end) {
      var len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0)
          start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0)
          end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start)
        end = start;
      var newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer2.prototype);
      return newBuf;
    };
    function checkOffset(offset, ext, length) {
      if (offset % 1 !== 0 || offset < 0)
        throw new RangeError("offset is not uint");
      if (offset + ext > length)
        throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      var val = this[offset];
      var mul = 1;
      var i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      var val = this[offset + --byteLength2];
      var mul = 1;
      while (byteLength2 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength2] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      var val = this[offset];
      var mul = 1;
      var i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      var i = byteLength2;
      var mul = 1;
      var val = this[offset + --i];
      while (i > 0 && (mul *= 256)) {
        val += this[offset + --i] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128))
        return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      var val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      var val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, true, 23, 4);
    };
    Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, false, 23, 4);
    };
    Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, true, 52, 8);
    };
    Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, false, 52, 8);
    };
    function checkInt(buf, value, offset, ext, max, min) {
      if (!Buffer2.isBuffer(buf))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max || value < min)
        throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
    }
    Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      var mul = 1;
      var i = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      var i = byteLength2 - 1;
      var mul = 1;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 255, 0);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
      return offset + 4;
    };
    Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      var i = 0;
      var mul = 1;
      var sub = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      var i = byteLength2 - 1;
      var mul = 1;
      var sub = 0;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 127, -128);
      if (value < 0)
        value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    };
    Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0)
        value = 4294967295 + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    function checkIEEE754(buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
      if (offset < 0)
        throw new RangeError("Index out of range");
    }
    function writeFloat(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
      }
      ieee754.write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    function writeDouble(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
      }
      ieee754.write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
      if (!Buffer2.isBuffer(target))
        throw new TypeError("argument should be a Buffer");
      if (!start)
        start = 0;
      if (!end && end !== 0)
        end = this.length;
      if (targetStart >= target.length)
        targetStart = target.length;
      if (!targetStart)
        targetStart = 0;
      if (end > 0 && end < start)
        end = start;
      if (end === start)
        return 0;
      if (target.length === 0 || this.length === 0)
        return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length)
        throw new RangeError("Index out of range");
      if (end < 0)
        throw new RangeError("sourceEnd out of bounds");
      if (end > this.length)
        end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      var len = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, end),
          targetStart
        );
      }
      return len;
    };
    Buffer2.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          var code = val.charCodeAt(0);
          if (encoding === "utf8" && code < 128 || encoding === "latin1") {
            val = code;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val)
        val = 0;
      var i;
      if (typeof val === "number") {
        for (i = start; i < end; ++i) {
          this[i] = val;
        }
      } else {
        var bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
        var len = bytes.length;
        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }
      return this;
    };
    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2)
        return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function utf8ToBytes(string, units) {
      units = units || Infinity;
      var codePoint;
      var length = string.length;
      var leadSurrogate = null;
      var bytes = [];
      for (var i = 0; i < length; ++i) {
        codePoint = string.charCodeAt(i);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            } else if (i + 1 === length) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0)
            break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0)
            break;
          bytes.push(
            codePoint >> 6 | 192,
            codePoint & 63 | 128
          );
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0)
            break;
          bytes.push(
            codePoint >> 12 | 224,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0)
            break;
          bytes.push(
            codePoint >> 18 | 240,
            codePoint >> 12 & 63 | 128,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function asciiToBytes(str) {
      var byteArray = [];
      for (var i = 0; i < str.length; ++i) {
        byteArray.push(str.charCodeAt(i) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units) {
      var c, hi, lo;
      var byteArray = [];
      for (var i = 0; i < str.length; ++i) {
        if ((units -= 2) < 0)
          break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return base64.toByteArray(base64clean(str));
    }
    function blitBuffer(src, dst, offset, length) {
      for (var i = 0; i < length; ++i) {
        if (i + offset >= dst.length || i >= src.length)
          break;
        dst[i + offset] = src[i];
      }
      return i;
    }
    function isInstance(obj2, type) {
      return obj2 instanceof type || obj2 != null && obj2.constructor != null && obj2.constructor.name != null && obj2.constructor.name === type.name;
    }
    function numberIsNaN(obj2) {
      return obj2 !== obj2;
    }
    var hexSliceLookupTable = function() {
      var alphabet = "0123456789abcdef";
      var table = new Array(256);
      for (var i = 0; i < 16; ++i) {
        var i16 = i * 16;
        for (var j = 0; j < 16; ++j) {
          table[i16 + j] = alphabet[i] + alphabet[j];
        }
      }
      return table;
    }();
  }
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "node_modules/safe-buffer/index.js"(exports2, module2) {
    var buffer = require_buffer();
    var Buffer2 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module2.exports = buffer;
    } else {
      copyProps(buffer, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// node_modules/mysql/lib/protocol/BufferList.js
var require_BufferList = __commonJS({
  "node_modules/mysql/lib/protocol/BufferList.js"(exports2, module2) {
    module2.exports = BufferList;
    function BufferList() {
      this.bufs = [];
      this.size = 0;
    }
    BufferList.prototype.shift = function shift() {
      var buf = this.bufs.shift();
      if (buf) {
        this.size -= buf.length;
      }
      return buf;
    };
    BufferList.prototype.push = function push(buf) {
      if (!buf || !buf.length) {
        return;
      }
      this.bufs.push(buf);
      this.size += buf.length;
    };
  }
});

// node_modules/mysql/lib/protocol/Parser.js
var require_Parser = __commonJS({
  "node_modules/mysql/lib/protocol/Parser.js"(exports2, module2) {
    var PacketHeader = require_PacketHeader();
    var BigNumber = require_bignumber();
    var Buffer2 = require_safe_buffer().Buffer;
    var BufferList = require_BufferList();
    var MAX_PACKET_LENGTH = Math.pow(2, 24) - 1;
    var MUL_32BIT = Math.pow(2, 32);
    var PACKET_HEADER_LENGTH = 4;
    module2.exports = Parser;
    function Parser(options) {
      options = options || {};
      this._supportBigNumbers = options.config && options.config.supportBigNumbers;
      this._buffer = Buffer2.alloc(0);
      this._nextBuffers = new BufferList();
      this._longPacketBuffers = new BufferList();
      this._offset = 0;
      this._packetEnd = null;
      this._packetHeader = null;
      this._packetOffset = null;
      this._onError = options.onError || function(err) {
        throw err;
      };
      this._onPacket = options.onPacket || function() {
      };
      this._nextPacketNumber = 0;
      this._encoding = "utf-8";
      this._paused = false;
    }
    Parser.prototype.write = function write(chunk) {
      this._nextBuffers.push(chunk);
      while (!this._paused) {
        var packetHeader = this._tryReadPacketHeader();
        if (!packetHeader) {
          break;
        }
        if (!this._combineNextBuffers(packetHeader.length)) {
          break;
        }
        this._parsePacket(packetHeader);
      }
    };
    Parser.prototype.append = function append(chunk) {
      if (!chunk || chunk.length === 0) {
        return;
      }
      var sliceEnd = this._buffer.length;
      var sliceStart = this._packetOffset === null ? this._offset : this._packetOffset;
      var sliceLength = sliceEnd - sliceStart;
      var buffer = null;
      var chunks = !(chunk instanceof Array || Array.isArray(chunk)) ? [chunk] : chunk;
      var length = 0;
      var offset = 0;
      for (var i = 0; i < chunks.length; i++) {
        length += chunks[i].length;
      }
      if (sliceLength !== 0) {
        buffer = Buffer2.allocUnsafe(sliceLength + length);
        offset = 0;
        offset += this._buffer.copy(buffer, 0, sliceStart, sliceEnd);
        for (var i = 0; i < chunks.length; i++) {
          offset += chunks[i].copy(buffer, offset);
        }
      } else if (chunks.length > 1) {
        buffer = Buffer2.allocUnsafe(length);
        offset = 0;
        for (var i = 0; i < chunks.length; i++) {
          offset += chunks[i].copy(buffer, offset);
        }
      } else {
        buffer = chunks[0];
      }
      this._buffer = buffer;
      this._offset = this._offset - sliceStart;
      this._packetEnd = this._packetEnd !== null ? this._packetEnd - sliceStart : null;
      this._packetOffset = this._packetOffset !== null ? this._packetOffset - sliceStart : null;
    };
    Parser.prototype.pause = function() {
      this._paused = true;
    };
    Parser.prototype.resume = function() {
      this._paused = false;
      process.nextTick(this.write.bind(this));
    };
    Parser.prototype.peak = function peak(offset) {
      return this._buffer[this._offset + (offset >>> 0)];
    };
    Parser.prototype.parseUnsignedNumber = function parseUnsignedNumber(bytes) {
      if (bytes === 1) {
        return this._buffer[this._offset++];
      }
      var buffer = this._buffer;
      var offset = this._offset + bytes - 1;
      var value = 0;
      if (bytes > 4) {
        var err = new Error("parseUnsignedNumber: Supports only up to 4 bytes");
        err.offset = this._offset - this._packetOffset - 1;
        err.code = "PARSER_UNSIGNED_TOO_LONG";
        throw err;
      }
      while (offset >= this._offset) {
        value = (value << 8 | buffer[offset]) >>> 0;
        offset--;
      }
      this._offset += bytes;
      return value;
    };
    Parser.prototype.parseLengthCodedString = function() {
      var length = this.parseLengthCodedNumber();
      if (length === null) {
        return null;
      }
      return this.parseString(length);
    };
    Parser.prototype.parseLengthCodedBuffer = function() {
      var length = this.parseLengthCodedNumber();
      if (length === null) {
        return null;
      }
      return this.parseBuffer(length);
    };
    Parser.prototype.parseLengthCodedNumber = function parseLengthCodedNumber() {
      if (this._offset >= this._buffer.length) {
        var err = new Error("Parser: read past end");
        err.offset = this._offset - this._packetOffset;
        err.code = "PARSER_READ_PAST_END";
        throw err;
      }
      var bits = this._buffer[this._offset++];
      if (bits <= 250) {
        return bits;
      }
      switch (bits) {
        case 251:
          return null;
        case 252:
          return this.parseUnsignedNumber(2);
        case 253:
          return this.parseUnsignedNumber(3);
        case 254:
          break;
        default:
          var err = new Error("Unexpected first byte" + (bits ? ": 0x" + bits.toString(16) : ""));
          err.offset = this._offset - this._packetOffset - 1;
          err.code = "PARSER_BAD_LENGTH_BYTE";
          throw err;
      }
      var low = this.parseUnsignedNumber(4);
      var high = this.parseUnsignedNumber(4);
      var value;
      if (high >>> 21) {
        value = BigNumber(MUL_32BIT).times(high).plus(low).toString();
        if (this._supportBigNumbers) {
          return value;
        }
        var err = new Error(
          'parseLengthCodedNumber: JS precision range exceeded, number is >= 53 bit: "' + value + '"'
        );
        err.offset = this._offset - this._packetOffset - 8;
        err.code = "PARSER_JS_PRECISION_RANGE_EXCEEDED";
        throw err;
      }
      value = low + MUL_32BIT * high;
      return value;
    };
    Parser.prototype.parseFiller = function(length) {
      return this.parseBuffer(length);
    };
    Parser.prototype.parseNullTerminatedBuffer = function() {
      var end = this._nullByteOffset();
      var value = this._buffer.slice(this._offset, end);
      this._offset = end + 1;
      return value;
    };
    Parser.prototype.parseNullTerminatedString = function() {
      var end = this._nullByteOffset();
      var value = this._buffer.toString(this._encoding, this._offset, end);
      this._offset = end + 1;
      return value;
    };
    Parser.prototype._nullByteOffset = function() {
      var offset = this._offset;
      while (this._buffer[offset] !== 0) {
        offset++;
        if (offset >= this._buffer.length) {
          var err = new Error("Offset of null terminated string not found.");
          err.offset = this._offset - this._packetOffset;
          err.code = "PARSER_MISSING_NULL_BYTE";
          throw err;
        }
      }
      return offset;
    };
    Parser.prototype.parsePacketTerminatedBuffer = function parsePacketTerminatedBuffer() {
      var length = this._packetEnd - this._offset;
      return this.parseBuffer(length);
    };
    Parser.prototype.parsePacketTerminatedString = function() {
      var length = this._packetEnd - this._offset;
      return this.parseString(length);
    };
    Parser.prototype.parseBuffer = function(length) {
      var response = Buffer2.alloc(length);
      this._buffer.copy(response, 0, this._offset, this._offset + length);
      this._offset += length;
      return response;
    };
    Parser.prototype.parseString = function(length) {
      var offset = this._offset;
      var end = offset + length;
      var value = this._buffer.toString(this._encoding, offset, end);
      this._offset = end;
      return value;
    };
    Parser.prototype.parseGeometryValue = function() {
      var buffer = this.parseLengthCodedBuffer();
      var offset = 4;
      if (buffer === null || !buffer.length) {
        return null;
      }
      function parseGeometry() {
        var result = null;
        var byteOrder = buffer.readUInt8(offset);
        offset += 1;
        var wkbType = byteOrder ? buffer.readUInt32LE(offset) : buffer.readUInt32BE(offset);
        offset += 4;
        switch (wkbType) {
          case 1:
            var x = byteOrder ? buffer.readDoubleLE(offset) : buffer.readDoubleBE(offset);
            offset += 8;
            var y = byteOrder ? buffer.readDoubleLE(offset) : buffer.readDoubleBE(offset);
            offset += 8;
            result = { x, y };
            break;
          case 2:
            var numPoints = byteOrder ? buffer.readUInt32LE(offset) : buffer.readUInt32BE(offset);
            offset += 4;
            result = [];
            for (var i = numPoints; i > 0; i--) {
              var x = byteOrder ? buffer.readDoubleLE(offset) : buffer.readDoubleBE(offset);
              offset += 8;
              var y = byteOrder ? buffer.readDoubleLE(offset) : buffer.readDoubleBE(offset);
              offset += 8;
              result.push({ x, y });
            }
            break;
          case 3:
            var numRings = byteOrder ? buffer.readUInt32LE(offset) : buffer.readUInt32BE(offset);
            offset += 4;
            result = [];
            for (var i = numRings; i > 0; i--) {
              var numPoints = byteOrder ? buffer.readUInt32LE(offset) : buffer.readUInt32BE(offset);
              offset += 4;
              var line = [];
              for (var j = numPoints; j > 0; j--) {
                var x = byteOrder ? buffer.readDoubleLE(offset) : buffer.readDoubleBE(offset);
                offset += 8;
                var y = byteOrder ? buffer.readDoubleLE(offset) : buffer.readDoubleBE(offset);
                offset += 8;
                line.push({ x, y });
              }
              result.push(line);
            }
            break;
          case 4:
          case 5:
          case 6:
          case 7:
            var num = byteOrder ? buffer.readUInt32LE(offset) : buffer.readUInt32BE(offset);
            offset += 4;
            var result = [];
            for (var i = num; i > 0; i--) {
              result.push(parseGeometry());
            }
            break;
        }
        return result;
      }
      return parseGeometry();
    };
    Parser.prototype.reachedPacketEnd = function() {
      return this._offset === this._packetEnd;
    };
    Parser.prototype.incrementPacketNumber = function() {
      var currentPacketNumber = this._nextPacketNumber;
      this._nextPacketNumber = (this._nextPacketNumber + 1) % 256;
      return currentPacketNumber;
    };
    Parser.prototype.resetPacketNumber = function() {
      this._nextPacketNumber = 0;
    };
    Parser.prototype.packetLength = function packetLength() {
      if (!this._packetHeader) {
        return null;
      }
      return this._packetHeader.length + this._longPacketBuffers.size;
    };
    Parser.prototype._combineNextBuffers = function _combineNextBuffers(bytes) {
      var length = this._buffer.length - this._offset;
      if (length >= bytes) {
        return true;
      }
      if (length + this._nextBuffers.size < bytes) {
        return false;
      }
      var buffers = [];
      var bytesNeeded = bytes - length;
      while (bytesNeeded > 0) {
        var buffer = this._nextBuffers.shift();
        buffers.push(buffer);
        bytesNeeded -= buffer.length;
      }
      this.append(buffers);
      return true;
    };
    Parser.prototype._combineLongPacketBuffers = function _combineLongPacketBuffers() {
      if (!this._longPacketBuffers.size) {
        return;
      }
      var remainingBytes = this._buffer.length - this._offset;
      var trailingPacketBytes = this._buffer.length - this._packetEnd;
      var buf = null;
      var buffer = Buffer2.allocUnsafe(remainingBytes + this._longPacketBuffers.size);
      var offset = 0;
      while (buf = this._longPacketBuffers.shift()) {
        offset += buf.copy(buffer, offset);
      }
      this._buffer.copy(buffer, offset, this._offset);
      this._buffer = buffer;
      this._offset = 0;
      this._packetEnd = this._buffer.length - trailingPacketBytes;
      this._packetOffset = 0;
    };
    Parser.prototype._parsePacket = function _parsePacket(packetHeader) {
      this._packetEnd = this._offset + packetHeader.length;
      this._packetOffset = this._offset;
      if (packetHeader.length === MAX_PACKET_LENGTH) {
        this._longPacketBuffers.push(this._buffer.slice(this._packetOffset, this._packetEnd));
        this._advanceToNextPacket();
        return;
      }
      this._combineLongPacketBuffers();
      var hadException = true;
      try {
        this._onPacket(packetHeader);
        hadException = false;
      } catch (err) {
        if (!err || typeof err.code !== "string" || err.code.substr(0, 7) !== "PARSER_") {
          throw err;
        }
        this._onError(err);
        hadException = false;
      } finally {
        this._advanceToNextPacket();
        if (hadException) {
          process.nextTick(this.write.bind(this));
        }
      }
    };
    Parser.prototype._tryReadPacketHeader = function _tryReadPacketHeader() {
      if (this._packetHeader) {
        return this._packetHeader;
      }
      if (!this._combineNextBuffers(PACKET_HEADER_LENGTH)) {
        return null;
      }
      this._packetHeader = new PacketHeader(
        this.parseUnsignedNumber(3),
        this.parseUnsignedNumber(1)
      );
      if (this._packetHeader.number !== this._nextPacketNumber) {
        var err = new Error(
          "Packets out of order. Got: " + this._packetHeader.number + " Expected: " + this._nextPacketNumber
        );
        err.code = "PROTOCOL_PACKETS_OUT_OF_ORDER";
        err.fatal = true;
        this._onError(err);
      }
      this.incrementPacketNumber();
      return this._packetHeader;
    };
    Parser.prototype._advanceToNextPacket = function() {
      this._offset = this._packetEnd;
      this._packetHeader = null;
      this._packetEnd = null;
      this._packetOffset = null;
    };
  }
});

// node_modules/mysql/lib/protocol/packets/AuthSwitchRequestPacket.js
var require_AuthSwitchRequestPacket = __commonJS({
  "node_modules/mysql/lib/protocol/packets/AuthSwitchRequestPacket.js"(exports2, module2) {
    module2.exports = AuthSwitchRequestPacket;
    function AuthSwitchRequestPacket(options) {
      options = options || {};
      this.status = 254;
      this.authMethodName = options.authMethodName;
      this.authMethodData = options.authMethodData;
    }
    AuthSwitchRequestPacket.prototype.parse = function parse(parser) {
      this.status = parser.parseUnsignedNumber(1);
      this.authMethodName = parser.parseNullTerminatedString();
      this.authMethodData = parser.parsePacketTerminatedBuffer();
    };
    AuthSwitchRequestPacket.prototype.write = function write(writer) {
      writer.writeUnsignedNumber(1, this.status);
      writer.writeNullTerminatedString(this.authMethodName);
      writer.writeBuffer(this.authMethodData);
    };
  }
});

// node_modules/mysql/lib/protocol/packets/AuthSwitchResponsePacket.js
var require_AuthSwitchResponsePacket = __commonJS({
  "node_modules/mysql/lib/protocol/packets/AuthSwitchResponsePacket.js"(exports2, module2) {
    module2.exports = AuthSwitchResponsePacket;
    function AuthSwitchResponsePacket(options) {
      options = options || {};
      this.data = options.data;
    }
    AuthSwitchResponsePacket.prototype.parse = function parse(parser) {
      this.data = parser.parsePacketTerminatedBuffer();
    };
    AuthSwitchResponsePacket.prototype.write = function write(writer) {
      writer.writeBuffer(this.data);
    };
  }
});

// node_modules/mysql/lib/protocol/packets/ClientAuthenticationPacket.js
var require_ClientAuthenticationPacket = __commonJS({
  "node_modules/mysql/lib/protocol/packets/ClientAuthenticationPacket.js"(exports2, module2) {
    var Buffer2 = require_safe_buffer().Buffer;
    module2.exports = ClientAuthenticationPacket;
    function ClientAuthenticationPacket(options) {
      options = options || {};
      this.clientFlags = options.clientFlags;
      this.maxPacketSize = options.maxPacketSize;
      this.charsetNumber = options.charsetNumber;
      this.filler = void 0;
      this.user = options.user;
      this.scrambleBuff = options.scrambleBuff;
      this.database = options.database;
      this.protocol41 = options.protocol41;
    }
    ClientAuthenticationPacket.prototype.parse = function(parser) {
      if (this.protocol41) {
        this.clientFlags = parser.parseUnsignedNumber(4);
        this.maxPacketSize = parser.parseUnsignedNumber(4);
        this.charsetNumber = parser.parseUnsignedNumber(1);
        this.filler = parser.parseFiller(23);
        this.user = parser.parseNullTerminatedString();
        this.scrambleBuff = parser.parseLengthCodedBuffer();
        this.database = parser.parseNullTerminatedString();
      } else {
        this.clientFlags = parser.parseUnsignedNumber(2);
        this.maxPacketSize = parser.parseUnsignedNumber(3);
        this.user = parser.parseNullTerminatedString();
        this.scrambleBuff = parser.parseBuffer(8);
        this.database = parser.parseLengthCodedBuffer();
      }
    };
    ClientAuthenticationPacket.prototype.write = function(writer) {
      if (this.protocol41) {
        writer.writeUnsignedNumber(4, this.clientFlags);
        writer.writeUnsignedNumber(4, this.maxPacketSize);
        writer.writeUnsignedNumber(1, this.charsetNumber);
        writer.writeFiller(23);
        writer.writeNullTerminatedString(this.user);
        writer.writeLengthCodedBuffer(this.scrambleBuff);
        writer.writeNullTerminatedString(this.database);
      } else {
        writer.writeUnsignedNumber(2, this.clientFlags);
        writer.writeUnsignedNumber(3, this.maxPacketSize);
        writer.writeNullTerminatedString(this.user);
        writer.writeBuffer(this.scrambleBuff);
        if (this.database && this.database.length) {
          writer.writeFiller(1);
          writer.writeBuffer(Buffer2.from(this.database));
        }
      }
    };
  }
});

// node_modules/mysql/lib/protocol/packets/ComChangeUserPacket.js
var require_ComChangeUserPacket = __commonJS({
  "node_modules/mysql/lib/protocol/packets/ComChangeUserPacket.js"(exports2, module2) {
    module2.exports = ComChangeUserPacket;
    function ComChangeUserPacket(options) {
      options = options || {};
      this.command = 17;
      this.user = options.user;
      this.scrambleBuff = options.scrambleBuff;
      this.database = options.database;
      this.charsetNumber = options.charsetNumber;
    }
    ComChangeUserPacket.prototype.parse = function(parser) {
      this.command = parser.parseUnsignedNumber(1);
      this.user = parser.parseNullTerminatedString();
      this.scrambleBuff = parser.parseLengthCodedBuffer();
      this.database = parser.parseNullTerminatedString();
      this.charsetNumber = parser.parseUnsignedNumber(1);
    };
    ComChangeUserPacket.prototype.write = function(writer) {
      writer.writeUnsignedNumber(1, this.command);
      writer.writeNullTerminatedString(this.user);
      writer.writeLengthCodedBuffer(this.scrambleBuff);
      writer.writeNullTerminatedString(this.database);
      writer.writeUnsignedNumber(2, this.charsetNumber);
    };
  }
});

// node_modules/mysql/lib/protocol/packets/ComPingPacket.js
var require_ComPingPacket = __commonJS({
  "node_modules/mysql/lib/protocol/packets/ComPingPacket.js"(exports2, module2) {
    module2.exports = ComPingPacket;
    function ComPingPacket() {
      this.command = 14;
    }
    ComPingPacket.prototype.write = function(writer) {
      writer.writeUnsignedNumber(1, this.command);
    };
    ComPingPacket.prototype.parse = function(parser) {
      this.command = parser.parseUnsignedNumber(1);
    };
  }
});

// node_modules/mysql/lib/protocol/packets/ComQueryPacket.js
var require_ComQueryPacket = __commonJS({
  "node_modules/mysql/lib/protocol/packets/ComQueryPacket.js"(exports2, module2) {
    module2.exports = ComQueryPacket;
    function ComQueryPacket(sql) {
      this.command = 3;
      this.sql = sql;
    }
    ComQueryPacket.prototype.write = function(writer) {
      writer.writeUnsignedNumber(1, this.command);
      writer.writeString(this.sql);
    };
    ComQueryPacket.prototype.parse = function(parser) {
      this.command = parser.parseUnsignedNumber(1);
      this.sql = parser.parsePacketTerminatedString();
    };
  }
});

// node_modules/mysql/lib/protocol/packets/ComQuitPacket.js
var require_ComQuitPacket = __commonJS({
  "node_modules/mysql/lib/protocol/packets/ComQuitPacket.js"(exports2, module2) {
    module2.exports = ComQuitPacket;
    function ComQuitPacket() {
      this.command = 1;
    }
    ComQuitPacket.prototype.parse = function parse(parser) {
      this.command = parser.parseUnsignedNumber(1);
    };
    ComQuitPacket.prototype.write = function write(writer) {
      writer.writeUnsignedNumber(1, this.command);
    };
  }
});

// node_modules/mysql/lib/protocol/packets/ComStatisticsPacket.js
var require_ComStatisticsPacket = __commonJS({
  "node_modules/mysql/lib/protocol/packets/ComStatisticsPacket.js"(exports2, module2) {
    module2.exports = ComStatisticsPacket;
    function ComStatisticsPacket() {
      this.command = 9;
    }
    ComStatisticsPacket.prototype.write = function(writer) {
      writer.writeUnsignedNumber(1, this.command);
    };
    ComStatisticsPacket.prototype.parse = function(parser) {
      this.command = parser.parseUnsignedNumber(1);
    };
  }
});

// node_modules/mysql/lib/protocol/packets/EmptyPacket.js
var require_EmptyPacket = __commonJS({
  "node_modules/mysql/lib/protocol/packets/EmptyPacket.js"(exports2, module2) {
    module2.exports = EmptyPacket;
    function EmptyPacket() {
    }
    EmptyPacket.prototype.parse = function parse() {
    };
    EmptyPacket.prototype.write = function write() {
    };
  }
});

// node_modules/mysql/lib/protocol/packets/EofPacket.js
var require_EofPacket = __commonJS({
  "node_modules/mysql/lib/protocol/packets/EofPacket.js"(exports2, module2) {
    module2.exports = EofPacket;
    function EofPacket(options) {
      options = options || {};
      this.fieldCount = void 0;
      this.warningCount = options.warningCount;
      this.serverStatus = options.serverStatus;
      this.protocol41 = options.protocol41;
    }
    EofPacket.prototype.parse = function(parser) {
      this.fieldCount = parser.parseUnsignedNumber(1);
      if (this.protocol41) {
        this.warningCount = parser.parseUnsignedNumber(2);
        this.serverStatus = parser.parseUnsignedNumber(2);
      }
    };
    EofPacket.prototype.write = function(writer) {
      writer.writeUnsignedNumber(1, 254);
      if (this.protocol41) {
        writer.writeUnsignedNumber(2, this.warningCount);
        writer.writeUnsignedNumber(2, this.serverStatus);
      }
    };
  }
});

// node_modules/mysql/lib/protocol/packets/ErrorPacket.js
var require_ErrorPacket = __commonJS({
  "node_modules/mysql/lib/protocol/packets/ErrorPacket.js"(exports2, module2) {
    module2.exports = ErrorPacket;
    function ErrorPacket(options) {
      options = options || {};
      this.fieldCount = options.fieldCount;
      this.errno = options.errno;
      this.sqlStateMarker = options.sqlStateMarker;
      this.sqlState = options.sqlState;
      this.message = options.message;
    }
    ErrorPacket.prototype.parse = function(parser) {
      this.fieldCount = parser.parseUnsignedNumber(1);
      this.errno = parser.parseUnsignedNumber(2);
      if (parser.peak() === 35) {
        this.sqlStateMarker = parser.parseString(1);
        this.sqlState = parser.parseString(5);
      }
      this.message = parser.parsePacketTerminatedString();
    };
    ErrorPacket.prototype.write = function(writer) {
      writer.writeUnsignedNumber(1, 255);
      writer.writeUnsignedNumber(2, this.errno);
      if (this.sqlStateMarker) {
        writer.writeString(this.sqlStateMarker);
        writer.writeString(this.sqlState);
      }
      writer.writeString(this.message);
    };
  }
});

// node_modules/mysql/lib/protocol/constants/types.js
var require_types = __commonJS({
  "node_modules/mysql/lib/protocol/constants/types.js"(exports2) {
    exports2.DECIMAL = 0;
    exports2.TINY = 1;
    exports2.SHORT = 2;
    exports2.LONG = 3;
    exports2.FLOAT = 4;
    exports2.DOUBLE = 5;
    exports2.NULL = 6;
    exports2.TIMESTAMP = 7;
    exports2.LONGLONG = 8;
    exports2.INT24 = 9;
    exports2.DATE = 10;
    exports2.TIME = 11;
    exports2.DATETIME = 12;
    exports2.YEAR = 13;
    exports2.NEWDATE = 14;
    exports2.VARCHAR = 15;
    exports2.BIT = 16;
    exports2.TIMESTAMP2 = 17;
    exports2.DATETIME2 = 18;
    exports2.TIME2 = 19;
    exports2.JSON = 245;
    exports2.NEWDECIMAL = 246;
    exports2.ENUM = 247;
    exports2.SET = 248;
    exports2.TINY_BLOB = 249;
    exports2.MEDIUM_BLOB = 250;
    exports2.LONG_BLOB = 251;
    exports2.BLOB = 252;
    exports2.VAR_STRING = 253;
    exports2.STRING = 254;
    exports2.GEOMETRY = 255;
    exports2[0] = "DECIMAL";
    exports2[1] = "TINY";
    exports2[2] = "SHORT";
    exports2[3] = "LONG";
    exports2[4] = "FLOAT";
    exports2[5] = "DOUBLE";
    exports2[6] = "NULL";
    exports2[7] = "TIMESTAMP";
    exports2[8] = "LONGLONG";
    exports2[9] = "INT24";
    exports2[10] = "DATE";
    exports2[11] = "TIME";
    exports2[12] = "DATETIME";
    exports2[13] = "YEAR";
    exports2[14] = "NEWDATE";
    exports2[15] = "VARCHAR";
    exports2[16] = "BIT";
    exports2[17] = "TIMESTAMP2";
    exports2[18] = "DATETIME2";
    exports2[19] = "TIME2";
    exports2[245] = "JSON";
    exports2[246] = "NEWDECIMAL";
    exports2[247] = "ENUM";
    exports2[248] = "SET";
    exports2[249] = "TINY_BLOB";
    exports2[250] = "MEDIUM_BLOB";
    exports2[251] = "LONG_BLOB";
    exports2[252] = "BLOB";
    exports2[253] = "VAR_STRING";
    exports2[254] = "STRING";
    exports2[255] = "GEOMETRY";
  }
});

// node_modules/mysql/lib/protocol/packets/Field.js
var require_Field = __commonJS({
  "node_modules/mysql/lib/protocol/packets/Field.js"(exports2, module2) {
    var Types = require_types();
    module2.exports = Field;
    function Field(options) {
      options = options || {};
      this.parser = options.parser;
      this.packet = options.packet;
      this.db = options.packet.db;
      this.table = options.packet.table;
      this.name = options.packet.name;
      this.type = Types[options.packet.type];
      this.length = options.packet.length;
    }
    Field.prototype.string = function() {
      return this.parser.parseLengthCodedString();
    };
    Field.prototype.buffer = function() {
      return this.parser.parseLengthCodedBuffer();
    };
    Field.prototype.geometry = function() {
      return this.parser.parseGeometryValue();
    };
  }
});

// node_modules/mysql/lib/protocol/packets/FieldPacket.js
var require_FieldPacket = __commonJS({
  "node_modules/mysql/lib/protocol/packets/FieldPacket.js"(exports2, module2) {
    module2.exports = FieldPacket;
    function FieldPacket(options) {
      options = options || {};
      this.catalog = options.catalog;
      this.db = options.db;
      this.table = options.table;
      this.orgTable = options.orgTable;
      this.name = options.name;
      this.orgName = options.orgName;
      this.charsetNr = options.charsetNr;
      this.length = options.length;
      this.type = options.type;
      this.flags = options.flags;
      this.decimals = options.decimals;
      this.default = options.default;
      this.zeroFill = options.zeroFill;
      this.protocol41 = options.protocol41;
    }
    FieldPacket.prototype.parse = function(parser) {
      if (this.protocol41) {
        this.catalog = parser.parseLengthCodedString();
        this.db = parser.parseLengthCodedString();
        this.table = parser.parseLengthCodedString();
        this.orgTable = parser.parseLengthCodedString();
        this.name = parser.parseLengthCodedString();
        this.orgName = parser.parseLengthCodedString();
        if (parser.parseLengthCodedNumber() !== 12) {
          var err = new TypeError("Received invalid field length");
          err.code = "PARSER_INVALID_FIELD_LENGTH";
          throw err;
        }
        this.charsetNr = parser.parseUnsignedNumber(2);
        this.length = parser.parseUnsignedNumber(4);
        this.type = parser.parseUnsignedNumber(1);
        this.flags = parser.parseUnsignedNumber(2);
        this.decimals = parser.parseUnsignedNumber(1);
        var filler = parser.parseBuffer(2);
        if (filler[0] !== 0 || filler[1] !== 0) {
          var err = new TypeError("Received invalid filler");
          err.code = "PARSER_INVALID_FILLER";
          throw err;
        }
        this.zeroFill = this.flags & 64 ? true : false;
        if (parser.reachedPacketEnd()) {
          return;
        }
        this.default = parser.parseLengthCodedString();
      } else {
        this.table = parser.parseLengthCodedString();
        this.name = parser.parseLengthCodedString();
        this.length = parser.parseUnsignedNumber(parser.parseUnsignedNumber(1));
        this.type = parser.parseUnsignedNumber(parser.parseUnsignedNumber(1));
      }
    };
    FieldPacket.prototype.write = function(writer) {
      if (this.protocol41) {
        writer.writeLengthCodedString(this.catalog);
        writer.writeLengthCodedString(this.db);
        writer.writeLengthCodedString(this.table);
        writer.writeLengthCodedString(this.orgTable);
        writer.writeLengthCodedString(this.name);
        writer.writeLengthCodedString(this.orgName);
        writer.writeLengthCodedNumber(12);
        writer.writeUnsignedNumber(2, this.charsetNr || 0);
        writer.writeUnsignedNumber(4, this.length || 0);
        writer.writeUnsignedNumber(1, this.type || 0);
        writer.writeUnsignedNumber(2, this.flags || 0);
        writer.writeUnsignedNumber(1, this.decimals || 0);
        writer.writeFiller(2);
        if (this.default !== void 0) {
          writer.writeLengthCodedString(this.default);
        }
      } else {
        writer.writeLengthCodedString(this.table);
        writer.writeLengthCodedString(this.name);
        writer.writeUnsignedNumber(1, 1);
        writer.writeUnsignedNumber(1, this.length);
        writer.writeUnsignedNumber(1, 1);
        writer.writeUnsignedNumber(1, this.type);
      }
    };
  }
});

// node_modules/mysql/lib/protocol/packets/HandshakeInitializationPacket.js
var require_HandshakeInitializationPacket = __commonJS({
  "node_modules/mysql/lib/protocol/packets/HandshakeInitializationPacket.js"(exports2, module2) {
    var Buffer2 = require_safe_buffer().Buffer;
    var Client = require_client();
    module2.exports = HandshakeInitializationPacket;
    function HandshakeInitializationPacket(options) {
      options = options || {};
      this.protocolVersion = options.protocolVersion;
      this.serverVersion = options.serverVersion;
      this.threadId = options.threadId;
      this.scrambleBuff1 = options.scrambleBuff1;
      this.filler1 = options.filler1;
      this.serverCapabilities1 = options.serverCapabilities1;
      this.serverLanguage = options.serverLanguage;
      this.serverStatus = options.serverStatus;
      this.serverCapabilities2 = options.serverCapabilities2;
      this.scrambleLength = options.scrambleLength;
      this.filler2 = options.filler2;
      this.scrambleBuff2 = options.scrambleBuff2;
      this.filler3 = options.filler3;
      this.pluginData = options.pluginData;
      this.protocol41 = options.protocol41;
      if (this.protocol41) {
        this.serverCapabilities1 |= Client.CLIENT_PROTOCOL_41;
      }
    }
    HandshakeInitializationPacket.prototype.parse = function(parser) {
      this.protocolVersion = parser.parseUnsignedNumber(1);
      this.serverVersion = parser.parseNullTerminatedString();
      this.threadId = parser.parseUnsignedNumber(4);
      this.scrambleBuff1 = parser.parseBuffer(8);
      this.filler1 = parser.parseFiller(1);
      this.serverCapabilities1 = parser.parseUnsignedNumber(2);
      this.serverLanguage = parser.parseUnsignedNumber(1);
      this.serverStatus = parser.parseUnsignedNumber(2);
      this.protocol41 = (this.serverCapabilities1 & 1 << 9) > 0;
      if (this.protocol41) {
        this.serverCapabilities2 = parser.parseUnsignedNumber(2);
        this.scrambleLength = parser.parseUnsignedNumber(1);
        this.filler2 = parser.parseFiller(10);
        this.scrambleBuff2 = parser.parseBuffer(12);
        this.filler3 = parser.parseFiller(1);
      } else {
        this.filler2 = parser.parseFiller(13);
      }
      if (parser.reachedPacketEnd()) {
        return;
      }
      this.pluginData = parser.parsePacketTerminatedString();
      var lastChar = this.pluginData.length - 1;
      if (this.pluginData[lastChar] === "\0") {
        this.pluginData = this.pluginData.substr(0, lastChar);
      }
    };
    HandshakeInitializationPacket.prototype.write = function(writer) {
      writer.writeUnsignedNumber(1, this.protocolVersion);
      writer.writeNullTerminatedString(this.serverVersion);
      writer.writeUnsignedNumber(4, this.threadId);
      writer.writeBuffer(this.scrambleBuff1);
      writer.writeFiller(1);
      writer.writeUnsignedNumber(2, this.serverCapabilities1);
      writer.writeUnsignedNumber(1, this.serverLanguage);
      writer.writeUnsignedNumber(2, this.serverStatus);
      if (this.protocol41) {
        writer.writeUnsignedNumber(2, this.serverCapabilities2);
        writer.writeUnsignedNumber(1, this.scrambleLength);
        writer.writeFiller(10);
      }
      writer.writeNullTerminatedBuffer(this.scrambleBuff2);
      if (this.pluginData !== void 0) {
        writer.writeNullTerminatedString(this.pluginData);
      }
    };
    HandshakeInitializationPacket.prototype.scrambleBuff = function() {
      var buffer = null;
      if (typeof this.scrambleBuff2 === "undefined") {
        buffer = Buffer2.from(this.scrambleBuff1);
      } else {
        buffer = Buffer2.allocUnsafe(this.scrambleBuff1.length + this.scrambleBuff2.length);
        this.scrambleBuff1.copy(buffer, 0);
        this.scrambleBuff2.copy(buffer, this.scrambleBuff1.length);
      }
      return buffer;
    };
  }
});

// node_modules/mysql/lib/protocol/packets/LocalDataFilePacket.js
var require_LocalDataFilePacket = __commonJS({
  "node_modules/mysql/lib/protocol/packets/LocalDataFilePacket.js"(exports2, module2) {
    module2.exports = LocalDataFilePacket;
    function LocalDataFilePacket(data) {
      this.data = data;
    }
    LocalDataFilePacket.prototype.write = function(writer) {
      writer.writeBuffer(this.data);
    };
  }
});

// node_modules/mysql/lib/protocol/packets/LocalInfileRequestPacket.js
var require_LocalInfileRequestPacket = __commonJS({
  "node_modules/mysql/lib/protocol/packets/LocalInfileRequestPacket.js"(exports2, module2) {
    module2.exports = LocalInfileRequestPacket;
    function LocalInfileRequestPacket(options) {
      options = options || {};
      this.filename = options.filename;
    }
    LocalInfileRequestPacket.prototype.parse = function parse(parser) {
      if (parser.parseLengthCodedNumber() !== null) {
        var err = new TypeError("Received invalid field length");
        err.code = "PARSER_INVALID_FIELD_LENGTH";
        throw err;
      }
      this.filename = parser.parsePacketTerminatedString();
    };
    LocalInfileRequestPacket.prototype.write = function write(writer) {
      writer.writeLengthCodedNumber(null);
      writer.writeString(this.filename);
    };
  }
});

// node_modules/mysql/lib/protocol/packets/OkPacket.js
var require_OkPacket = __commonJS({
  "node_modules/mysql/lib/protocol/packets/OkPacket.js"(exports2, module2) {
    var ER_UPDATE_INFO_REGEXP = /^[^:0-9]+: [0-9]+[^:0-9]+: ([0-9]+)[^:0-9]+: [0-9]+[^:0-9]*$/;
    module2.exports = OkPacket;
    function OkPacket(options) {
      options = options || {};
      this.fieldCount = void 0;
      this.affectedRows = void 0;
      this.insertId = void 0;
      this.serverStatus = void 0;
      this.warningCount = void 0;
      this.message = void 0;
      this.protocol41 = options.protocol41;
    }
    OkPacket.prototype.parse = function(parser) {
      this.fieldCount = parser.parseUnsignedNumber(1);
      this.affectedRows = parser.parseLengthCodedNumber();
      this.insertId = parser.parseLengthCodedNumber();
      if (this.protocol41) {
        this.serverStatus = parser.parseUnsignedNumber(2);
        this.warningCount = parser.parseUnsignedNumber(2);
      }
      this.message = parser.parsePacketTerminatedString();
      this.changedRows = 0;
      var m = ER_UPDATE_INFO_REGEXP.exec(this.message);
      if (m !== null) {
        this.changedRows = parseInt(m[1], 10);
      }
    };
    OkPacket.prototype.write = function(writer) {
      writer.writeUnsignedNumber(1, 0);
      writer.writeLengthCodedNumber(this.affectedRows || 0);
      writer.writeLengthCodedNumber(this.insertId || 0);
      if (this.protocol41) {
        writer.writeUnsignedNumber(2, this.serverStatus || 0);
        writer.writeUnsignedNumber(2, this.warningCount || 0);
      }
      writer.writeString(this.message);
    };
  }
});

// node_modules/mysql/lib/protocol/packets/OldPasswordPacket.js
var require_OldPasswordPacket = __commonJS({
  "node_modules/mysql/lib/protocol/packets/OldPasswordPacket.js"(exports2, module2) {
    module2.exports = OldPasswordPacket;
    function OldPasswordPacket(options) {
      options = options || {};
      this.scrambleBuff = options.scrambleBuff;
    }
    OldPasswordPacket.prototype.parse = function(parser) {
      this.scrambleBuff = parser.parsePacketTerminatedBuffer();
    };
    OldPasswordPacket.prototype.write = function(writer) {
      writer.writeBuffer(this.scrambleBuff);
    };
  }
});

// node_modules/mysql/lib/protocol/packets/ResultSetHeaderPacket.js
var require_ResultSetHeaderPacket = __commonJS({
  "node_modules/mysql/lib/protocol/packets/ResultSetHeaderPacket.js"(exports2, module2) {
    module2.exports = ResultSetHeaderPacket;
    function ResultSetHeaderPacket(options) {
      options = options || {};
      this.fieldCount = options.fieldCount;
    }
    ResultSetHeaderPacket.prototype.parse = function(parser) {
      this.fieldCount = parser.parseLengthCodedNumber();
    };
    ResultSetHeaderPacket.prototype.write = function(writer) {
      writer.writeLengthCodedNumber(this.fieldCount);
    };
  }
});

// node_modules/mysql/lib/protocol/packets/RowDataPacket.js
var require_RowDataPacket = __commonJS({
  "node_modules/mysql/lib/protocol/packets/RowDataPacket.js"(exports2, module2) {
    var Types = require_types();
    var Charsets = require_charsets();
    var Field = require_Field();
    var IEEE_754_BINARY_64_PRECISION = Math.pow(2, 53);
    module2.exports = RowDataPacket;
    function RowDataPacket() {
    }
    Object.defineProperty(RowDataPacket.prototype, "parse", {
      configurable: true,
      enumerable: false,
      value: parse
    });
    Object.defineProperty(RowDataPacket.prototype, "_typeCast", {
      configurable: true,
      enumerable: false,
      value: typeCast
    });
    function parse(parser, fieldPackets, typeCast2, nestTables, connection) {
      var self2 = this;
      var next = function() {
        return self2._typeCast(fieldPacket, parser, connection.config.timezone, connection.config.supportBigNumbers, connection.config.bigNumberStrings, connection.config.dateStrings);
      };
      for (var i = 0; i < fieldPackets.length; i++) {
        var fieldPacket = fieldPackets[i];
        var value;
        if (typeof typeCast2 === "function") {
          value = typeCast2.apply(connection, [new Field({ packet: fieldPacket, parser }), next]);
        } else {
          value = typeCast2 ? this._typeCast(fieldPacket, parser, connection.config.timezone, connection.config.supportBigNumbers, connection.config.bigNumberStrings, connection.config.dateStrings) : fieldPacket.charsetNr === Charsets.BINARY ? parser.parseLengthCodedBuffer() : parser.parseLengthCodedString();
        }
        if (typeof nestTables === "string" && nestTables.length) {
          this[fieldPacket.table + nestTables + fieldPacket.name] = value;
        } else if (nestTables) {
          this[fieldPacket.table] = this[fieldPacket.table] || {};
          this[fieldPacket.table][fieldPacket.name] = value;
        } else {
          this[fieldPacket.name] = value;
        }
      }
    }
    function typeCast(field, parser, timeZone, supportBigNumbers, bigNumberStrings, dateStrings) {
      var numberString;
      switch (field.type) {
        case Types.TIMESTAMP:
        case Types.TIMESTAMP2:
        case Types.DATE:
        case Types.DATETIME:
        case Types.DATETIME2:
        case Types.NEWDATE:
          var dateString = parser.parseLengthCodedString();
          if (typeMatch(field.type, dateStrings)) {
            return dateString;
          }
          if (dateString === null) {
            return null;
          }
          var originalString = dateString;
          if (field.type === Types.DATE) {
            dateString += " 00:00:00";
          }
          if (timeZone !== "local") {
            dateString += " " + timeZone;
          }
          var dt = new Date(dateString);
          if (isNaN(dt.getTime())) {
            return originalString;
          }
          return dt;
        case Types.TINY:
        case Types.SHORT:
        case Types.LONG:
        case Types.INT24:
        case Types.YEAR:
        case Types.FLOAT:
        case Types.DOUBLE:
          numberString = parser.parseLengthCodedString();
          return numberString === null || field.zeroFill && numberString[0] === "0" ? numberString : Number(numberString);
        case Types.NEWDECIMAL:
        case Types.LONGLONG:
          numberString = parser.parseLengthCodedString();
          return numberString === null || field.zeroFill && numberString[0] === "0" ? numberString : supportBigNumbers && (bigNumberStrings || Number(numberString) >= IEEE_754_BINARY_64_PRECISION || Number(numberString) <= -IEEE_754_BINARY_64_PRECISION) ? numberString : Number(numberString);
        case Types.BIT:
          return parser.parseLengthCodedBuffer();
        case Types.STRING:
        case Types.VAR_STRING:
        case Types.TINY_BLOB:
        case Types.MEDIUM_BLOB:
        case Types.LONG_BLOB:
        case Types.BLOB:
          return field.charsetNr === Charsets.BINARY ? parser.parseLengthCodedBuffer() : parser.parseLengthCodedString();
        case Types.GEOMETRY:
          return parser.parseGeometryValue();
        default:
          return parser.parseLengthCodedString();
      }
    }
    function typeMatch(type, list) {
      if (Array.isArray(list)) {
        return list.indexOf(Types[type]) !== -1;
      } else {
        return Boolean(list);
      }
    }
  }
});

// node_modules/mysql/lib/protocol/packets/SSLRequestPacket.js
var require_SSLRequestPacket = __commonJS({
  "node_modules/mysql/lib/protocol/packets/SSLRequestPacket.js"(exports2, module2) {
    var ClientConstants = require_client();
    module2.exports = SSLRequestPacket;
    function SSLRequestPacket(options) {
      options = options || {};
      this.clientFlags = options.clientFlags | ClientConstants.CLIENT_SSL;
      this.maxPacketSize = options.maxPacketSize;
      this.charsetNumber = options.charsetNumber;
    }
    SSLRequestPacket.prototype.parse = function(parser) {
      this.clientFlags = parser.parseUnsignedNumber(4);
      this.maxPacketSize = parser.parseUnsignedNumber(4);
      this.charsetNumber = parser.parseUnsignedNumber(1);
    };
    SSLRequestPacket.prototype.write = function(writer) {
      writer.writeUnsignedNumber(4, this.clientFlags);
      writer.writeUnsignedNumber(4, this.maxPacketSize);
      writer.writeUnsignedNumber(1, this.charsetNumber);
      writer.writeFiller(23);
    };
  }
});

// node_modules/mysql/lib/protocol/packets/StatisticsPacket.js
var require_StatisticsPacket = __commonJS({
  "node_modules/mysql/lib/protocol/packets/StatisticsPacket.js"(exports2, module2) {
    module2.exports = StatisticsPacket;
    function StatisticsPacket() {
      this.message = void 0;
    }
    StatisticsPacket.prototype.parse = function(parser) {
      this.message = parser.parsePacketTerminatedString();
      var items = this.message.split(/\s\s/);
      for (var i = 0; i < items.length; i++) {
        var m = items[i].match(/^(.+)\:\s+(.+)$/);
        if (m !== null) {
          this[m[1].toLowerCase().replace(/\s/g, "_")] = Number(m[2]);
        }
      }
    };
    StatisticsPacket.prototype.write = function(writer) {
      writer.writeString(this.message);
    };
  }
});

// node_modules/mysql/lib/protocol/packets/UseOldPasswordPacket.js
var require_UseOldPasswordPacket = __commonJS({
  "node_modules/mysql/lib/protocol/packets/UseOldPasswordPacket.js"(exports2, module2) {
    module2.exports = UseOldPasswordPacket;
    function UseOldPasswordPacket(options) {
      options = options || {};
      this.firstByte = options.firstByte || 254;
    }
    UseOldPasswordPacket.prototype.parse = function(parser) {
      this.firstByte = parser.parseUnsignedNumber(1);
    };
    UseOldPasswordPacket.prototype.write = function(writer) {
      writer.writeUnsignedNumber(1, this.firstByte);
    };
  }
});

// node_modules/mysql/lib/protocol/packets/index.js
var require_packets = __commonJS({
  "node_modules/mysql/lib/protocol/packets/index.js"(exports2) {
    exports2.AuthSwitchRequestPacket = require_AuthSwitchRequestPacket();
    exports2.AuthSwitchResponsePacket = require_AuthSwitchResponsePacket();
    exports2.ClientAuthenticationPacket = require_ClientAuthenticationPacket();
    exports2.ComChangeUserPacket = require_ComChangeUserPacket();
    exports2.ComPingPacket = require_ComPingPacket();
    exports2.ComQueryPacket = require_ComQueryPacket();
    exports2.ComQuitPacket = require_ComQuitPacket();
    exports2.ComStatisticsPacket = require_ComStatisticsPacket();
    exports2.EmptyPacket = require_EmptyPacket();
    exports2.EofPacket = require_EofPacket();
    exports2.ErrorPacket = require_ErrorPacket();
    exports2.Field = require_Field();
    exports2.FieldPacket = require_FieldPacket();
    exports2.HandshakeInitializationPacket = require_HandshakeInitializationPacket();
    exports2.LocalDataFilePacket = require_LocalDataFilePacket();
    exports2.LocalInfileRequestPacket = require_LocalInfileRequestPacket();
    exports2.OkPacket = require_OkPacket();
    exports2.OldPasswordPacket = require_OldPasswordPacket();
    exports2.ResultSetHeaderPacket = require_ResultSetHeaderPacket();
    exports2.RowDataPacket = require_RowDataPacket();
    exports2.SSLRequestPacket = require_SSLRequestPacket();
    exports2.StatisticsPacket = require_StatisticsPacket();
    exports2.UseOldPasswordPacket = require_UseOldPasswordPacket();
  }
});

// node_modules/mysql/lib/protocol/constants/errors.js
var require_errors = __commonJS({
  "node_modules/mysql/lib/protocol/constants/errors.js"(exports2) {
    exports2.EE_CANTCREATEFILE = 1;
    exports2.EE_READ = 2;
    exports2.EE_WRITE = 3;
    exports2.EE_BADCLOSE = 4;
    exports2.EE_OUTOFMEMORY = 5;
    exports2.EE_DELETE = 6;
    exports2.EE_LINK = 7;
    exports2.EE_EOFERR = 9;
    exports2.EE_CANTLOCK = 10;
    exports2.EE_CANTUNLOCK = 11;
    exports2.EE_DIR = 12;
    exports2.EE_STAT = 13;
    exports2.EE_CANT_CHSIZE = 14;
    exports2.EE_CANT_OPEN_STREAM = 15;
    exports2.EE_GETWD = 16;
    exports2.EE_SETWD = 17;
    exports2.EE_LINK_WARNING = 18;
    exports2.EE_OPEN_WARNING = 19;
    exports2.EE_DISK_FULL = 20;
    exports2.EE_CANT_MKDIR = 21;
    exports2.EE_UNKNOWN_CHARSET = 22;
    exports2.EE_OUT_OF_FILERESOURCES = 23;
    exports2.EE_CANT_READLINK = 24;
    exports2.EE_CANT_SYMLINK = 25;
    exports2.EE_REALPATH = 26;
    exports2.EE_SYNC = 27;
    exports2.EE_UNKNOWN_COLLATION = 28;
    exports2.EE_FILENOTFOUND = 29;
    exports2.EE_FILE_NOT_CLOSED = 30;
    exports2.EE_CHANGE_OWNERSHIP = 31;
    exports2.EE_CHANGE_PERMISSIONS = 32;
    exports2.EE_CANT_SEEK = 33;
    exports2.EE_CAPACITY_EXCEEDED = 34;
    exports2.HA_ERR_KEY_NOT_FOUND = 120;
    exports2.HA_ERR_FOUND_DUPP_KEY = 121;
    exports2.HA_ERR_INTERNAL_ERROR = 122;
    exports2.HA_ERR_RECORD_CHANGED = 123;
    exports2.HA_ERR_WRONG_INDEX = 124;
    exports2.HA_ERR_CRASHED = 126;
    exports2.HA_ERR_WRONG_IN_RECORD = 127;
    exports2.HA_ERR_OUT_OF_MEM = 128;
    exports2.HA_ERR_NOT_A_TABLE = 130;
    exports2.HA_ERR_WRONG_COMMAND = 131;
    exports2.HA_ERR_OLD_FILE = 132;
    exports2.HA_ERR_NO_ACTIVE_RECORD = 133;
    exports2.HA_ERR_RECORD_DELETED = 134;
    exports2.HA_ERR_RECORD_FILE_FULL = 135;
    exports2.HA_ERR_INDEX_FILE_FULL = 136;
    exports2.HA_ERR_END_OF_FILE = 137;
    exports2.HA_ERR_UNSUPPORTED = 138;
    exports2.HA_ERR_TOO_BIG_ROW = 139;
    exports2.HA_WRONG_CREATE_OPTION = 140;
    exports2.HA_ERR_FOUND_DUPP_UNIQUE = 141;
    exports2.HA_ERR_UNKNOWN_CHARSET = 142;
    exports2.HA_ERR_WRONG_MRG_TABLE_DEF = 143;
    exports2.HA_ERR_CRASHED_ON_REPAIR = 144;
    exports2.HA_ERR_CRASHED_ON_USAGE = 145;
    exports2.HA_ERR_LOCK_WAIT_TIMEOUT = 146;
    exports2.HA_ERR_LOCK_TABLE_FULL = 147;
    exports2.HA_ERR_READ_ONLY_TRANSACTION = 148;
    exports2.HA_ERR_LOCK_DEADLOCK = 149;
    exports2.HA_ERR_CANNOT_ADD_FOREIGN = 150;
    exports2.HA_ERR_NO_REFERENCED_ROW = 151;
    exports2.HA_ERR_ROW_IS_REFERENCED = 152;
    exports2.HA_ERR_NO_SAVEPOINT = 153;
    exports2.HA_ERR_NON_UNIQUE_BLOCK_SIZE = 154;
    exports2.HA_ERR_NO_SUCH_TABLE = 155;
    exports2.HA_ERR_TABLE_EXIST = 156;
    exports2.HA_ERR_NO_CONNECTION = 157;
    exports2.HA_ERR_NULL_IN_SPATIAL = 158;
    exports2.HA_ERR_TABLE_DEF_CHANGED = 159;
    exports2.HA_ERR_NO_PARTITION_FOUND = 160;
    exports2.HA_ERR_RBR_LOGGING_FAILED = 161;
    exports2.HA_ERR_DROP_INDEX_FK = 162;
    exports2.HA_ERR_FOREIGN_DUPLICATE_KEY = 163;
    exports2.HA_ERR_TABLE_NEEDS_UPGRADE = 164;
    exports2.HA_ERR_TABLE_READONLY = 165;
    exports2.HA_ERR_AUTOINC_READ_FAILED = 166;
    exports2.HA_ERR_AUTOINC_ERANGE = 167;
    exports2.HA_ERR_GENERIC = 168;
    exports2.HA_ERR_RECORD_IS_THE_SAME = 169;
    exports2.HA_ERR_LOGGING_IMPOSSIBLE = 170;
    exports2.HA_ERR_CORRUPT_EVENT = 171;
    exports2.HA_ERR_NEW_FILE = 172;
    exports2.HA_ERR_ROWS_EVENT_APPLY = 173;
    exports2.HA_ERR_INITIALIZATION = 174;
    exports2.HA_ERR_FILE_TOO_SHORT = 175;
    exports2.HA_ERR_WRONG_CRC = 176;
    exports2.HA_ERR_TOO_MANY_CONCURRENT_TRXS = 177;
    exports2.HA_ERR_NOT_IN_LOCK_PARTITIONS = 178;
    exports2.HA_ERR_INDEX_COL_TOO_LONG = 179;
    exports2.HA_ERR_INDEX_CORRUPT = 180;
    exports2.HA_ERR_UNDO_REC_TOO_BIG = 181;
    exports2.HA_FTS_INVALID_DOCID = 182;
    exports2.HA_ERR_TABLE_IN_FK_CHECK = 183;
    exports2.HA_ERR_TABLESPACE_EXISTS = 184;
    exports2.HA_ERR_TOO_MANY_FIELDS = 185;
    exports2.HA_ERR_ROW_IN_WRONG_PARTITION = 186;
    exports2.HA_ERR_INNODB_READ_ONLY = 187;
    exports2.HA_ERR_FTS_EXCEED_RESULT_CACHE_LIMIT = 188;
    exports2.HA_ERR_TEMP_FILE_WRITE_FAILURE = 189;
    exports2.HA_ERR_INNODB_FORCED_RECOVERY = 190;
    exports2.HA_ERR_FTS_TOO_MANY_WORDS_IN_PHRASE = 191;
    exports2.HA_ERR_FK_DEPTH_EXCEEDED = 192;
    exports2.HA_MISSING_CREATE_OPTION = 193;
    exports2.HA_ERR_SE_OUT_OF_MEMORY = 194;
    exports2.HA_ERR_TABLE_CORRUPT = 195;
    exports2.HA_ERR_QUERY_INTERRUPTED = 196;
    exports2.HA_ERR_TABLESPACE_MISSING = 197;
    exports2.HA_ERR_TABLESPACE_IS_NOT_EMPTY = 198;
    exports2.HA_ERR_WRONG_FILE_NAME = 199;
    exports2.HA_ERR_NOT_ALLOWED_COMMAND = 200;
    exports2.HA_ERR_COMPUTE_FAILED = 201;
    exports2.ER_HASHCHK = 1e3;
    exports2.ER_NISAMCHK = 1001;
    exports2.ER_NO = 1002;
    exports2.ER_YES = 1003;
    exports2.ER_CANT_CREATE_FILE = 1004;
    exports2.ER_CANT_CREATE_TABLE = 1005;
    exports2.ER_CANT_CREATE_DB = 1006;
    exports2.ER_DB_CREATE_EXISTS = 1007;
    exports2.ER_DB_DROP_EXISTS = 1008;
    exports2.ER_DB_DROP_DELETE = 1009;
    exports2.ER_DB_DROP_RMDIR = 1010;
    exports2.ER_CANT_DELETE_FILE = 1011;
    exports2.ER_CANT_FIND_SYSTEM_REC = 1012;
    exports2.ER_CANT_GET_STAT = 1013;
    exports2.ER_CANT_GET_WD = 1014;
    exports2.ER_CANT_LOCK = 1015;
    exports2.ER_CANT_OPEN_FILE = 1016;
    exports2.ER_FILE_NOT_FOUND = 1017;
    exports2.ER_CANT_READ_DIR = 1018;
    exports2.ER_CANT_SET_WD = 1019;
    exports2.ER_CHECKREAD = 1020;
    exports2.ER_DISK_FULL = 1021;
    exports2.ER_DUP_KEY = 1022;
    exports2.ER_ERROR_ON_CLOSE = 1023;
    exports2.ER_ERROR_ON_READ = 1024;
    exports2.ER_ERROR_ON_RENAME = 1025;
    exports2.ER_ERROR_ON_WRITE = 1026;
    exports2.ER_FILE_USED = 1027;
    exports2.ER_FILSORT_ABORT = 1028;
    exports2.ER_FORM_NOT_FOUND = 1029;
    exports2.ER_GET_ERRNO = 1030;
    exports2.ER_ILLEGAL_HA = 1031;
    exports2.ER_KEY_NOT_FOUND = 1032;
    exports2.ER_NOT_FORM_FILE = 1033;
    exports2.ER_NOT_KEYFILE = 1034;
    exports2.ER_OLD_KEYFILE = 1035;
    exports2.ER_OPEN_AS_READONLY = 1036;
    exports2.ER_OUTOFMEMORY = 1037;
    exports2.ER_OUT_OF_SORTMEMORY = 1038;
    exports2.ER_UNEXPECTED_EOF = 1039;
    exports2.ER_CON_COUNT_ERROR = 1040;
    exports2.ER_OUT_OF_RESOURCES = 1041;
    exports2.ER_BAD_HOST_ERROR = 1042;
    exports2.ER_HANDSHAKE_ERROR = 1043;
    exports2.ER_DBACCESS_DENIED_ERROR = 1044;
    exports2.ER_ACCESS_DENIED_ERROR = 1045;
    exports2.ER_NO_DB_ERROR = 1046;
    exports2.ER_UNKNOWN_COM_ERROR = 1047;
    exports2.ER_BAD_NULL_ERROR = 1048;
    exports2.ER_BAD_DB_ERROR = 1049;
    exports2.ER_TABLE_EXISTS_ERROR = 1050;
    exports2.ER_BAD_TABLE_ERROR = 1051;
    exports2.ER_NON_UNIQ_ERROR = 1052;
    exports2.ER_SERVER_SHUTDOWN = 1053;
    exports2.ER_BAD_FIELD_ERROR = 1054;
    exports2.ER_WRONG_FIELD_WITH_GROUP = 1055;
    exports2.ER_WRONG_GROUP_FIELD = 1056;
    exports2.ER_WRONG_SUM_SELECT = 1057;
    exports2.ER_WRONG_VALUE_COUNT = 1058;
    exports2.ER_TOO_LONG_IDENT = 1059;
    exports2.ER_DUP_FIELDNAME = 1060;
    exports2.ER_DUP_KEYNAME = 1061;
    exports2.ER_DUP_ENTRY = 1062;
    exports2.ER_WRONG_FIELD_SPEC = 1063;
    exports2.ER_PARSE_ERROR = 1064;
    exports2.ER_EMPTY_QUERY = 1065;
    exports2.ER_NONUNIQ_TABLE = 1066;
    exports2.ER_INVALID_DEFAULT = 1067;
    exports2.ER_MULTIPLE_PRI_KEY = 1068;
    exports2.ER_TOO_MANY_KEYS = 1069;
    exports2.ER_TOO_MANY_KEY_PARTS = 1070;
    exports2.ER_TOO_LONG_KEY = 1071;
    exports2.ER_KEY_COLUMN_DOES_NOT_EXITS = 1072;
    exports2.ER_BLOB_USED_AS_KEY = 1073;
    exports2.ER_TOO_BIG_FIELDLENGTH = 1074;
    exports2.ER_WRONG_AUTO_KEY = 1075;
    exports2.ER_READY = 1076;
    exports2.ER_NORMAL_SHUTDOWN = 1077;
    exports2.ER_GOT_SIGNAL = 1078;
    exports2.ER_SHUTDOWN_COMPLETE = 1079;
    exports2.ER_FORCING_CLOSE = 1080;
    exports2.ER_IPSOCK_ERROR = 1081;
    exports2.ER_NO_SUCH_INDEX = 1082;
    exports2.ER_WRONG_FIELD_TERMINATORS = 1083;
    exports2.ER_BLOBS_AND_NO_TERMINATED = 1084;
    exports2.ER_TEXTFILE_NOT_READABLE = 1085;
    exports2.ER_FILE_EXISTS_ERROR = 1086;
    exports2.ER_LOAD_INFO = 1087;
    exports2.ER_ALTER_INFO = 1088;
    exports2.ER_WRONG_SUB_KEY = 1089;
    exports2.ER_CANT_REMOVE_ALL_FIELDS = 1090;
    exports2.ER_CANT_DROP_FIELD_OR_KEY = 1091;
    exports2.ER_INSERT_INFO = 1092;
    exports2.ER_UPDATE_TABLE_USED = 1093;
    exports2.ER_NO_SUCH_THREAD = 1094;
    exports2.ER_KILL_DENIED_ERROR = 1095;
    exports2.ER_NO_TABLES_USED = 1096;
    exports2.ER_TOO_BIG_SET = 1097;
    exports2.ER_NO_UNIQUE_LOGFILE = 1098;
    exports2.ER_TABLE_NOT_LOCKED_FOR_WRITE = 1099;
    exports2.ER_TABLE_NOT_LOCKED = 1100;
    exports2.ER_BLOB_CANT_HAVE_DEFAULT = 1101;
    exports2.ER_WRONG_DB_NAME = 1102;
    exports2.ER_WRONG_TABLE_NAME = 1103;
    exports2.ER_TOO_BIG_SELECT = 1104;
    exports2.ER_UNKNOWN_ERROR = 1105;
    exports2.ER_UNKNOWN_PROCEDURE = 1106;
    exports2.ER_WRONG_PARAMCOUNT_TO_PROCEDURE = 1107;
    exports2.ER_WRONG_PARAMETERS_TO_PROCEDURE = 1108;
    exports2.ER_UNKNOWN_TABLE = 1109;
    exports2.ER_FIELD_SPECIFIED_TWICE = 1110;
    exports2.ER_INVALID_GROUP_FUNC_USE = 1111;
    exports2.ER_UNSUPPORTED_EXTENSION = 1112;
    exports2.ER_TABLE_MUST_HAVE_COLUMNS = 1113;
    exports2.ER_RECORD_FILE_FULL = 1114;
    exports2.ER_UNKNOWN_CHARACTER_SET = 1115;
    exports2.ER_TOO_MANY_TABLES = 1116;
    exports2.ER_TOO_MANY_FIELDS = 1117;
    exports2.ER_TOO_BIG_ROWSIZE = 1118;
    exports2.ER_STACK_OVERRUN = 1119;
    exports2.ER_WRONG_OUTER_JOIN = 1120;
    exports2.ER_NULL_COLUMN_IN_INDEX = 1121;
    exports2.ER_CANT_FIND_UDF = 1122;
    exports2.ER_CANT_INITIALIZE_UDF = 1123;
    exports2.ER_UDF_NO_PATHS = 1124;
    exports2.ER_UDF_EXISTS = 1125;
    exports2.ER_CANT_OPEN_LIBRARY = 1126;
    exports2.ER_CANT_FIND_DL_ENTRY = 1127;
    exports2.ER_FUNCTION_NOT_DEFINED = 1128;
    exports2.ER_HOST_IS_BLOCKED = 1129;
    exports2.ER_HOST_NOT_PRIVILEGED = 1130;
    exports2.ER_PASSWORD_ANONYMOUS_USER = 1131;
    exports2.ER_PASSWORD_NOT_ALLOWED = 1132;
    exports2.ER_PASSWORD_NO_MATCH = 1133;
    exports2.ER_UPDATE_INFO = 1134;
    exports2.ER_CANT_CREATE_THREAD = 1135;
    exports2.ER_WRONG_VALUE_COUNT_ON_ROW = 1136;
    exports2.ER_CANT_REOPEN_TABLE = 1137;
    exports2.ER_INVALID_USE_OF_NULL = 1138;
    exports2.ER_REGEXP_ERROR = 1139;
    exports2.ER_MIX_OF_GROUP_FUNC_AND_FIELDS = 1140;
    exports2.ER_NONEXISTING_GRANT = 1141;
    exports2.ER_TABLEACCESS_DENIED_ERROR = 1142;
    exports2.ER_COLUMNACCESS_DENIED_ERROR = 1143;
    exports2.ER_ILLEGAL_GRANT_FOR_TABLE = 1144;
    exports2.ER_GRANT_WRONG_HOST_OR_USER = 1145;
    exports2.ER_NO_SUCH_TABLE = 1146;
    exports2.ER_NONEXISTING_TABLE_GRANT = 1147;
    exports2.ER_NOT_ALLOWED_COMMAND = 1148;
    exports2.ER_SYNTAX_ERROR = 1149;
    exports2.ER_DELAYED_CANT_CHANGE_LOCK = 1150;
    exports2.ER_TOO_MANY_DELAYED_THREADS = 1151;
    exports2.ER_ABORTING_CONNECTION = 1152;
    exports2.ER_NET_PACKET_TOO_LARGE = 1153;
    exports2.ER_NET_READ_ERROR_FROM_PIPE = 1154;
    exports2.ER_NET_FCNTL_ERROR = 1155;
    exports2.ER_NET_PACKETS_OUT_OF_ORDER = 1156;
    exports2.ER_NET_UNCOMPRESS_ERROR = 1157;
    exports2.ER_NET_READ_ERROR = 1158;
    exports2.ER_NET_READ_INTERRUPTED = 1159;
    exports2.ER_NET_ERROR_ON_WRITE = 1160;
    exports2.ER_NET_WRITE_INTERRUPTED = 1161;
    exports2.ER_TOO_LONG_STRING = 1162;
    exports2.ER_TABLE_CANT_HANDLE_BLOB = 1163;
    exports2.ER_TABLE_CANT_HANDLE_AUTO_INCREMENT = 1164;
    exports2.ER_DELAYED_INSERT_TABLE_LOCKED = 1165;
    exports2.ER_WRONG_COLUMN_NAME = 1166;
    exports2.ER_WRONG_KEY_COLUMN = 1167;
    exports2.ER_WRONG_MRG_TABLE = 1168;
    exports2.ER_DUP_UNIQUE = 1169;
    exports2.ER_BLOB_KEY_WITHOUT_LENGTH = 1170;
    exports2.ER_PRIMARY_CANT_HAVE_NULL = 1171;
    exports2.ER_TOO_MANY_ROWS = 1172;
    exports2.ER_REQUIRES_PRIMARY_KEY = 1173;
    exports2.ER_NO_RAID_COMPILED = 1174;
    exports2.ER_UPDATE_WITHOUT_KEY_IN_SAFE_MODE = 1175;
    exports2.ER_KEY_DOES_NOT_EXITS = 1176;
    exports2.ER_CHECK_NO_SUCH_TABLE = 1177;
    exports2.ER_CHECK_NOT_IMPLEMENTED = 1178;
    exports2.ER_CANT_DO_THIS_DURING_AN_TRANSACTION = 1179;
    exports2.ER_ERROR_DURING_COMMIT = 1180;
    exports2.ER_ERROR_DURING_ROLLBACK = 1181;
    exports2.ER_ERROR_DURING_FLUSH_LOGS = 1182;
    exports2.ER_ERROR_DURING_CHECKPOINT = 1183;
    exports2.ER_NEW_ABORTING_CONNECTION = 1184;
    exports2.ER_DUMP_NOT_IMPLEMENTED = 1185;
    exports2.ER_FLUSH_MASTER_BINLOG_CLOSED = 1186;
    exports2.ER_INDEX_REBUILD = 1187;
    exports2.ER_MASTER = 1188;
    exports2.ER_MASTER_NET_READ = 1189;
    exports2.ER_MASTER_NET_WRITE = 1190;
    exports2.ER_FT_MATCHING_KEY_NOT_FOUND = 1191;
    exports2.ER_LOCK_OR_ACTIVE_TRANSACTION = 1192;
    exports2.ER_UNKNOWN_SYSTEM_VARIABLE = 1193;
    exports2.ER_CRASHED_ON_USAGE = 1194;
    exports2.ER_CRASHED_ON_REPAIR = 1195;
    exports2.ER_WARNING_NOT_COMPLETE_ROLLBACK = 1196;
    exports2.ER_TRANS_CACHE_FULL = 1197;
    exports2.ER_SLAVE_MUST_STOP = 1198;
    exports2.ER_SLAVE_NOT_RUNNING = 1199;
    exports2.ER_BAD_SLAVE = 1200;
    exports2.ER_MASTER_INFO = 1201;
    exports2.ER_SLAVE_THREAD = 1202;
    exports2.ER_TOO_MANY_USER_CONNECTIONS = 1203;
    exports2.ER_SET_CONSTANTS_ONLY = 1204;
    exports2.ER_LOCK_WAIT_TIMEOUT = 1205;
    exports2.ER_LOCK_TABLE_FULL = 1206;
    exports2.ER_READ_ONLY_TRANSACTION = 1207;
    exports2.ER_DROP_DB_WITH_READ_LOCK = 1208;
    exports2.ER_CREATE_DB_WITH_READ_LOCK = 1209;
    exports2.ER_WRONG_ARGUMENTS = 1210;
    exports2.ER_NO_PERMISSION_TO_CREATE_USER = 1211;
    exports2.ER_UNION_TABLES_IN_DIFFERENT_DIR = 1212;
    exports2.ER_LOCK_DEADLOCK = 1213;
    exports2.ER_TABLE_CANT_HANDLE_FT = 1214;
    exports2.ER_CANNOT_ADD_FOREIGN = 1215;
    exports2.ER_NO_REFERENCED_ROW = 1216;
    exports2.ER_ROW_IS_REFERENCED = 1217;
    exports2.ER_CONNECT_TO_MASTER = 1218;
    exports2.ER_QUERY_ON_MASTER = 1219;
    exports2.ER_ERROR_WHEN_EXECUTING_COMMAND = 1220;
    exports2.ER_WRONG_USAGE = 1221;
    exports2.ER_WRONG_NUMBER_OF_COLUMNS_IN_SELECT = 1222;
    exports2.ER_CANT_UPDATE_WITH_READLOCK = 1223;
    exports2.ER_MIXING_NOT_ALLOWED = 1224;
    exports2.ER_DUP_ARGUMENT = 1225;
    exports2.ER_USER_LIMIT_REACHED = 1226;
    exports2.ER_SPECIFIC_ACCESS_DENIED_ERROR = 1227;
    exports2.ER_LOCAL_VARIABLE = 1228;
    exports2.ER_GLOBAL_VARIABLE = 1229;
    exports2.ER_NO_DEFAULT = 1230;
    exports2.ER_WRONG_VALUE_FOR_VAR = 1231;
    exports2.ER_WRONG_TYPE_FOR_VAR = 1232;
    exports2.ER_VAR_CANT_BE_READ = 1233;
    exports2.ER_CANT_USE_OPTION_HERE = 1234;
    exports2.ER_NOT_SUPPORTED_YET = 1235;
    exports2.ER_MASTER_FATAL_ERROR_READING_BINLOG = 1236;
    exports2.ER_SLAVE_IGNORED_TABLE = 1237;
    exports2.ER_INCORRECT_GLOBAL_LOCAL_VAR = 1238;
    exports2.ER_WRONG_FK_DEF = 1239;
    exports2.ER_KEY_REF_DO_NOT_MATCH_TABLE_REF = 1240;
    exports2.ER_OPERAND_COLUMNS = 1241;
    exports2.ER_SUBQUERY_NO_1_ROW = 1242;
    exports2.ER_UNKNOWN_STMT_HANDLER = 1243;
    exports2.ER_CORRUPT_HELP_DB = 1244;
    exports2.ER_CYCLIC_REFERENCE = 1245;
    exports2.ER_AUTO_CONVERT = 1246;
    exports2.ER_ILLEGAL_REFERENCE = 1247;
    exports2.ER_DERIVED_MUST_HAVE_ALIAS = 1248;
    exports2.ER_SELECT_REDUCED = 1249;
    exports2.ER_TABLENAME_NOT_ALLOWED_HERE = 1250;
    exports2.ER_NOT_SUPPORTED_AUTH_MODE = 1251;
    exports2.ER_SPATIAL_CANT_HAVE_NULL = 1252;
    exports2.ER_COLLATION_CHARSET_MISMATCH = 1253;
    exports2.ER_SLAVE_WAS_RUNNING = 1254;
    exports2.ER_SLAVE_WAS_NOT_RUNNING = 1255;
    exports2.ER_TOO_BIG_FOR_UNCOMPRESS = 1256;
    exports2.ER_ZLIB_Z_MEM_ERROR = 1257;
    exports2.ER_ZLIB_Z_BUF_ERROR = 1258;
    exports2.ER_ZLIB_Z_DATA_ERROR = 1259;
    exports2.ER_CUT_VALUE_GROUP_CONCAT = 1260;
    exports2.ER_WARN_TOO_FEW_RECORDS = 1261;
    exports2.ER_WARN_TOO_MANY_RECORDS = 1262;
    exports2.ER_WARN_NULL_TO_NOTNULL = 1263;
    exports2.ER_WARN_DATA_OUT_OF_RANGE = 1264;
    exports2.WARN_DATA_TRUNCATED = 1265;
    exports2.ER_WARN_USING_OTHER_HANDLER = 1266;
    exports2.ER_CANT_AGGREGATE_2COLLATIONS = 1267;
    exports2.ER_DROP_USER = 1268;
    exports2.ER_REVOKE_GRANTS = 1269;
    exports2.ER_CANT_AGGREGATE_3COLLATIONS = 1270;
    exports2.ER_CANT_AGGREGATE_NCOLLATIONS = 1271;
    exports2.ER_VARIABLE_IS_NOT_STRUCT = 1272;
    exports2.ER_UNKNOWN_COLLATION = 1273;
    exports2.ER_SLAVE_IGNORED_SSL_PARAMS = 1274;
    exports2.ER_SERVER_IS_IN_SECURE_AUTH_MODE = 1275;
    exports2.ER_WARN_FIELD_RESOLVED = 1276;
    exports2.ER_BAD_SLAVE_UNTIL_COND = 1277;
    exports2.ER_MISSING_SKIP_SLAVE = 1278;
    exports2.ER_UNTIL_COND_IGNORED = 1279;
    exports2.ER_WRONG_NAME_FOR_INDEX = 1280;
    exports2.ER_WRONG_NAME_FOR_CATALOG = 1281;
    exports2.ER_WARN_QC_RESIZE = 1282;
    exports2.ER_BAD_FT_COLUMN = 1283;
    exports2.ER_UNKNOWN_KEY_CACHE = 1284;
    exports2.ER_WARN_HOSTNAME_WONT_WORK = 1285;
    exports2.ER_UNKNOWN_STORAGE_ENGINE = 1286;
    exports2.ER_WARN_DEPRECATED_SYNTAX = 1287;
    exports2.ER_NON_UPDATABLE_TABLE = 1288;
    exports2.ER_FEATURE_DISABLED = 1289;
    exports2.ER_OPTION_PREVENTS_STATEMENT = 1290;
    exports2.ER_DUPLICATED_VALUE_IN_TYPE = 1291;
    exports2.ER_TRUNCATED_WRONG_VALUE = 1292;
    exports2.ER_TOO_MUCH_AUTO_TIMESTAMP_COLS = 1293;
    exports2.ER_INVALID_ON_UPDATE = 1294;
    exports2.ER_UNSUPPORTED_PS = 1295;
    exports2.ER_GET_ERRMSG = 1296;
    exports2.ER_GET_TEMPORARY_ERRMSG = 1297;
    exports2.ER_UNKNOWN_TIME_ZONE = 1298;
    exports2.ER_WARN_INVALID_TIMESTAMP = 1299;
    exports2.ER_INVALID_CHARACTER_STRING = 1300;
    exports2.ER_WARN_ALLOWED_PACKET_OVERFLOWED = 1301;
    exports2.ER_CONFLICTING_DECLARATIONS = 1302;
    exports2.ER_SP_NO_RECURSIVE_CREATE = 1303;
    exports2.ER_SP_ALREADY_EXISTS = 1304;
    exports2.ER_SP_DOES_NOT_EXIST = 1305;
    exports2.ER_SP_DROP_FAILED = 1306;
    exports2.ER_SP_STORE_FAILED = 1307;
    exports2.ER_SP_LILABEL_MISMATCH = 1308;
    exports2.ER_SP_LABEL_REDEFINE = 1309;
    exports2.ER_SP_LABEL_MISMATCH = 1310;
    exports2.ER_SP_UNINIT_VAR = 1311;
    exports2.ER_SP_BADSELECT = 1312;
    exports2.ER_SP_BADRETURN = 1313;
    exports2.ER_SP_BADSTATEMENT = 1314;
    exports2.ER_UPDATE_LOG_DEPRECATED_IGNORED = 1315;
    exports2.ER_UPDATE_LOG_DEPRECATED_TRANSLATED = 1316;
    exports2.ER_QUERY_INTERRUPTED = 1317;
    exports2.ER_SP_WRONG_NO_OF_ARGS = 1318;
    exports2.ER_SP_COND_MISMATCH = 1319;
    exports2.ER_SP_NORETURN = 1320;
    exports2.ER_SP_NORETURNEND = 1321;
    exports2.ER_SP_BAD_CURSOR_QUERY = 1322;
    exports2.ER_SP_BAD_CURSOR_SELECT = 1323;
    exports2.ER_SP_CURSOR_MISMATCH = 1324;
    exports2.ER_SP_CURSOR_ALREADY_OPEN = 1325;
    exports2.ER_SP_CURSOR_NOT_OPEN = 1326;
    exports2.ER_SP_UNDECLARED_VAR = 1327;
    exports2.ER_SP_WRONG_NO_OF_FETCH_ARGS = 1328;
    exports2.ER_SP_FETCH_NO_DATA = 1329;
    exports2.ER_SP_DUP_PARAM = 1330;
    exports2.ER_SP_DUP_VAR = 1331;
    exports2.ER_SP_DUP_COND = 1332;
    exports2.ER_SP_DUP_CURS = 1333;
    exports2.ER_SP_CANT_ALTER = 1334;
    exports2.ER_SP_SUBSELECT_NYI = 1335;
    exports2.ER_STMT_NOT_ALLOWED_IN_SF_OR_TRG = 1336;
    exports2.ER_SP_VARCOND_AFTER_CURSHNDLR = 1337;
    exports2.ER_SP_CURSOR_AFTER_HANDLER = 1338;
    exports2.ER_SP_CASE_NOT_FOUND = 1339;
    exports2.ER_FPARSER_TOO_BIG_FILE = 1340;
    exports2.ER_FPARSER_BAD_HEADER = 1341;
    exports2.ER_FPARSER_EOF_IN_COMMENT = 1342;
    exports2.ER_FPARSER_ERROR_IN_PARAMETER = 1343;
    exports2.ER_FPARSER_EOF_IN_UNKNOWN_PARAMETER = 1344;
    exports2.ER_VIEW_NO_EXPLAIN = 1345;
    exports2.ER_FRM_UNKNOWN_TYPE = 1346;
    exports2.ER_WRONG_OBJECT = 1347;
    exports2.ER_NONUPDATEABLE_COLUMN = 1348;
    exports2.ER_VIEW_SELECT_DERIVED = 1349;
    exports2.ER_VIEW_SELECT_CLAUSE = 1350;
    exports2.ER_VIEW_SELECT_VARIABLE = 1351;
    exports2.ER_VIEW_SELECT_TMPTABLE = 1352;
    exports2.ER_VIEW_WRONG_LIST = 1353;
    exports2.ER_WARN_VIEW_MERGE = 1354;
    exports2.ER_WARN_VIEW_WITHOUT_KEY = 1355;
    exports2.ER_VIEW_INVALID = 1356;
    exports2.ER_SP_NO_DROP_SP = 1357;
    exports2.ER_SP_GOTO_IN_HNDLR = 1358;
    exports2.ER_TRG_ALREADY_EXISTS = 1359;
    exports2.ER_TRG_DOES_NOT_EXIST = 1360;
    exports2.ER_TRG_ON_VIEW_OR_TEMP_TABLE = 1361;
    exports2.ER_TRG_CANT_CHANGE_ROW = 1362;
    exports2.ER_TRG_NO_SUCH_ROW_IN_TRG = 1363;
    exports2.ER_NO_DEFAULT_FOR_FIELD = 1364;
    exports2.ER_DIVISION_BY_ZERO = 1365;
    exports2.ER_TRUNCATED_WRONG_VALUE_FOR_FIELD = 1366;
    exports2.ER_ILLEGAL_VALUE_FOR_TYPE = 1367;
    exports2.ER_VIEW_NONUPD_CHECK = 1368;
    exports2.ER_VIEW_CHECK_FAILED = 1369;
    exports2.ER_PROCACCESS_DENIED_ERROR = 1370;
    exports2.ER_RELAY_LOG_FAIL = 1371;
    exports2.ER_PASSWD_LENGTH = 1372;
    exports2.ER_UNKNOWN_TARGET_BINLOG = 1373;
    exports2.ER_IO_ERR_LOG_INDEX_READ = 1374;
    exports2.ER_BINLOG_PURGE_PROHIBITED = 1375;
    exports2.ER_FSEEK_FAIL = 1376;
    exports2.ER_BINLOG_PURGE_FATAL_ERR = 1377;
    exports2.ER_LOG_IN_USE = 1378;
    exports2.ER_LOG_PURGE_UNKNOWN_ERR = 1379;
    exports2.ER_RELAY_LOG_INIT = 1380;
    exports2.ER_NO_BINARY_LOGGING = 1381;
    exports2.ER_RESERVED_SYNTAX = 1382;
    exports2.ER_WSAS_FAILED = 1383;
    exports2.ER_DIFF_GROUPS_PROC = 1384;
    exports2.ER_NO_GROUP_FOR_PROC = 1385;
    exports2.ER_ORDER_WITH_PROC = 1386;
    exports2.ER_LOGGING_PROHIBIT_CHANGING_OF = 1387;
    exports2.ER_NO_FILE_MAPPING = 1388;
    exports2.ER_WRONG_MAGIC = 1389;
    exports2.ER_PS_MANY_PARAM = 1390;
    exports2.ER_KEY_PART_0 = 1391;
    exports2.ER_VIEW_CHECKSUM = 1392;
    exports2.ER_VIEW_MULTIUPDATE = 1393;
    exports2.ER_VIEW_NO_INSERT_FIELD_LIST = 1394;
    exports2.ER_VIEW_DELETE_MERGE_VIEW = 1395;
    exports2.ER_CANNOT_USER = 1396;
    exports2.ER_XAER_NOTA = 1397;
    exports2.ER_XAER_INVAL = 1398;
    exports2.ER_XAER_RMFAIL = 1399;
    exports2.ER_XAER_OUTSIDE = 1400;
    exports2.ER_XAER_RMERR = 1401;
    exports2.ER_XA_RBROLLBACK = 1402;
    exports2.ER_NONEXISTING_PROC_GRANT = 1403;
    exports2.ER_PROC_AUTO_GRANT_FAIL = 1404;
    exports2.ER_PROC_AUTO_REVOKE_FAIL = 1405;
    exports2.ER_DATA_TOO_LONG = 1406;
    exports2.ER_SP_BAD_SQLSTATE = 1407;
    exports2.ER_STARTUP = 1408;
    exports2.ER_LOAD_FROM_FIXED_SIZE_ROWS_TO_VAR = 1409;
    exports2.ER_CANT_CREATE_USER_WITH_GRANT = 1410;
    exports2.ER_WRONG_VALUE_FOR_TYPE = 1411;
    exports2.ER_TABLE_DEF_CHANGED = 1412;
    exports2.ER_SP_DUP_HANDLER = 1413;
    exports2.ER_SP_NOT_VAR_ARG = 1414;
    exports2.ER_SP_NO_RETSET = 1415;
    exports2.ER_CANT_CREATE_GEOMETRY_OBJECT = 1416;
    exports2.ER_FAILED_ROUTINE_BREAK_BINLOG = 1417;
    exports2.ER_BINLOG_UNSAFE_ROUTINE = 1418;
    exports2.ER_BINLOG_CREATE_ROUTINE_NEED_SUPER = 1419;
    exports2.ER_EXEC_STMT_WITH_OPEN_CURSOR = 1420;
    exports2.ER_STMT_HAS_NO_OPEN_CURSOR = 1421;
    exports2.ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG = 1422;
    exports2.ER_NO_DEFAULT_FOR_VIEW_FIELD = 1423;
    exports2.ER_SP_NO_RECURSION = 1424;
    exports2.ER_TOO_BIG_SCALE = 1425;
    exports2.ER_TOO_BIG_PRECISION = 1426;
    exports2.ER_M_BIGGER_THAN_D = 1427;
    exports2.ER_WRONG_LOCK_OF_SYSTEM_TABLE = 1428;
    exports2.ER_CONNECT_TO_FOREIGN_DATA_SOURCE = 1429;
    exports2.ER_QUERY_ON_FOREIGN_DATA_SOURCE = 1430;
    exports2.ER_FOREIGN_DATA_SOURCE_DOESNT_EXIST = 1431;
    exports2.ER_FOREIGN_DATA_STRING_INVALID_CANT_CREATE = 1432;
    exports2.ER_FOREIGN_DATA_STRING_INVALID = 1433;
    exports2.ER_CANT_CREATE_FEDERATED_TABLE = 1434;
    exports2.ER_TRG_IN_WRONG_SCHEMA = 1435;
    exports2.ER_STACK_OVERRUN_NEED_MORE = 1436;
    exports2.ER_TOO_LONG_BODY = 1437;
    exports2.ER_WARN_CANT_DROP_DEFAULT_KEYCACHE = 1438;
    exports2.ER_TOO_BIG_DISPLAYWIDTH = 1439;
    exports2.ER_XAER_DUPID = 1440;
    exports2.ER_DATETIME_FUNCTION_OVERFLOW = 1441;
    exports2.ER_CANT_UPDATE_USED_TABLE_IN_SF_OR_TRG = 1442;
    exports2.ER_VIEW_PREVENT_UPDATE = 1443;
    exports2.ER_PS_NO_RECURSION = 1444;
    exports2.ER_SP_CANT_SET_AUTOCOMMIT = 1445;
    exports2.ER_MALFORMED_DEFINER = 1446;
    exports2.ER_VIEW_FRM_NO_USER = 1447;
    exports2.ER_VIEW_OTHER_USER = 1448;
    exports2.ER_NO_SUCH_USER = 1449;
    exports2.ER_FORBID_SCHEMA_CHANGE = 1450;
    exports2.ER_ROW_IS_REFERENCED_2 = 1451;
    exports2.ER_NO_REFERENCED_ROW_2 = 1452;
    exports2.ER_SP_BAD_VAR_SHADOW = 1453;
    exports2.ER_TRG_NO_DEFINER = 1454;
    exports2.ER_OLD_FILE_FORMAT = 1455;
    exports2.ER_SP_RECURSION_LIMIT = 1456;
    exports2.ER_SP_PROC_TABLE_CORRUPT = 1457;
    exports2.ER_SP_WRONG_NAME = 1458;
    exports2.ER_TABLE_NEEDS_UPGRADE = 1459;
    exports2.ER_SP_NO_AGGREGATE = 1460;
    exports2.ER_MAX_PREPARED_STMT_COUNT_REACHED = 1461;
    exports2.ER_VIEW_RECURSIVE = 1462;
    exports2.ER_NON_GROUPING_FIELD_USED = 1463;
    exports2.ER_TABLE_CANT_HANDLE_SPKEYS = 1464;
    exports2.ER_NO_TRIGGERS_ON_SYSTEM_SCHEMA = 1465;
    exports2.ER_REMOVED_SPACES = 1466;
    exports2.ER_AUTOINC_READ_FAILED = 1467;
    exports2.ER_USERNAME = 1468;
    exports2.ER_HOSTNAME = 1469;
    exports2.ER_WRONG_STRING_LENGTH = 1470;
    exports2.ER_NON_INSERTABLE_TABLE = 1471;
    exports2.ER_ADMIN_WRONG_MRG_TABLE = 1472;
    exports2.ER_TOO_HIGH_LEVEL_OF_NESTING_FOR_SELECT = 1473;
    exports2.ER_NAME_BECOMES_EMPTY = 1474;
    exports2.ER_AMBIGUOUS_FIELD_TERM = 1475;
    exports2.ER_FOREIGN_SERVER_EXISTS = 1476;
    exports2.ER_FOREIGN_SERVER_DOESNT_EXIST = 1477;
    exports2.ER_ILLEGAL_HA_CREATE_OPTION = 1478;
    exports2.ER_PARTITION_REQUIRES_VALUES_ERROR = 1479;
    exports2.ER_PARTITION_WRONG_VALUES_ERROR = 1480;
    exports2.ER_PARTITION_MAXVALUE_ERROR = 1481;
    exports2.ER_PARTITION_SUBPARTITION_ERROR = 1482;
    exports2.ER_PARTITION_SUBPART_MIX_ERROR = 1483;
    exports2.ER_PARTITION_WRONG_NO_PART_ERROR = 1484;
    exports2.ER_PARTITION_WRONG_NO_SUBPART_ERROR = 1485;
    exports2.ER_WRONG_EXPR_IN_PARTITION_FUNC_ERROR = 1486;
    exports2.ER_NO_CONST_EXPR_IN_RANGE_OR_LIST_ERROR = 1487;
    exports2.ER_FIELD_NOT_FOUND_PART_ERROR = 1488;
    exports2.ER_LIST_OF_FIELDS_ONLY_IN_HASH_ERROR = 1489;
    exports2.ER_INCONSISTENT_PARTITION_INFO_ERROR = 1490;
    exports2.ER_PARTITION_FUNC_NOT_ALLOWED_ERROR = 1491;
    exports2.ER_PARTITIONS_MUST_BE_DEFINED_ERROR = 1492;
    exports2.ER_RANGE_NOT_INCREASING_ERROR = 1493;
    exports2.ER_INCONSISTENT_TYPE_OF_FUNCTIONS_ERROR = 1494;
    exports2.ER_MULTIPLE_DEF_CONST_IN_LIST_PART_ERROR = 1495;
    exports2.ER_PARTITION_ENTRY_ERROR = 1496;
    exports2.ER_MIX_HANDLER_ERROR = 1497;
    exports2.ER_PARTITION_NOT_DEFINED_ERROR = 1498;
    exports2.ER_TOO_MANY_PARTITIONS_ERROR = 1499;
    exports2.ER_SUBPARTITION_ERROR = 1500;
    exports2.ER_CANT_CREATE_HANDLER_FILE = 1501;
    exports2.ER_BLOB_FIELD_IN_PART_FUNC_ERROR = 1502;
    exports2.ER_UNIQUE_KEY_NEED_ALL_FIELDS_IN_PF = 1503;
    exports2.ER_NO_PARTS_ERROR = 1504;
    exports2.ER_PARTITION_MGMT_ON_NONPARTITIONED = 1505;
    exports2.ER_FOREIGN_KEY_ON_PARTITIONED = 1506;
    exports2.ER_DROP_PARTITION_NON_EXISTENT = 1507;
    exports2.ER_DROP_LAST_PARTITION = 1508;
    exports2.ER_COALESCE_ONLY_ON_HASH_PARTITION = 1509;
    exports2.ER_REORG_HASH_ONLY_ON_SAME_NO = 1510;
    exports2.ER_REORG_NO_PARAM_ERROR = 1511;
    exports2.ER_ONLY_ON_RANGE_LIST_PARTITION = 1512;
    exports2.ER_ADD_PARTITION_SUBPART_ERROR = 1513;
    exports2.ER_ADD_PARTITION_NO_NEW_PARTITION = 1514;
    exports2.ER_COALESCE_PARTITION_NO_PARTITION = 1515;
    exports2.ER_REORG_PARTITION_NOT_EXIST = 1516;
    exports2.ER_SAME_NAME_PARTITION = 1517;
    exports2.ER_NO_BINLOG_ERROR = 1518;
    exports2.ER_CONSECUTIVE_REORG_PARTITIONS = 1519;
    exports2.ER_REORG_OUTSIDE_RANGE = 1520;
    exports2.ER_PARTITION_FUNCTION_FAILURE = 1521;
    exports2.ER_PART_STATE_ERROR = 1522;
    exports2.ER_LIMITED_PART_RANGE = 1523;
    exports2.ER_PLUGIN_IS_NOT_LOADED = 1524;
    exports2.ER_WRONG_VALUE = 1525;
    exports2.ER_NO_PARTITION_FOR_GIVEN_VALUE = 1526;
    exports2.ER_FILEGROUP_OPTION_ONLY_ONCE = 1527;
    exports2.ER_CREATE_FILEGROUP_FAILED = 1528;
    exports2.ER_DROP_FILEGROUP_FAILED = 1529;
    exports2.ER_TABLESPACE_AUTO_EXTEND_ERROR = 1530;
    exports2.ER_WRONG_SIZE_NUMBER = 1531;
    exports2.ER_SIZE_OVERFLOW_ERROR = 1532;
    exports2.ER_ALTER_FILEGROUP_FAILED = 1533;
    exports2.ER_BINLOG_ROW_LOGGING_FAILED = 1534;
    exports2.ER_BINLOG_ROW_WRONG_TABLE_DEF = 1535;
    exports2.ER_BINLOG_ROW_RBR_TO_SBR = 1536;
    exports2.ER_EVENT_ALREADY_EXISTS = 1537;
    exports2.ER_EVENT_STORE_FAILED = 1538;
    exports2.ER_EVENT_DOES_NOT_EXIST = 1539;
    exports2.ER_EVENT_CANT_ALTER = 1540;
    exports2.ER_EVENT_DROP_FAILED = 1541;
    exports2.ER_EVENT_INTERVAL_NOT_POSITIVE_OR_TOO_BIG = 1542;
    exports2.ER_EVENT_ENDS_BEFORE_STARTS = 1543;
    exports2.ER_EVENT_EXEC_TIME_IN_THE_PAST = 1544;
    exports2.ER_EVENT_OPEN_TABLE_FAILED = 1545;
    exports2.ER_EVENT_NEITHER_M_EXPR_NOR_M_AT = 1546;
    exports2.ER_COL_COUNT_DOESNT_MATCH_CORRUPTED = 1547;
    exports2.ER_CANNOT_LOAD_FROM_TABLE = 1548;
    exports2.ER_EVENT_CANNOT_DELETE = 1549;
    exports2.ER_EVENT_COMPILE_ERROR = 1550;
    exports2.ER_EVENT_SAME_NAME = 1551;
    exports2.ER_EVENT_DATA_TOO_LONG = 1552;
    exports2.ER_DROP_INDEX_FK = 1553;
    exports2.ER_WARN_DEPRECATED_SYNTAX_WITH_VER = 1554;
    exports2.ER_CANT_WRITE_LOCK_LOG_TABLE = 1555;
    exports2.ER_CANT_LOCK_LOG_TABLE = 1556;
    exports2.ER_FOREIGN_DUPLICATE_KEY = 1557;
    exports2.ER_COL_COUNT_DOESNT_MATCH_PLEASE_UPDATE = 1558;
    exports2.ER_TEMP_TABLE_PREVENTS_SWITCH_OUT_OF_RBR = 1559;
    exports2.ER_STORED_FUNCTION_PREVENTS_SWITCH_BINLOG_FORMAT = 1560;
    exports2.ER_NDB_CANT_SWITCH_BINLOG_FORMAT = 1561;
    exports2.ER_PARTITION_NO_TEMPORARY = 1562;
    exports2.ER_PARTITION_CONST_DOMAIN_ERROR = 1563;
    exports2.ER_PARTITION_FUNCTION_IS_NOT_ALLOWED = 1564;
    exports2.ER_DDL_LOG_ERROR = 1565;
    exports2.ER_NULL_IN_VALUES_LESS_THAN = 1566;
    exports2.ER_WRONG_PARTITION_NAME = 1567;
    exports2.ER_CANT_CHANGE_TX_CHARACTERISTICS = 1568;
    exports2.ER_DUP_ENTRY_AUTOINCREMENT_CASE = 1569;
    exports2.ER_EVENT_MODIFY_QUEUE_ERROR = 1570;
    exports2.ER_EVENT_SET_VAR_ERROR = 1571;
    exports2.ER_PARTITION_MERGE_ERROR = 1572;
    exports2.ER_CANT_ACTIVATE_LOG = 1573;
    exports2.ER_RBR_NOT_AVAILABLE = 1574;
    exports2.ER_BASE64_DECODE_ERROR = 1575;
    exports2.ER_EVENT_RECURSION_FORBIDDEN = 1576;
    exports2.ER_EVENTS_DB_ERROR = 1577;
    exports2.ER_ONLY_INTEGERS_ALLOWED = 1578;
    exports2.ER_UNSUPORTED_LOG_ENGINE = 1579;
    exports2.ER_BAD_LOG_STATEMENT = 1580;
    exports2.ER_CANT_RENAME_LOG_TABLE = 1581;
    exports2.ER_WRONG_PARAMCOUNT_TO_NATIVE_FCT = 1582;
    exports2.ER_WRONG_PARAMETERS_TO_NATIVE_FCT = 1583;
    exports2.ER_WRONG_PARAMETERS_TO_STORED_FCT = 1584;
    exports2.ER_NATIVE_FCT_NAME_COLLISION = 1585;
    exports2.ER_DUP_ENTRY_WITH_KEY_NAME = 1586;
    exports2.ER_BINLOG_PURGE_EMFILE = 1587;
    exports2.ER_EVENT_CANNOT_CREATE_IN_THE_PAST = 1588;
    exports2.ER_EVENT_CANNOT_ALTER_IN_THE_PAST = 1589;
    exports2.ER_SLAVE_INCIDENT = 1590;
    exports2.ER_NO_PARTITION_FOR_GIVEN_VALUE_SILENT = 1591;
    exports2.ER_BINLOG_UNSAFE_STATEMENT = 1592;
    exports2.ER_SLAVE_FATAL_ERROR = 1593;
    exports2.ER_SLAVE_RELAY_LOG_READ_FAILURE = 1594;
    exports2.ER_SLAVE_RELAY_LOG_WRITE_FAILURE = 1595;
    exports2.ER_SLAVE_CREATE_EVENT_FAILURE = 1596;
    exports2.ER_SLAVE_MASTER_COM_FAILURE = 1597;
    exports2.ER_BINLOG_LOGGING_IMPOSSIBLE = 1598;
    exports2.ER_VIEW_NO_CREATION_CTX = 1599;
    exports2.ER_VIEW_INVALID_CREATION_CTX = 1600;
    exports2.ER_SR_INVALID_CREATION_CTX = 1601;
    exports2.ER_TRG_CORRUPTED_FILE = 1602;
    exports2.ER_TRG_NO_CREATION_CTX = 1603;
    exports2.ER_TRG_INVALID_CREATION_CTX = 1604;
    exports2.ER_EVENT_INVALID_CREATION_CTX = 1605;
    exports2.ER_TRG_CANT_OPEN_TABLE = 1606;
    exports2.ER_CANT_CREATE_SROUTINE = 1607;
    exports2.ER_NEVER_USED = 1608;
    exports2.ER_NO_FORMAT_DESCRIPTION_EVENT_BEFORE_BINLOG_STATEMENT = 1609;
    exports2.ER_SLAVE_CORRUPT_EVENT = 1610;
    exports2.ER_LOAD_DATA_INVALID_COLUMN = 1611;
    exports2.ER_LOG_PURGE_NO_FILE = 1612;
    exports2.ER_XA_RBTIMEOUT = 1613;
    exports2.ER_XA_RBDEADLOCK = 1614;
    exports2.ER_NEED_REPREPARE = 1615;
    exports2.ER_DELAYED_NOT_SUPPORTED = 1616;
    exports2.WARN_NO_MASTER_INFO = 1617;
    exports2.WARN_OPTION_IGNORED = 1618;
    exports2.ER_PLUGIN_DELETE_BUILTIN = 1619;
    exports2.WARN_PLUGIN_BUSY = 1620;
    exports2.ER_VARIABLE_IS_READONLY = 1621;
    exports2.ER_WARN_ENGINE_TRANSACTION_ROLLBACK = 1622;
    exports2.ER_SLAVE_HEARTBEAT_FAILURE = 1623;
    exports2.ER_SLAVE_HEARTBEAT_VALUE_OUT_OF_RANGE = 1624;
    exports2.ER_NDB_REPLICATION_SCHEMA_ERROR = 1625;
    exports2.ER_CONFLICT_FN_PARSE_ERROR = 1626;
    exports2.ER_EXCEPTIONS_WRITE_ERROR = 1627;
    exports2.ER_TOO_LONG_TABLE_COMMENT = 1628;
    exports2.ER_TOO_LONG_FIELD_COMMENT = 1629;
    exports2.ER_FUNC_INEXISTENT_NAME_COLLISION = 1630;
    exports2.ER_DATABASE_NAME = 1631;
    exports2.ER_TABLE_NAME = 1632;
    exports2.ER_PARTITION_NAME = 1633;
    exports2.ER_SUBPARTITION_NAME = 1634;
    exports2.ER_TEMPORARY_NAME = 1635;
    exports2.ER_RENAMED_NAME = 1636;
    exports2.ER_TOO_MANY_CONCURRENT_TRXS = 1637;
    exports2.WARN_NON_ASCII_SEPARATOR_NOT_IMPLEMENTED = 1638;
    exports2.ER_DEBUG_SYNC_TIMEOUT = 1639;
    exports2.ER_DEBUG_SYNC_HIT_LIMIT = 1640;
    exports2.ER_DUP_SIGNAL_SET = 1641;
    exports2.ER_SIGNAL_WARN = 1642;
    exports2.ER_SIGNAL_NOT_FOUND = 1643;
    exports2.ER_SIGNAL_EXCEPTION = 1644;
    exports2.ER_RESIGNAL_WITHOUT_ACTIVE_HANDLER = 1645;
    exports2.ER_SIGNAL_BAD_CONDITION_TYPE = 1646;
    exports2.WARN_COND_ITEM_TRUNCATED = 1647;
    exports2.ER_COND_ITEM_TOO_LONG = 1648;
    exports2.ER_UNKNOWN_LOCALE = 1649;
    exports2.ER_SLAVE_IGNORE_SERVER_IDS = 1650;
    exports2.ER_QUERY_CACHE_DISABLED = 1651;
    exports2.ER_SAME_NAME_PARTITION_FIELD = 1652;
    exports2.ER_PARTITION_COLUMN_LIST_ERROR = 1653;
    exports2.ER_WRONG_TYPE_COLUMN_VALUE_ERROR = 1654;
    exports2.ER_TOO_MANY_PARTITION_FUNC_FIELDS_ERROR = 1655;
    exports2.ER_MAXVALUE_IN_VALUES_IN = 1656;
    exports2.ER_TOO_MANY_VALUES_ERROR = 1657;
    exports2.ER_ROW_SINGLE_PARTITION_FIELD_ERROR = 1658;
    exports2.ER_FIELD_TYPE_NOT_ALLOWED_AS_PARTITION_FIELD = 1659;
    exports2.ER_PARTITION_FIELDS_TOO_LONG = 1660;
    exports2.ER_BINLOG_ROW_ENGINE_AND_STMT_ENGINE = 1661;
    exports2.ER_BINLOG_ROW_MODE_AND_STMT_ENGINE = 1662;
    exports2.ER_BINLOG_UNSAFE_AND_STMT_ENGINE = 1663;
    exports2.ER_BINLOG_ROW_INJECTION_AND_STMT_ENGINE = 1664;
    exports2.ER_BINLOG_STMT_MODE_AND_ROW_ENGINE = 1665;
    exports2.ER_BINLOG_ROW_INJECTION_AND_STMT_MODE = 1666;
    exports2.ER_BINLOG_MULTIPLE_ENGINES_AND_SELF_LOGGING_ENGINE = 1667;
    exports2.ER_BINLOG_UNSAFE_LIMIT = 1668;
    exports2.ER_BINLOG_UNSAFE_INSERT_DELAYED = 1669;
    exports2.ER_BINLOG_UNSAFE_SYSTEM_TABLE = 1670;
    exports2.ER_BINLOG_UNSAFE_AUTOINC_COLUMNS = 1671;
    exports2.ER_BINLOG_UNSAFE_UDF = 1672;
    exports2.ER_BINLOG_UNSAFE_SYSTEM_VARIABLE = 1673;
    exports2.ER_BINLOG_UNSAFE_SYSTEM_FUNCTION = 1674;
    exports2.ER_BINLOG_UNSAFE_NONTRANS_AFTER_TRANS = 1675;
    exports2.ER_MESSAGE_AND_STATEMENT = 1676;
    exports2.ER_SLAVE_CONVERSION_FAILED = 1677;
    exports2.ER_SLAVE_CANT_CREATE_CONVERSION = 1678;
    exports2.ER_INSIDE_TRANSACTION_PREVENTS_SWITCH_BINLOG_FORMAT = 1679;
    exports2.ER_PATH_LENGTH = 1680;
    exports2.ER_WARN_DEPRECATED_SYNTAX_NO_REPLACEMENT = 1681;
    exports2.ER_WRONG_NATIVE_TABLE_STRUCTURE = 1682;
    exports2.ER_WRONG_PERFSCHEMA_USAGE = 1683;
    exports2.ER_WARN_I_S_SKIPPED_TABLE = 1684;
    exports2.ER_INSIDE_TRANSACTION_PREVENTS_SWITCH_BINLOG_DIRECT = 1685;
    exports2.ER_STORED_FUNCTION_PREVENTS_SWITCH_BINLOG_DIRECT = 1686;
    exports2.ER_SPATIAL_MUST_HAVE_GEOM_COL = 1687;
    exports2.ER_TOO_LONG_INDEX_COMMENT = 1688;
    exports2.ER_LOCK_ABORTED = 1689;
    exports2.ER_DATA_OUT_OF_RANGE = 1690;
    exports2.ER_WRONG_SPVAR_TYPE_IN_LIMIT = 1691;
    exports2.ER_BINLOG_UNSAFE_MULTIPLE_ENGINES_AND_SELF_LOGGING_ENGINE = 1692;
    exports2.ER_BINLOG_UNSAFE_MIXED_STATEMENT = 1693;
    exports2.ER_INSIDE_TRANSACTION_PREVENTS_SWITCH_SQL_LOG_BIN = 1694;
    exports2.ER_STORED_FUNCTION_PREVENTS_SWITCH_SQL_LOG_BIN = 1695;
    exports2.ER_FAILED_READ_FROM_PAR_FILE = 1696;
    exports2.ER_VALUES_IS_NOT_INT_TYPE_ERROR = 1697;
    exports2.ER_ACCESS_DENIED_NO_PASSWORD_ERROR = 1698;
    exports2.ER_SET_PASSWORD_AUTH_PLUGIN = 1699;
    exports2.ER_GRANT_PLUGIN_USER_EXISTS = 1700;
    exports2.ER_TRUNCATE_ILLEGAL_FK = 1701;
    exports2.ER_PLUGIN_IS_PERMANENT = 1702;
    exports2.ER_SLAVE_HEARTBEAT_VALUE_OUT_OF_RANGE_MIN = 1703;
    exports2.ER_SLAVE_HEARTBEAT_VALUE_OUT_OF_RANGE_MAX = 1704;
    exports2.ER_STMT_CACHE_FULL = 1705;
    exports2.ER_MULTI_UPDATE_KEY_CONFLICT = 1706;
    exports2.ER_TABLE_NEEDS_REBUILD = 1707;
    exports2.WARN_OPTION_BELOW_LIMIT = 1708;
    exports2.ER_INDEX_COLUMN_TOO_LONG = 1709;
    exports2.ER_ERROR_IN_TRIGGER_BODY = 1710;
    exports2.ER_ERROR_IN_UNKNOWN_TRIGGER_BODY = 1711;
    exports2.ER_INDEX_CORRUPT = 1712;
    exports2.ER_UNDO_RECORD_TOO_BIG = 1713;
    exports2.ER_BINLOG_UNSAFE_INSERT_IGNORE_SELECT = 1714;
    exports2.ER_BINLOG_UNSAFE_INSERT_SELECT_UPDATE = 1715;
    exports2.ER_BINLOG_UNSAFE_REPLACE_SELECT = 1716;
    exports2.ER_BINLOG_UNSAFE_CREATE_IGNORE_SELECT = 1717;
    exports2.ER_BINLOG_UNSAFE_CREATE_REPLACE_SELECT = 1718;
    exports2.ER_BINLOG_UNSAFE_UPDATE_IGNORE = 1719;
    exports2.ER_PLUGIN_NO_UNINSTALL = 1720;
    exports2.ER_PLUGIN_NO_INSTALL = 1721;
    exports2.ER_BINLOG_UNSAFE_WRITE_AUTOINC_SELECT = 1722;
    exports2.ER_BINLOG_UNSAFE_CREATE_SELECT_AUTOINC = 1723;
    exports2.ER_BINLOG_UNSAFE_INSERT_TWO_KEYS = 1724;
    exports2.ER_TABLE_IN_FK_CHECK = 1725;
    exports2.ER_UNSUPPORTED_ENGINE = 1726;
    exports2.ER_BINLOG_UNSAFE_AUTOINC_NOT_FIRST = 1727;
    exports2.ER_CANNOT_LOAD_FROM_TABLE_V2 = 1728;
    exports2.ER_MASTER_DELAY_VALUE_OUT_OF_RANGE = 1729;
    exports2.ER_ONLY_FD_AND_RBR_EVENTS_ALLOWED_IN_BINLOG_STATEMENT = 1730;
    exports2.ER_PARTITION_EXCHANGE_DIFFERENT_OPTION = 1731;
    exports2.ER_PARTITION_EXCHANGE_PART_TABLE = 1732;
    exports2.ER_PARTITION_EXCHANGE_TEMP_TABLE = 1733;
    exports2.ER_PARTITION_INSTEAD_OF_SUBPARTITION = 1734;
    exports2.ER_UNKNOWN_PARTITION = 1735;
    exports2.ER_TABLES_DIFFERENT_METADATA = 1736;
    exports2.ER_ROW_DOES_NOT_MATCH_PARTITION = 1737;
    exports2.ER_BINLOG_CACHE_SIZE_GREATER_THAN_MAX = 1738;
    exports2.ER_WARN_INDEX_NOT_APPLICABLE = 1739;
    exports2.ER_PARTITION_EXCHANGE_FOREIGN_KEY = 1740;
    exports2.ER_NO_SUCH_KEY_VALUE = 1741;
    exports2.ER_RPL_INFO_DATA_TOO_LONG = 1742;
    exports2.ER_NETWORK_READ_EVENT_CHECKSUM_FAILURE = 1743;
    exports2.ER_BINLOG_READ_EVENT_CHECKSUM_FAILURE = 1744;
    exports2.ER_BINLOG_STMT_CACHE_SIZE_GREATER_THAN_MAX = 1745;
    exports2.ER_CANT_UPDATE_TABLE_IN_CREATE_TABLE_SELECT = 1746;
    exports2.ER_PARTITION_CLAUSE_ON_NONPARTITIONED = 1747;
    exports2.ER_ROW_DOES_NOT_MATCH_GIVEN_PARTITION_SET = 1748;
    exports2.ER_NO_SUCH_PARTITION = 1749;
    exports2.ER_CHANGE_RPL_INFO_REPOSITORY_FAILURE = 1750;
    exports2.ER_WARNING_NOT_COMPLETE_ROLLBACK_WITH_CREATED_TEMP_TABLE = 1751;
    exports2.ER_WARNING_NOT_COMPLETE_ROLLBACK_WITH_DROPPED_TEMP_TABLE = 1752;
    exports2.ER_MTS_FEATURE_IS_NOT_SUPPORTED = 1753;
    exports2.ER_MTS_UPDATED_DBS_GREATER_MAX = 1754;
    exports2.ER_MTS_CANT_PARALLEL = 1755;
    exports2.ER_MTS_INCONSISTENT_DATA = 1756;
    exports2.ER_FULLTEXT_NOT_SUPPORTED_WITH_PARTITIONING = 1757;
    exports2.ER_DA_INVALID_CONDITION_NUMBER = 1758;
    exports2.ER_INSECURE_PLAIN_TEXT = 1759;
    exports2.ER_INSECURE_CHANGE_MASTER = 1760;
    exports2.ER_FOREIGN_DUPLICATE_KEY_WITH_CHILD_INFO = 1761;
    exports2.ER_FOREIGN_DUPLICATE_KEY_WITHOUT_CHILD_INFO = 1762;
    exports2.ER_SQLTHREAD_WITH_SECURE_SLAVE = 1763;
    exports2.ER_TABLE_HAS_NO_FT = 1764;
    exports2.ER_VARIABLE_NOT_SETTABLE_IN_SF_OR_TRIGGER = 1765;
    exports2.ER_VARIABLE_NOT_SETTABLE_IN_TRANSACTION = 1766;
    exports2.ER_GTID_NEXT_IS_NOT_IN_GTID_NEXT_LIST = 1767;
    exports2.ER_CANT_CHANGE_GTID_NEXT_IN_TRANSACTION = 1768;
    exports2.ER_SET_STATEMENT_CANNOT_INVOKE_FUNCTION = 1769;
    exports2.ER_GTID_NEXT_CANT_BE_AUTOMATIC_IF_GTID_NEXT_LIST_IS_NON_NULL = 1770;
    exports2.ER_SKIPPING_LOGGED_TRANSACTION = 1771;
    exports2.ER_MALFORMED_GTID_SET_SPECIFICATION = 1772;
    exports2.ER_MALFORMED_GTID_SET_ENCODING = 1773;
    exports2.ER_MALFORMED_GTID_SPECIFICATION = 1774;
    exports2.ER_GNO_EXHAUSTED = 1775;
    exports2.ER_BAD_SLAVE_AUTO_POSITION = 1776;
    exports2.ER_AUTO_POSITION_REQUIRES_GTID_MODE_NOT_OFF = 1777;
    exports2.ER_CANT_DO_IMPLICIT_COMMIT_IN_TRX_WHEN_GTID_NEXT_IS_SET = 1778;
    exports2.ER_GTID_MODE_ON_REQUIRES_ENFORCE_GTID_CONSISTENCY_ON = 1779;
    exports2.ER_GTID_MODE_REQUIRES_BINLOG = 1780;
    exports2.ER_CANT_SET_GTID_NEXT_TO_GTID_WHEN_GTID_MODE_IS_OFF = 1781;
    exports2.ER_CANT_SET_GTID_NEXT_TO_ANONYMOUS_WHEN_GTID_MODE_IS_ON = 1782;
    exports2.ER_CANT_SET_GTID_NEXT_LIST_TO_NON_NULL_WHEN_GTID_MODE_IS_OFF = 1783;
    exports2.ER_FOUND_GTID_EVENT_WHEN_GTID_MODE_IS_OFF = 1784;
    exports2.ER_GTID_UNSAFE_NON_TRANSACTIONAL_TABLE = 1785;
    exports2.ER_GTID_UNSAFE_CREATE_SELECT = 1786;
    exports2.ER_GTID_UNSAFE_CREATE_DROP_TEMPORARY_TABLE_IN_TRANSACTION = 1787;
    exports2.ER_GTID_MODE_CAN_ONLY_CHANGE_ONE_STEP_AT_A_TIME = 1788;
    exports2.ER_MASTER_HAS_PURGED_REQUIRED_GTIDS = 1789;
    exports2.ER_CANT_SET_GTID_NEXT_WHEN_OWNING_GTID = 1790;
    exports2.ER_UNKNOWN_EXPLAIN_FORMAT = 1791;
    exports2.ER_CANT_EXECUTE_IN_READ_ONLY_TRANSACTION = 1792;
    exports2.ER_TOO_LONG_TABLE_PARTITION_COMMENT = 1793;
    exports2.ER_SLAVE_CONFIGURATION = 1794;
    exports2.ER_INNODB_FT_LIMIT = 1795;
    exports2.ER_INNODB_NO_FT_TEMP_TABLE = 1796;
    exports2.ER_INNODB_FT_WRONG_DOCID_COLUMN = 1797;
    exports2.ER_INNODB_FT_WRONG_DOCID_INDEX = 1798;
    exports2.ER_INNODB_ONLINE_LOG_TOO_BIG = 1799;
    exports2.ER_UNKNOWN_ALTER_ALGORITHM = 1800;
    exports2.ER_UNKNOWN_ALTER_LOCK = 1801;
    exports2.ER_MTS_CHANGE_MASTER_CANT_RUN_WITH_GAPS = 1802;
    exports2.ER_MTS_RECOVERY_FAILURE = 1803;
    exports2.ER_MTS_RESET_WORKERS = 1804;
    exports2.ER_COL_COUNT_DOESNT_MATCH_CORRUPTED_V2 = 1805;
    exports2.ER_SLAVE_SILENT_RETRY_TRANSACTION = 1806;
    exports2.ER_DISCARD_FK_CHECKS_RUNNING = 1807;
    exports2.ER_TABLE_SCHEMA_MISMATCH = 1808;
    exports2.ER_TABLE_IN_SYSTEM_TABLESPACE = 1809;
    exports2.ER_IO_READ_ERROR = 1810;
    exports2.ER_IO_WRITE_ERROR = 1811;
    exports2.ER_TABLESPACE_MISSING = 1812;
    exports2.ER_TABLESPACE_EXISTS = 1813;
    exports2.ER_TABLESPACE_DISCARDED = 1814;
    exports2.ER_INTERNAL_ERROR = 1815;
    exports2.ER_INNODB_IMPORT_ERROR = 1816;
    exports2.ER_INNODB_INDEX_CORRUPT = 1817;
    exports2.ER_INVALID_YEAR_COLUMN_LENGTH = 1818;
    exports2.ER_NOT_VALID_PASSWORD = 1819;
    exports2.ER_MUST_CHANGE_PASSWORD = 1820;
    exports2.ER_FK_NO_INDEX_CHILD = 1821;
    exports2.ER_FK_NO_INDEX_PARENT = 1822;
    exports2.ER_FK_FAIL_ADD_SYSTEM = 1823;
    exports2.ER_FK_CANNOT_OPEN_PARENT = 1824;
    exports2.ER_FK_INCORRECT_OPTION = 1825;
    exports2.ER_FK_DUP_NAME = 1826;
    exports2.ER_PASSWORD_FORMAT = 1827;
    exports2.ER_FK_COLUMN_CANNOT_DROP = 1828;
    exports2.ER_FK_COLUMN_CANNOT_DROP_CHILD = 1829;
    exports2.ER_FK_COLUMN_NOT_NULL = 1830;
    exports2.ER_DUP_INDEX = 1831;
    exports2.ER_FK_COLUMN_CANNOT_CHANGE = 1832;
    exports2.ER_FK_COLUMN_CANNOT_CHANGE_CHILD = 1833;
    exports2.ER_FK_CANNOT_DELETE_PARENT = 1834;
    exports2.ER_MALFORMED_PACKET = 1835;
    exports2.ER_READ_ONLY_MODE = 1836;
    exports2.ER_GTID_NEXT_TYPE_UNDEFINED_GROUP = 1837;
    exports2.ER_VARIABLE_NOT_SETTABLE_IN_SP = 1838;
    exports2.ER_CANT_SET_GTID_PURGED_WHEN_GTID_MODE_IS_OFF = 1839;
    exports2.ER_CANT_SET_GTID_PURGED_WHEN_GTID_EXECUTED_IS_NOT_EMPTY = 1840;
    exports2.ER_CANT_SET_GTID_PURGED_WHEN_OWNED_GTIDS_IS_NOT_EMPTY = 1841;
    exports2.ER_GTID_PURGED_WAS_CHANGED = 1842;
    exports2.ER_GTID_EXECUTED_WAS_CHANGED = 1843;
    exports2.ER_BINLOG_STMT_MODE_AND_NO_REPL_TABLES = 1844;
    exports2.ER_ALTER_OPERATION_NOT_SUPPORTED = 1845;
    exports2.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON = 1846;
    exports2.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_COPY = 1847;
    exports2.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_PARTITION = 1848;
    exports2.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_FK_RENAME = 1849;
    exports2.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_COLUMN_TYPE = 1850;
    exports2.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_FK_CHECK = 1851;
    exports2.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_IGNORE = 1852;
    exports2.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_NOPK = 1853;
    exports2.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_AUTOINC = 1854;
    exports2.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_HIDDEN_FTS = 1855;
    exports2.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_CHANGE_FTS = 1856;
    exports2.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_FTS = 1857;
    exports2.ER_SQL_SLAVE_SKIP_COUNTER_NOT_SETTABLE_IN_GTID_MODE = 1858;
    exports2.ER_DUP_UNKNOWN_IN_INDEX = 1859;
    exports2.ER_IDENT_CAUSES_TOO_LONG_PATH = 1860;
    exports2.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_NOT_NULL = 1861;
    exports2.ER_MUST_CHANGE_PASSWORD_LOGIN = 1862;
    exports2.ER_ROW_IN_WRONG_PARTITION = 1863;
    exports2.ER_MTS_EVENT_BIGGER_PENDING_JOBS_SIZE_MAX = 1864;
    exports2.ER_INNODB_NO_FT_USES_PARSER = 1865;
    exports2.ER_BINLOG_LOGICAL_CORRUPTION = 1866;
    exports2.ER_WARN_PURGE_LOG_IN_USE = 1867;
    exports2.ER_WARN_PURGE_LOG_IS_ACTIVE = 1868;
    exports2.ER_AUTO_INCREMENT_CONFLICT = 1869;
    exports2.WARN_ON_BLOCKHOLE_IN_RBR = 1870;
    exports2.ER_SLAVE_MI_INIT_REPOSITORY = 1871;
    exports2.ER_SLAVE_RLI_INIT_REPOSITORY = 1872;
    exports2.ER_ACCESS_DENIED_CHANGE_USER_ERROR = 1873;
    exports2.ER_INNODB_READ_ONLY = 1874;
    exports2.ER_STOP_SLAVE_SQL_THREAD_TIMEOUT = 1875;
    exports2.ER_STOP_SLAVE_IO_THREAD_TIMEOUT = 1876;
    exports2.ER_TABLE_CORRUPT = 1877;
    exports2.ER_TEMP_FILE_WRITE_FAILURE = 1878;
    exports2.ER_INNODB_FT_AUX_NOT_HEX_ID = 1879;
    exports2.ER_OLD_TEMPORALS_UPGRADED = 1880;
    exports2.ER_INNODB_FORCED_RECOVERY = 1881;
    exports2.ER_AES_INVALID_IV = 1882;
    exports2.ER_PLUGIN_CANNOT_BE_UNINSTALLED = 1883;
    exports2.ER_GTID_UNSAFE_BINLOG_SPLITTABLE_STATEMENT_AND_GTID_GROUP = 1884;
    exports2.ER_SLAVE_HAS_MORE_GTIDS_THAN_MASTER = 1885;
    exports2.ER_MISSING_KEY = 1886;
    exports2.WARN_NAMED_PIPE_ACCESS_EVERYONE = 1887;
    exports2.ER_FOUND_MISSING_GTIDS = 1888;
    exports2.ER_FILE_CORRUPT = 3e3;
    exports2.ER_ERROR_ON_MASTER = 3001;
    exports2.ER_INCONSISTENT_ERROR = 3002;
    exports2.ER_STORAGE_ENGINE_NOT_LOADED = 3003;
    exports2.ER_GET_STACKED_DA_WITHOUT_ACTIVE_HANDLER = 3004;
    exports2.ER_WARN_LEGACY_SYNTAX_CONVERTED = 3005;
    exports2.ER_BINLOG_UNSAFE_FULLTEXT_PLUGIN = 3006;
    exports2.ER_CANNOT_DISCARD_TEMPORARY_TABLE = 3007;
    exports2.ER_FK_DEPTH_EXCEEDED = 3008;
    exports2.ER_COL_COUNT_DOESNT_MATCH_PLEASE_UPDATE_V2 = 3009;
    exports2.ER_WARN_TRIGGER_DOESNT_HAVE_CREATED = 3010;
    exports2.ER_REFERENCED_TRG_DOES_NOT_EXIST = 3011;
    exports2.ER_EXPLAIN_NOT_SUPPORTED = 3012;
    exports2.ER_INVALID_FIELD_SIZE = 3013;
    exports2.ER_MISSING_HA_CREATE_OPTION = 3014;
    exports2.ER_ENGINE_OUT_OF_MEMORY = 3015;
    exports2.ER_PASSWORD_EXPIRE_ANONYMOUS_USER = 3016;
    exports2.ER_SLAVE_SQL_THREAD_MUST_STOP = 3017;
    exports2.ER_NO_FT_MATERIALIZED_SUBQUERY = 3018;
    exports2.ER_INNODB_UNDO_LOG_FULL = 3019;
    exports2.ER_INVALID_ARGUMENT_FOR_LOGARITHM = 3020;
    exports2.ER_SLAVE_CHANNEL_IO_THREAD_MUST_STOP = 3021;
    exports2.ER_WARN_OPEN_TEMP_TABLES_MUST_BE_ZERO = 3022;
    exports2.ER_WARN_ONLY_MASTER_LOG_FILE_NO_POS = 3023;
    exports2.ER_QUERY_TIMEOUT = 3024;
    exports2.ER_NON_RO_SELECT_DISABLE_TIMER = 3025;
    exports2.ER_DUP_LIST_ENTRY = 3026;
    exports2.ER_SQL_MODE_NO_EFFECT = 3027;
    exports2.ER_AGGREGATE_ORDER_FOR_UNION = 3028;
    exports2.ER_AGGREGATE_ORDER_NON_AGG_QUERY = 3029;
    exports2.ER_SLAVE_WORKER_STOPPED_PREVIOUS_THD_ERROR = 3030;
    exports2.ER_DONT_SUPPORT_SLAVE_PRESERVE_COMMIT_ORDER = 3031;
    exports2.ER_SERVER_OFFLINE_MODE = 3032;
    exports2.ER_GIS_DIFFERENT_SRIDS = 3033;
    exports2.ER_GIS_UNSUPPORTED_ARGUMENT = 3034;
    exports2.ER_GIS_UNKNOWN_ERROR = 3035;
    exports2.ER_GIS_UNKNOWN_EXCEPTION = 3036;
    exports2.ER_GIS_INVALID_DATA = 3037;
    exports2.ER_BOOST_GEOMETRY_EMPTY_INPUT_EXCEPTION = 3038;
    exports2.ER_BOOST_GEOMETRY_CENTROID_EXCEPTION = 3039;
    exports2.ER_BOOST_GEOMETRY_OVERLAY_INVALID_INPUT_EXCEPTION = 3040;
    exports2.ER_BOOST_GEOMETRY_TURN_INFO_EXCEPTION = 3041;
    exports2.ER_BOOST_GEOMETRY_SELF_INTERSECTION_POINT_EXCEPTION = 3042;
    exports2.ER_BOOST_GEOMETRY_UNKNOWN_EXCEPTION = 3043;
    exports2.ER_STD_BAD_ALLOC_ERROR = 3044;
    exports2.ER_STD_DOMAIN_ERROR = 3045;
    exports2.ER_STD_LENGTH_ERROR = 3046;
    exports2.ER_STD_INVALID_ARGUMENT = 3047;
    exports2.ER_STD_OUT_OF_RANGE_ERROR = 3048;
    exports2.ER_STD_OVERFLOW_ERROR = 3049;
    exports2.ER_STD_RANGE_ERROR = 3050;
    exports2.ER_STD_UNDERFLOW_ERROR = 3051;
    exports2.ER_STD_LOGIC_ERROR = 3052;
    exports2.ER_STD_RUNTIME_ERROR = 3053;
    exports2.ER_STD_UNKNOWN_EXCEPTION = 3054;
    exports2.ER_GIS_DATA_WRONG_ENDIANESS = 3055;
    exports2.ER_CHANGE_MASTER_PASSWORD_LENGTH = 3056;
    exports2.ER_USER_LOCK_WRONG_NAME = 3057;
    exports2.ER_USER_LOCK_DEADLOCK = 3058;
    exports2.ER_REPLACE_INACCESSIBLE_ROWS = 3059;
    exports2.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_GIS = 3060;
    exports2.ER_ILLEGAL_USER_VAR = 3061;
    exports2.ER_GTID_MODE_OFF = 3062;
    exports2.ER_UNSUPPORTED_BY_REPLICATION_THREAD = 3063;
    exports2.ER_INCORRECT_TYPE = 3064;
    exports2.ER_FIELD_IN_ORDER_NOT_SELECT = 3065;
    exports2.ER_AGGREGATE_IN_ORDER_NOT_SELECT = 3066;
    exports2.ER_INVALID_RPL_WILD_TABLE_FILTER_PATTERN = 3067;
    exports2.ER_NET_OK_PACKET_TOO_LARGE = 3068;
    exports2.ER_INVALID_JSON_DATA = 3069;
    exports2.ER_INVALID_GEOJSON_MISSING_MEMBER = 3070;
    exports2.ER_INVALID_GEOJSON_WRONG_TYPE = 3071;
    exports2.ER_INVALID_GEOJSON_UNSPECIFIED = 3072;
    exports2.ER_DIMENSION_UNSUPPORTED = 3073;
    exports2.ER_SLAVE_CHANNEL_DOES_NOT_EXIST = 3074;
    exports2.ER_SLAVE_MULTIPLE_CHANNELS_HOST_PORT = 3075;
    exports2.ER_SLAVE_CHANNEL_NAME_INVALID_OR_TOO_LONG = 3076;
    exports2.ER_SLAVE_NEW_CHANNEL_WRONG_REPOSITORY = 3077;
    exports2.ER_SLAVE_CHANNEL_DELETE = 3078;
    exports2.ER_SLAVE_MULTIPLE_CHANNELS_CMD = 3079;
    exports2.ER_SLAVE_MAX_CHANNELS_EXCEEDED = 3080;
    exports2.ER_SLAVE_CHANNEL_MUST_STOP = 3081;
    exports2.ER_SLAVE_CHANNEL_NOT_RUNNING = 3082;
    exports2.ER_SLAVE_CHANNEL_WAS_RUNNING = 3083;
    exports2.ER_SLAVE_CHANNEL_WAS_NOT_RUNNING = 3084;
    exports2.ER_SLAVE_CHANNEL_SQL_THREAD_MUST_STOP = 3085;
    exports2.ER_SLAVE_CHANNEL_SQL_SKIP_COUNTER = 3086;
    exports2.ER_WRONG_FIELD_WITH_GROUP_V2 = 3087;
    exports2.ER_MIX_OF_GROUP_FUNC_AND_FIELDS_V2 = 3088;
    exports2.ER_WARN_DEPRECATED_SYSVAR_UPDATE = 3089;
    exports2.ER_WARN_DEPRECATED_SQLMODE = 3090;
    exports2.ER_CANNOT_LOG_PARTIAL_DROP_DATABASE_WITH_GTID = 3091;
    exports2.ER_GROUP_REPLICATION_CONFIGURATION = 3092;
    exports2.ER_GROUP_REPLICATION_RUNNING = 3093;
    exports2.ER_GROUP_REPLICATION_APPLIER_INIT_ERROR = 3094;
    exports2.ER_GROUP_REPLICATION_STOP_APPLIER_THREAD_TIMEOUT = 3095;
    exports2.ER_GROUP_REPLICATION_COMMUNICATION_LAYER_SESSION_ERROR = 3096;
    exports2.ER_GROUP_REPLICATION_COMMUNICATION_LAYER_JOIN_ERROR = 3097;
    exports2.ER_BEFORE_DML_VALIDATION_ERROR = 3098;
    exports2.ER_PREVENTS_VARIABLE_WITHOUT_RBR = 3099;
    exports2.ER_RUN_HOOK_ERROR = 3100;
    exports2.ER_TRANSACTION_ROLLBACK_DURING_COMMIT = 3101;
    exports2.ER_GENERATED_COLUMN_FUNCTION_IS_NOT_ALLOWED = 3102;
    exports2.ER_UNSUPPORTED_ALTER_INPLACE_ON_VIRTUAL_COLUMN = 3103;
    exports2.ER_WRONG_FK_OPTION_FOR_GENERATED_COLUMN = 3104;
    exports2.ER_NON_DEFAULT_VALUE_FOR_GENERATED_COLUMN = 3105;
    exports2.ER_UNSUPPORTED_ACTION_ON_GENERATED_COLUMN = 3106;
    exports2.ER_GENERATED_COLUMN_NON_PRIOR = 3107;
    exports2.ER_DEPENDENT_BY_GENERATED_COLUMN = 3108;
    exports2.ER_GENERATED_COLUMN_REF_AUTO_INC = 3109;
    exports2.ER_FEATURE_NOT_AVAILABLE = 3110;
    exports2.ER_CANT_SET_GTID_MODE = 3111;
    exports2.ER_CANT_USE_AUTO_POSITION_WITH_GTID_MODE_OFF = 3112;
    exports2.ER_CANT_REPLICATE_ANONYMOUS_WITH_AUTO_POSITION = 3113;
    exports2.ER_CANT_REPLICATE_ANONYMOUS_WITH_GTID_MODE_ON = 3114;
    exports2.ER_CANT_REPLICATE_GTID_WITH_GTID_MODE_OFF = 3115;
    exports2.ER_CANT_SET_ENFORCE_GTID_CONSISTENCY_ON_WITH_ONGOING_GTID_VIOLATING_TRANSACTIONS = 3116;
    exports2.ER_SET_ENFORCE_GTID_CONSISTENCY_WARN_WITH_ONGOING_GTID_VIOLATING_TRANSACTIONS = 3117;
    exports2.ER_ACCOUNT_HAS_BEEN_LOCKED = 3118;
    exports2.ER_WRONG_TABLESPACE_NAME = 3119;
    exports2.ER_TABLESPACE_IS_NOT_EMPTY = 3120;
    exports2.ER_WRONG_FILE_NAME = 3121;
    exports2.ER_BOOST_GEOMETRY_INCONSISTENT_TURNS_EXCEPTION = 3122;
    exports2.ER_WARN_OPTIMIZER_HINT_SYNTAX_ERROR = 3123;
    exports2.ER_WARN_BAD_MAX_EXECUTION_TIME = 3124;
    exports2.ER_WARN_UNSUPPORTED_MAX_EXECUTION_TIME = 3125;
    exports2.ER_WARN_CONFLICTING_HINT = 3126;
    exports2.ER_WARN_UNKNOWN_QB_NAME = 3127;
    exports2.ER_UNRESOLVED_HINT_NAME = 3128;
    exports2.ER_WARN_ON_MODIFYING_GTID_EXECUTED_TABLE = 3129;
    exports2.ER_PLUGGABLE_PROTOCOL_COMMAND_NOT_SUPPORTED = 3130;
    exports2.ER_LOCKING_SERVICE_WRONG_NAME = 3131;
    exports2.ER_LOCKING_SERVICE_DEADLOCK = 3132;
    exports2.ER_LOCKING_SERVICE_TIMEOUT = 3133;
    exports2.ER_GIS_MAX_POINTS_IN_GEOMETRY_OVERFLOWED = 3134;
    exports2.ER_SQL_MODE_MERGED = 3135;
    exports2.ER_VTOKEN_PLUGIN_TOKEN_MISMATCH = 3136;
    exports2.ER_VTOKEN_PLUGIN_TOKEN_NOT_FOUND = 3137;
    exports2.ER_CANT_SET_VARIABLE_WHEN_OWNING_GTID = 3138;
    exports2.ER_SLAVE_CHANNEL_OPERATION_NOT_ALLOWED = 3139;
    exports2.ER_INVALID_JSON_TEXT = 3140;
    exports2.ER_INVALID_JSON_TEXT_IN_PARAM = 3141;
    exports2.ER_INVALID_JSON_BINARY_DATA = 3142;
    exports2.ER_INVALID_JSON_PATH = 3143;
    exports2.ER_INVALID_JSON_CHARSET = 3144;
    exports2.ER_INVALID_JSON_CHARSET_IN_FUNCTION = 3145;
    exports2.ER_INVALID_TYPE_FOR_JSON = 3146;
    exports2.ER_INVALID_CAST_TO_JSON = 3147;
    exports2.ER_INVALID_JSON_PATH_CHARSET = 3148;
    exports2.ER_INVALID_JSON_PATH_WILDCARD = 3149;
    exports2.ER_JSON_VALUE_TOO_BIG = 3150;
    exports2.ER_JSON_KEY_TOO_BIG = 3151;
    exports2.ER_JSON_USED_AS_KEY = 3152;
    exports2.ER_JSON_VACUOUS_PATH = 3153;
    exports2.ER_JSON_BAD_ONE_OR_ALL_ARG = 3154;
    exports2.ER_NUMERIC_JSON_VALUE_OUT_OF_RANGE = 3155;
    exports2.ER_INVALID_JSON_VALUE_FOR_CAST = 3156;
    exports2.ER_JSON_DOCUMENT_TOO_DEEP = 3157;
    exports2.ER_JSON_DOCUMENT_NULL_KEY = 3158;
    exports2.ER_SECURE_TRANSPORT_REQUIRED = 3159;
    exports2.ER_NO_SECURE_TRANSPORTS_CONFIGURED = 3160;
    exports2.ER_DISABLED_STORAGE_ENGINE = 3161;
    exports2.ER_USER_DOES_NOT_EXIST = 3162;
    exports2.ER_USER_ALREADY_EXISTS = 3163;
    exports2.ER_AUDIT_API_ABORT = 3164;
    exports2.ER_INVALID_JSON_PATH_ARRAY_CELL = 3165;
    exports2.ER_BUFPOOL_RESIZE_INPROGRESS = 3166;
    exports2.ER_FEATURE_DISABLED_SEE_DOC = 3167;
    exports2.ER_SERVER_ISNT_AVAILABLE = 3168;
    exports2.ER_SESSION_WAS_KILLED = 3169;
    exports2.ER_CAPACITY_EXCEEDED = 3170;
    exports2.ER_CAPACITY_EXCEEDED_IN_RANGE_OPTIMIZER = 3171;
    exports2.ER_TABLE_NEEDS_UPG_PART = 3172;
    exports2.ER_CANT_WAIT_FOR_EXECUTED_GTID_SET_WHILE_OWNING_A_GTID = 3173;
    exports2.ER_CANNOT_ADD_FOREIGN_BASE_COL_VIRTUAL = 3174;
    exports2.ER_CANNOT_CREATE_VIRTUAL_INDEX_CONSTRAINT = 3175;
    exports2.ER_ERROR_ON_MODIFYING_GTID_EXECUTED_TABLE = 3176;
    exports2.ER_LOCK_REFUSED_BY_ENGINE = 3177;
    exports2.ER_UNSUPPORTED_ALTER_ONLINE_ON_VIRTUAL_COLUMN = 3178;
    exports2.ER_MASTER_KEY_ROTATION_NOT_SUPPORTED_BY_SE = 3179;
    exports2.ER_MASTER_KEY_ROTATION_ERROR_BY_SE = 3180;
    exports2.ER_MASTER_KEY_ROTATION_BINLOG_FAILED = 3181;
    exports2.ER_MASTER_KEY_ROTATION_SE_UNAVAILABLE = 3182;
    exports2.ER_TABLESPACE_CANNOT_ENCRYPT = 3183;
    exports2.ER_INVALID_ENCRYPTION_OPTION = 3184;
    exports2.ER_CANNOT_FIND_KEY_IN_KEYRING = 3185;
    exports2.ER_CAPACITY_EXCEEDED_IN_PARSER = 3186;
    exports2.ER_UNSUPPORTED_ALTER_ENCRYPTION_INPLACE = 3187;
    exports2.ER_KEYRING_UDF_KEYRING_SERVICE_ERROR = 3188;
    exports2.ER_USER_COLUMN_OLD_LENGTH = 3189;
    exports2.ER_CANT_RESET_MASTER = 3190;
    exports2.ER_GROUP_REPLICATION_MAX_GROUP_SIZE = 3191;
    exports2.ER_CANNOT_ADD_FOREIGN_BASE_COL_STORED = 3192;
    exports2.ER_TABLE_REFERENCED = 3193;
    exports2.ER_PARTITION_ENGINE_DEPRECATED_FOR_TABLE = 3194;
    exports2.ER_WARN_USING_GEOMFROMWKB_TO_SET_SRID_ZERO = 3195;
    exports2.ER_WARN_USING_GEOMFROMWKB_TO_SET_SRID = 3196;
    exports2.ER_XA_RETRY = 3197;
    exports2.ER_KEYRING_AWS_UDF_AWS_KMS_ERROR = 3198;
    exports2.ER_BINLOG_UNSAFE_XA = 3199;
    exports2.ER_UDF_ERROR = 3200;
    exports2.ER_KEYRING_MIGRATION_FAILURE = 3201;
    exports2.ER_KEYRING_ACCESS_DENIED_ERROR = 3202;
    exports2.ER_KEYRING_MIGRATION_STATUS = 3203;
    exports2.ER_PLUGIN_FAILED_TO_OPEN_TABLES = 3204;
    exports2.ER_PLUGIN_FAILED_TO_OPEN_TABLE = 3205;
    exports2.ER_AUDIT_LOG_NO_KEYRING_PLUGIN_INSTALLED = 3206;
    exports2.ER_AUDIT_LOG_ENCRYPTION_PASSWORD_HAS_NOT_BEEN_SET = 3207;
    exports2.ER_AUDIT_LOG_COULD_NOT_CREATE_AES_KEY = 3208;
    exports2.ER_AUDIT_LOG_ENCRYPTION_PASSWORD_CANNOT_BE_FETCHED = 3209;
    exports2.ER_AUDIT_LOG_JSON_FILTERING_NOT_ENABLED = 3210;
    exports2.ER_AUDIT_LOG_UDF_INSUFFICIENT_PRIVILEGE = 3211;
    exports2.ER_AUDIT_LOG_SUPER_PRIVILEGE_REQUIRED = 3212;
    exports2.ER_COULD_NOT_REINITIALIZE_AUDIT_LOG_FILTERS = 3213;
    exports2.ER_AUDIT_LOG_UDF_INVALID_ARGUMENT_TYPE = 3214;
    exports2.ER_AUDIT_LOG_UDF_INVALID_ARGUMENT_COUNT = 3215;
    exports2.ER_AUDIT_LOG_HAS_NOT_BEEN_INSTALLED = 3216;
    exports2.ER_AUDIT_LOG_UDF_READ_INVALID_MAX_ARRAY_LENGTH_ARG_TYPE = 3217;
    exports2.ER_AUDIT_LOG_UDF_READ_INVALID_MAX_ARRAY_LENGTH_ARG_VALUE = 3218;
    exports2.ER_AUDIT_LOG_JSON_FILTER_PARSING_ERROR = 3219;
    exports2.ER_AUDIT_LOG_JSON_FILTER_NAME_CANNOT_BE_EMPTY = 3220;
    exports2.ER_AUDIT_LOG_JSON_USER_NAME_CANNOT_BE_EMPTY = 3221;
    exports2.ER_AUDIT_LOG_JSON_FILTER_DOES_NOT_EXISTS = 3222;
    exports2.ER_AUDIT_LOG_USER_FIRST_CHARACTER_MUST_BE_ALPHANUMERIC = 3223;
    exports2.ER_AUDIT_LOG_USER_NAME_INVALID_CHARACTER = 3224;
    exports2.ER_AUDIT_LOG_HOST_NAME_INVALID_CHARACTER = 3225;
    exports2.WARN_DEPRECATED_MAXDB_SQL_MODE_FOR_TIMESTAMP = 3226;
    exports2.ER_XA_REPLICATION_FILTERS = 3227;
    exports2.ER_CANT_OPEN_ERROR_LOG = 3228;
    exports2.ER_GROUPING_ON_TIMESTAMP_IN_DST = 3229;
    exports2.ER_CANT_START_SERVER_NAMED_PIPE = 3230;
    exports2[1] = "EE_CANTCREATEFILE";
    exports2[2] = "EE_READ";
    exports2[3] = "EE_WRITE";
    exports2[4] = "EE_BADCLOSE";
    exports2[5] = "EE_OUTOFMEMORY";
    exports2[6] = "EE_DELETE";
    exports2[7] = "EE_LINK";
    exports2[9] = "EE_EOFERR";
    exports2[10] = "EE_CANTLOCK";
    exports2[11] = "EE_CANTUNLOCK";
    exports2[12] = "EE_DIR";
    exports2[13] = "EE_STAT";
    exports2[14] = "EE_CANT_CHSIZE";
    exports2[15] = "EE_CANT_OPEN_STREAM";
    exports2[16] = "EE_GETWD";
    exports2[17] = "EE_SETWD";
    exports2[18] = "EE_LINK_WARNING";
    exports2[19] = "EE_OPEN_WARNING";
    exports2[20] = "EE_DISK_FULL";
    exports2[21] = "EE_CANT_MKDIR";
    exports2[22] = "EE_UNKNOWN_CHARSET";
    exports2[23] = "EE_OUT_OF_FILERESOURCES";
    exports2[24] = "EE_CANT_READLINK";
    exports2[25] = "EE_CANT_SYMLINK";
    exports2[26] = "EE_REALPATH";
    exports2[27] = "EE_SYNC";
    exports2[28] = "EE_UNKNOWN_COLLATION";
    exports2[29] = "EE_FILENOTFOUND";
    exports2[30] = "EE_FILE_NOT_CLOSED";
    exports2[31] = "EE_CHANGE_OWNERSHIP";
    exports2[32] = "EE_CHANGE_PERMISSIONS";
    exports2[33] = "EE_CANT_SEEK";
    exports2[34] = "EE_CAPACITY_EXCEEDED";
    exports2[120] = "HA_ERR_KEY_NOT_FOUND";
    exports2[121] = "HA_ERR_FOUND_DUPP_KEY";
    exports2[122] = "HA_ERR_INTERNAL_ERROR";
    exports2[123] = "HA_ERR_RECORD_CHANGED";
    exports2[124] = "HA_ERR_WRONG_INDEX";
    exports2[126] = "HA_ERR_CRASHED";
    exports2[127] = "HA_ERR_WRONG_IN_RECORD";
    exports2[128] = "HA_ERR_OUT_OF_MEM";
    exports2[130] = "HA_ERR_NOT_A_TABLE";
    exports2[131] = "HA_ERR_WRONG_COMMAND";
    exports2[132] = "HA_ERR_OLD_FILE";
    exports2[133] = "HA_ERR_NO_ACTIVE_RECORD";
    exports2[134] = "HA_ERR_RECORD_DELETED";
    exports2[135] = "HA_ERR_RECORD_FILE_FULL";
    exports2[136] = "HA_ERR_INDEX_FILE_FULL";
    exports2[137] = "HA_ERR_END_OF_FILE";
    exports2[138] = "HA_ERR_UNSUPPORTED";
    exports2[139] = "HA_ERR_TOO_BIG_ROW";
    exports2[140] = "HA_WRONG_CREATE_OPTION";
    exports2[141] = "HA_ERR_FOUND_DUPP_UNIQUE";
    exports2[142] = "HA_ERR_UNKNOWN_CHARSET";
    exports2[143] = "HA_ERR_WRONG_MRG_TABLE_DEF";
    exports2[144] = "HA_ERR_CRASHED_ON_REPAIR";
    exports2[145] = "HA_ERR_CRASHED_ON_USAGE";
    exports2[146] = "HA_ERR_LOCK_WAIT_TIMEOUT";
    exports2[147] = "HA_ERR_LOCK_TABLE_FULL";
    exports2[148] = "HA_ERR_READ_ONLY_TRANSACTION";
    exports2[149] = "HA_ERR_LOCK_DEADLOCK";
    exports2[150] = "HA_ERR_CANNOT_ADD_FOREIGN";
    exports2[151] = "HA_ERR_NO_REFERENCED_ROW";
    exports2[152] = "HA_ERR_ROW_IS_REFERENCED";
    exports2[153] = "HA_ERR_NO_SAVEPOINT";
    exports2[154] = "HA_ERR_NON_UNIQUE_BLOCK_SIZE";
    exports2[155] = "HA_ERR_NO_SUCH_TABLE";
    exports2[156] = "HA_ERR_TABLE_EXIST";
    exports2[157] = "HA_ERR_NO_CONNECTION";
    exports2[158] = "HA_ERR_NULL_IN_SPATIAL";
    exports2[159] = "HA_ERR_TABLE_DEF_CHANGED";
    exports2[160] = "HA_ERR_NO_PARTITION_FOUND";
    exports2[161] = "HA_ERR_RBR_LOGGING_FAILED";
    exports2[162] = "HA_ERR_DROP_INDEX_FK";
    exports2[163] = "HA_ERR_FOREIGN_DUPLICATE_KEY";
    exports2[164] = "HA_ERR_TABLE_NEEDS_UPGRADE";
    exports2[165] = "HA_ERR_TABLE_READONLY";
    exports2[166] = "HA_ERR_AUTOINC_READ_FAILED";
    exports2[167] = "HA_ERR_AUTOINC_ERANGE";
    exports2[168] = "HA_ERR_GENERIC";
    exports2[169] = "HA_ERR_RECORD_IS_THE_SAME";
    exports2[170] = "HA_ERR_LOGGING_IMPOSSIBLE";
    exports2[171] = "HA_ERR_CORRUPT_EVENT";
    exports2[172] = "HA_ERR_NEW_FILE";
    exports2[173] = "HA_ERR_ROWS_EVENT_APPLY";
    exports2[174] = "HA_ERR_INITIALIZATION";
    exports2[175] = "HA_ERR_FILE_TOO_SHORT";
    exports2[176] = "HA_ERR_WRONG_CRC";
    exports2[177] = "HA_ERR_TOO_MANY_CONCURRENT_TRXS";
    exports2[178] = "HA_ERR_NOT_IN_LOCK_PARTITIONS";
    exports2[179] = "HA_ERR_INDEX_COL_TOO_LONG";
    exports2[180] = "HA_ERR_INDEX_CORRUPT";
    exports2[181] = "HA_ERR_UNDO_REC_TOO_BIG";
    exports2[182] = "HA_FTS_INVALID_DOCID";
    exports2[183] = "HA_ERR_TABLE_IN_FK_CHECK";
    exports2[184] = "HA_ERR_TABLESPACE_EXISTS";
    exports2[185] = "HA_ERR_TOO_MANY_FIELDS";
    exports2[186] = "HA_ERR_ROW_IN_WRONG_PARTITION";
    exports2[187] = "HA_ERR_INNODB_READ_ONLY";
    exports2[188] = "HA_ERR_FTS_EXCEED_RESULT_CACHE_LIMIT";
    exports2[189] = "HA_ERR_TEMP_FILE_WRITE_FAILURE";
    exports2[190] = "HA_ERR_INNODB_FORCED_RECOVERY";
    exports2[191] = "HA_ERR_FTS_TOO_MANY_WORDS_IN_PHRASE";
    exports2[192] = "HA_ERR_FK_DEPTH_EXCEEDED";
    exports2[193] = "HA_MISSING_CREATE_OPTION";
    exports2[194] = "HA_ERR_SE_OUT_OF_MEMORY";
    exports2[195] = "HA_ERR_TABLE_CORRUPT";
    exports2[196] = "HA_ERR_QUERY_INTERRUPTED";
    exports2[197] = "HA_ERR_TABLESPACE_MISSING";
    exports2[198] = "HA_ERR_TABLESPACE_IS_NOT_EMPTY";
    exports2[199] = "HA_ERR_WRONG_FILE_NAME";
    exports2[200] = "HA_ERR_NOT_ALLOWED_COMMAND";
    exports2[201] = "HA_ERR_COMPUTE_FAILED";
    exports2[1e3] = "ER_HASHCHK";
    exports2[1001] = "ER_NISAMCHK";
    exports2[1002] = "ER_NO";
    exports2[1003] = "ER_YES";
    exports2[1004] = "ER_CANT_CREATE_FILE";
    exports2[1005] = "ER_CANT_CREATE_TABLE";
    exports2[1006] = "ER_CANT_CREATE_DB";
    exports2[1007] = "ER_DB_CREATE_EXISTS";
    exports2[1008] = "ER_DB_DROP_EXISTS";
    exports2[1009] = "ER_DB_DROP_DELETE";
    exports2[1010] = "ER_DB_DROP_RMDIR";
    exports2[1011] = "ER_CANT_DELETE_FILE";
    exports2[1012] = "ER_CANT_FIND_SYSTEM_REC";
    exports2[1013] = "ER_CANT_GET_STAT";
    exports2[1014] = "ER_CANT_GET_WD";
    exports2[1015] = "ER_CANT_LOCK";
    exports2[1016] = "ER_CANT_OPEN_FILE";
    exports2[1017] = "ER_FILE_NOT_FOUND";
    exports2[1018] = "ER_CANT_READ_DIR";
    exports2[1019] = "ER_CANT_SET_WD";
    exports2[1020] = "ER_CHECKREAD";
    exports2[1021] = "ER_DISK_FULL";
    exports2[1022] = "ER_DUP_KEY";
    exports2[1023] = "ER_ERROR_ON_CLOSE";
    exports2[1024] = "ER_ERROR_ON_READ";
    exports2[1025] = "ER_ERROR_ON_RENAME";
    exports2[1026] = "ER_ERROR_ON_WRITE";
    exports2[1027] = "ER_FILE_USED";
    exports2[1028] = "ER_FILSORT_ABORT";
    exports2[1029] = "ER_FORM_NOT_FOUND";
    exports2[1030] = "ER_GET_ERRNO";
    exports2[1031] = "ER_ILLEGAL_HA";
    exports2[1032] = "ER_KEY_NOT_FOUND";
    exports2[1033] = "ER_NOT_FORM_FILE";
    exports2[1034] = "ER_NOT_KEYFILE";
    exports2[1035] = "ER_OLD_KEYFILE";
    exports2[1036] = "ER_OPEN_AS_READONLY";
    exports2[1037] = "ER_OUTOFMEMORY";
    exports2[1038] = "ER_OUT_OF_SORTMEMORY";
    exports2[1039] = "ER_UNEXPECTED_EOF";
    exports2[1040] = "ER_CON_COUNT_ERROR";
    exports2[1041] = "ER_OUT_OF_RESOURCES";
    exports2[1042] = "ER_BAD_HOST_ERROR";
    exports2[1043] = "ER_HANDSHAKE_ERROR";
    exports2[1044] = "ER_DBACCESS_DENIED_ERROR";
    exports2[1045] = "ER_ACCESS_DENIED_ERROR";
    exports2[1046] = "ER_NO_DB_ERROR";
    exports2[1047] = "ER_UNKNOWN_COM_ERROR";
    exports2[1048] = "ER_BAD_NULL_ERROR";
    exports2[1049] = "ER_BAD_DB_ERROR";
    exports2[1050] = "ER_TABLE_EXISTS_ERROR";
    exports2[1051] = "ER_BAD_TABLE_ERROR";
    exports2[1052] = "ER_NON_UNIQ_ERROR";
    exports2[1053] = "ER_SERVER_SHUTDOWN";
    exports2[1054] = "ER_BAD_FIELD_ERROR";
    exports2[1055] = "ER_WRONG_FIELD_WITH_GROUP";
    exports2[1056] = "ER_WRONG_GROUP_FIELD";
    exports2[1057] = "ER_WRONG_SUM_SELECT";
    exports2[1058] = "ER_WRONG_VALUE_COUNT";
    exports2[1059] = "ER_TOO_LONG_IDENT";
    exports2[1060] = "ER_DUP_FIELDNAME";
    exports2[1061] = "ER_DUP_KEYNAME";
    exports2[1062] = "ER_DUP_ENTRY";
    exports2[1063] = "ER_WRONG_FIELD_SPEC";
    exports2[1064] = "ER_PARSE_ERROR";
    exports2[1065] = "ER_EMPTY_QUERY";
    exports2[1066] = "ER_NONUNIQ_TABLE";
    exports2[1067] = "ER_INVALID_DEFAULT";
    exports2[1068] = "ER_MULTIPLE_PRI_KEY";
    exports2[1069] = "ER_TOO_MANY_KEYS";
    exports2[1070] = "ER_TOO_MANY_KEY_PARTS";
    exports2[1071] = "ER_TOO_LONG_KEY";
    exports2[1072] = "ER_KEY_COLUMN_DOES_NOT_EXITS";
    exports2[1073] = "ER_BLOB_USED_AS_KEY";
    exports2[1074] = "ER_TOO_BIG_FIELDLENGTH";
    exports2[1075] = "ER_WRONG_AUTO_KEY";
    exports2[1076] = "ER_READY";
    exports2[1077] = "ER_NORMAL_SHUTDOWN";
    exports2[1078] = "ER_GOT_SIGNAL";
    exports2[1079] = "ER_SHUTDOWN_COMPLETE";
    exports2[1080] = "ER_FORCING_CLOSE";
    exports2[1081] = "ER_IPSOCK_ERROR";
    exports2[1082] = "ER_NO_SUCH_INDEX";
    exports2[1083] = "ER_WRONG_FIELD_TERMINATORS";
    exports2[1084] = "ER_BLOBS_AND_NO_TERMINATED";
    exports2[1085] = "ER_TEXTFILE_NOT_READABLE";
    exports2[1086] = "ER_FILE_EXISTS_ERROR";
    exports2[1087] = "ER_LOAD_INFO";
    exports2[1088] = "ER_ALTER_INFO";
    exports2[1089] = "ER_WRONG_SUB_KEY";
    exports2[1090] = "ER_CANT_REMOVE_ALL_FIELDS";
    exports2[1091] = "ER_CANT_DROP_FIELD_OR_KEY";
    exports2[1092] = "ER_INSERT_INFO";
    exports2[1093] = "ER_UPDATE_TABLE_USED";
    exports2[1094] = "ER_NO_SUCH_THREAD";
    exports2[1095] = "ER_KILL_DENIED_ERROR";
    exports2[1096] = "ER_NO_TABLES_USED";
    exports2[1097] = "ER_TOO_BIG_SET";
    exports2[1098] = "ER_NO_UNIQUE_LOGFILE";
    exports2[1099] = "ER_TABLE_NOT_LOCKED_FOR_WRITE";
    exports2[1100] = "ER_TABLE_NOT_LOCKED";
    exports2[1101] = "ER_BLOB_CANT_HAVE_DEFAULT";
    exports2[1102] = "ER_WRONG_DB_NAME";
    exports2[1103] = "ER_WRONG_TABLE_NAME";
    exports2[1104] = "ER_TOO_BIG_SELECT";
    exports2[1105] = "ER_UNKNOWN_ERROR";
    exports2[1106] = "ER_UNKNOWN_PROCEDURE";
    exports2[1107] = "ER_WRONG_PARAMCOUNT_TO_PROCEDURE";
    exports2[1108] = "ER_WRONG_PARAMETERS_TO_PROCEDURE";
    exports2[1109] = "ER_UNKNOWN_TABLE";
    exports2[1110] = "ER_FIELD_SPECIFIED_TWICE";
    exports2[1111] = "ER_INVALID_GROUP_FUNC_USE";
    exports2[1112] = "ER_UNSUPPORTED_EXTENSION";
    exports2[1113] = "ER_TABLE_MUST_HAVE_COLUMNS";
    exports2[1114] = "ER_RECORD_FILE_FULL";
    exports2[1115] = "ER_UNKNOWN_CHARACTER_SET";
    exports2[1116] = "ER_TOO_MANY_TABLES";
    exports2[1117] = "ER_TOO_MANY_FIELDS";
    exports2[1118] = "ER_TOO_BIG_ROWSIZE";
    exports2[1119] = "ER_STACK_OVERRUN";
    exports2[1120] = "ER_WRONG_OUTER_JOIN";
    exports2[1121] = "ER_NULL_COLUMN_IN_INDEX";
    exports2[1122] = "ER_CANT_FIND_UDF";
    exports2[1123] = "ER_CANT_INITIALIZE_UDF";
    exports2[1124] = "ER_UDF_NO_PATHS";
    exports2[1125] = "ER_UDF_EXISTS";
    exports2[1126] = "ER_CANT_OPEN_LIBRARY";
    exports2[1127] = "ER_CANT_FIND_DL_ENTRY";
    exports2[1128] = "ER_FUNCTION_NOT_DEFINED";
    exports2[1129] = "ER_HOST_IS_BLOCKED";
    exports2[1130] = "ER_HOST_NOT_PRIVILEGED";
    exports2[1131] = "ER_PASSWORD_ANONYMOUS_USER";
    exports2[1132] = "ER_PASSWORD_NOT_ALLOWED";
    exports2[1133] = "ER_PASSWORD_NO_MATCH";
    exports2[1134] = "ER_UPDATE_INFO";
    exports2[1135] = "ER_CANT_CREATE_THREAD";
    exports2[1136] = "ER_WRONG_VALUE_COUNT_ON_ROW";
    exports2[1137] = "ER_CANT_REOPEN_TABLE";
    exports2[1138] = "ER_INVALID_USE_OF_NULL";
    exports2[1139] = "ER_REGEXP_ERROR";
    exports2[1140] = "ER_MIX_OF_GROUP_FUNC_AND_FIELDS";
    exports2[1141] = "ER_NONEXISTING_GRANT";
    exports2[1142] = "ER_TABLEACCESS_DENIED_ERROR";
    exports2[1143] = "ER_COLUMNACCESS_DENIED_ERROR";
    exports2[1144] = "ER_ILLEGAL_GRANT_FOR_TABLE";
    exports2[1145] = "ER_GRANT_WRONG_HOST_OR_USER";
    exports2[1146] = "ER_NO_SUCH_TABLE";
    exports2[1147] = "ER_NONEXISTING_TABLE_GRANT";
    exports2[1148] = "ER_NOT_ALLOWED_COMMAND";
    exports2[1149] = "ER_SYNTAX_ERROR";
    exports2[1150] = "ER_DELAYED_CANT_CHANGE_LOCK";
    exports2[1151] = "ER_TOO_MANY_DELAYED_THREADS";
    exports2[1152] = "ER_ABORTING_CONNECTION";
    exports2[1153] = "ER_NET_PACKET_TOO_LARGE";
    exports2[1154] = "ER_NET_READ_ERROR_FROM_PIPE";
    exports2[1155] = "ER_NET_FCNTL_ERROR";
    exports2[1156] = "ER_NET_PACKETS_OUT_OF_ORDER";
    exports2[1157] = "ER_NET_UNCOMPRESS_ERROR";
    exports2[1158] = "ER_NET_READ_ERROR";
    exports2[1159] = "ER_NET_READ_INTERRUPTED";
    exports2[1160] = "ER_NET_ERROR_ON_WRITE";
    exports2[1161] = "ER_NET_WRITE_INTERRUPTED";
    exports2[1162] = "ER_TOO_LONG_STRING";
    exports2[1163] = "ER_TABLE_CANT_HANDLE_BLOB";
    exports2[1164] = "ER_TABLE_CANT_HANDLE_AUTO_INCREMENT";
    exports2[1165] = "ER_DELAYED_INSERT_TABLE_LOCKED";
    exports2[1166] = "ER_WRONG_COLUMN_NAME";
    exports2[1167] = "ER_WRONG_KEY_COLUMN";
    exports2[1168] = "ER_WRONG_MRG_TABLE";
    exports2[1169] = "ER_DUP_UNIQUE";
    exports2[1170] = "ER_BLOB_KEY_WITHOUT_LENGTH";
    exports2[1171] = "ER_PRIMARY_CANT_HAVE_NULL";
    exports2[1172] = "ER_TOO_MANY_ROWS";
    exports2[1173] = "ER_REQUIRES_PRIMARY_KEY";
    exports2[1174] = "ER_NO_RAID_COMPILED";
    exports2[1175] = "ER_UPDATE_WITHOUT_KEY_IN_SAFE_MODE";
    exports2[1176] = "ER_KEY_DOES_NOT_EXITS";
    exports2[1177] = "ER_CHECK_NO_SUCH_TABLE";
    exports2[1178] = "ER_CHECK_NOT_IMPLEMENTED";
    exports2[1179] = "ER_CANT_DO_THIS_DURING_AN_TRANSACTION";
    exports2[1180] = "ER_ERROR_DURING_COMMIT";
    exports2[1181] = "ER_ERROR_DURING_ROLLBACK";
    exports2[1182] = "ER_ERROR_DURING_FLUSH_LOGS";
    exports2[1183] = "ER_ERROR_DURING_CHECKPOINT";
    exports2[1184] = "ER_NEW_ABORTING_CONNECTION";
    exports2[1185] = "ER_DUMP_NOT_IMPLEMENTED";
    exports2[1186] = "ER_FLUSH_MASTER_BINLOG_CLOSED";
    exports2[1187] = "ER_INDEX_REBUILD";
    exports2[1188] = "ER_MASTER";
    exports2[1189] = "ER_MASTER_NET_READ";
    exports2[1190] = "ER_MASTER_NET_WRITE";
    exports2[1191] = "ER_FT_MATCHING_KEY_NOT_FOUND";
    exports2[1192] = "ER_LOCK_OR_ACTIVE_TRANSACTION";
    exports2[1193] = "ER_UNKNOWN_SYSTEM_VARIABLE";
    exports2[1194] = "ER_CRASHED_ON_USAGE";
    exports2[1195] = "ER_CRASHED_ON_REPAIR";
    exports2[1196] = "ER_WARNING_NOT_COMPLETE_ROLLBACK";
    exports2[1197] = "ER_TRANS_CACHE_FULL";
    exports2[1198] = "ER_SLAVE_MUST_STOP";
    exports2[1199] = "ER_SLAVE_NOT_RUNNING";
    exports2[1200] = "ER_BAD_SLAVE";
    exports2[1201] = "ER_MASTER_INFO";
    exports2[1202] = "ER_SLAVE_THREAD";
    exports2[1203] = "ER_TOO_MANY_USER_CONNECTIONS";
    exports2[1204] = "ER_SET_CONSTANTS_ONLY";
    exports2[1205] = "ER_LOCK_WAIT_TIMEOUT";
    exports2[1206] = "ER_LOCK_TABLE_FULL";
    exports2[1207] = "ER_READ_ONLY_TRANSACTION";
    exports2[1208] = "ER_DROP_DB_WITH_READ_LOCK";
    exports2[1209] = "ER_CREATE_DB_WITH_READ_LOCK";
    exports2[1210] = "ER_WRONG_ARGUMENTS";
    exports2[1211] = "ER_NO_PERMISSION_TO_CREATE_USER";
    exports2[1212] = "ER_UNION_TABLES_IN_DIFFERENT_DIR";
    exports2[1213] = "ER_LOCK_DEADLOCK";
    exports2[1214] = "ER_TABLE_CANT_HANDLE_FT";
    exports2[1215] = "ER_CANNOT_ADD_FOREIGN";
    exports2[1216] = "ER_NO_REFERENCED_ROW";
    exports2[1217] = "ER_ROW_IS_REFERENCED";
    exports2[1218] = "ER_CONNECT_TO_MASTER";
    exports2[1219] = "ER_QUERY_ON_MASTER";
    exports2[1220] = "ER_ERROR_WHEN_EXECUTING_COMMAND";
    exports2[1221] = "ER_WRONG_USAGE";
    exports2[1222] = "ER_WRONG_NUMBER_OF_COLUMNS_IN_SELECT";
    exports2[1223] = "ER_CANT_UPDATE_WITH_READLOCK";
    exports2[1224] = "ER_MIXING_NOT_ALLOWED";
    exports2[1225] = "ER_DUP_ARGUMENT";
    exports2[1226] = "ER_USER_LIMIT_REACHED";
    exports2[1227] = "ER_SPECIFIC_ACCESS_DENIED_ERROR";
    exports2[1228] = "ER_LOCAL_VARIABLE";
    exports2[1229] = "ER_GLOBAL_VARIABLE";
    exports2[1230] = "ER_NO_DEFAULT";
    exports2[1231] = "ER_WRONG_VALUE_FOR_VAR";
    exports2[1232] = "ER_WRONG_TYPE_FOR_VAR";
    exports2[1233] = "ER_VAR_CANT_BE_READ";
    exports2[1234] = "ER_CANT_USE_OPTION_HERE";
    exports2[1235] = "ER_NOT_SUPPORTED_YET";
    exports2[1236] = "ER_MASTER_FATAL_ERROR_READING_BINLOG";
    exports2[1237] = "ER_SLAVE_IGNORED_TABLE";
    exports2[1238] = "ER_INCORRECT_GLOBAL_LOCAL_VAR";
    exports2[1239] = "ER_WRONG_FK_DEF";
    exports2[1240] = "ER_KEY_REF_DO_NOT_MATCH_TABLE_REF";
    exports2[1241] = "ER_OPERAND_COLUMNS";
    exports2[1242] = "ER_SUBQUERY_NO_1_ROW";
    exports2[1243] = "ER_UNKNOWN_STMT_HANDLER";
    exports2[1244] = "ER_CORRUPT_HELP_DB";
    exports2[1245] = "ER_CYCLIC_REFERENCE";
    exports2[1246] = "ER_AUTO_CONVERT";
    exports2[1247] = "ER_ILLEGAL_REFERENCE";
    exports2[1248] = "ER_DERIVED_MUST_HAVE_ALIAS";
    exports2[1249] = "ER_SELECT_REDUCED";
    exports2[1250] = "ER_TABLENAME_NOT_ALLOWED_HERE";
    exports2[1251] = "ER_NOT_SUPPORTED_AUTH_MODE";
    exports2[1252] = "ER_SPATIAL_CANT_HAVE_NULL";
    exports2[1253] = "ER_COLLATION_CHARSET_MISMATCH";
    exports2[1254] = "ER_SLAVE_WAS_RUNNING";
    exports2[1255] = "ER_SLAVE_WAS_NOT_RUNNING";
    exports2[1256] = "ER_TOO_BIG_FOR_UNCOMPRESS";
    exports2[1257] = "ER_ZLIB_Z_MEM_ERROR";
    exports2[1258] = "ER_ZLIB_Z_BUF_ERROR";
    exports2[1259] = "ER_ZLIB_Z_DATA_ERROR";
    exports2[1260] = "ER_CUT_VALUE_GROUP_CONCAT";
    exports2[1261] = "ER_WARN_TOO_FEW_RECORDS";
    exports2[1262] = "ER_WARN_TOO_MANY_RECORDS";
    exports2[1263] = "ER_WARN_NULL_TO_NOTNULL";
    exports2[1264] = "ER_WARN_DATA_OUT_OF_RANGE";
    exports2[1265] = "WARN_DATA_TRUNCATED";
    exports2[1266] = "ER_WARN_USING_OTHER_HANDLER";
    exports2[1267] = "ER_CANT_AGGREGATE_2COLLATIONS";
    exports2[1268] = "ER_DROP_USER";
    exports2[1269] = "ER_REVOKE_GRANTS";
    exports2[1270] = "ER_CANT_AGGREGATE_3COLLATIONS";
    exports2[1271] = "ER_CANT_AGGREGATE_NCOLLATIONS";
    exports2[1272] = "ER_VARIABLE_IS_NOT_STRUCT";
    exports2[1273] = "ER_UNKNOWN_COLLATION";
    exports2[1274] = "ER_SLAVE_IGNORED_SSL_PARAMS";
    exports2[1275] = "ER_SERVER_IS_IN_SECURE_AUTH_MODE";
    exports2[1276] = "ER_WARN_FIELD_RESOLVED";
    exports2[1277] = "ER_BAD_SLAVE_UNTIL_COND";
    exports2[1278] = "ER_MISSING_SKIP_SLAVE";
    exports2[1279] = "ER_UNTIL_COND_IGNORED";
    exports2[1280] = "ER_WRONG_NAME_FOR_INDEX";
    exports2[1281] = "ER_WRONG_NAME_FOR_CATALOG";
    exports2[1282] = "ER_WARN_QC_RESIZE";
    exports2[1283] = "ER_BAD_FT_COLUMN";
    exports2[1284] = "ER_UNKNOWN_KEY_CACHE";
    exports2[1285] = "ER_WARN_HOSTNAME_WONT_WORK";
    exports2[1286] = "ER_UNKNOWN_STORAGE_ENGINE";
    exports2[1287] = "ER_WARN_DEPRECATED_SYNTAX";
    exports2[1288] = "ER_NON_UPDATABLE_TABLE";
    exports2[1289] = "ER_FEATURE_DISABLED";
    exports2[1290] = "ER_OPTION_PREVENTS_STATEMENT";
    exports2[1291] = "ER_DUPLICATED_VALUE_IN_TYPE";
    exports2[1292] = "ER_TRUNCATED_WRONG_VALUE";
    exports2[1293] = "ER_TOO_MUCH_AUTO_TIMESTAMP_COLS";
    exports2[1294] = "ER_INVALID_ON_UPDATE";
    exports2[1295] = "ER_UNSUPPORTED_PS";
    exports2[1296] = "ER_GET_ERRMSG";
    exports2[1297] = "ER_GET_TEMPORARY_ERRMSG";
    exports2[1298] = "ER_UNKNOWN_TIME_ZONE";
    exports2[1299] = "ER_WARN_INVALID_TIMESTAMP";
    exports2[1300] = "ER_INVALID_CHARACTER_STRING";
    exports2[1301] = "ER_WARN_ALLOWED_PACKET_OVERFLOWED";
    exports2[1302] = "ER_CONFLICTING_DECLARATIONS";
    exports2[1303] = "ER_SP_NO_RECURSIVE_CREATE";
    exports2[1304] = "ER_SP_ALREADY_EXISTS";
    exports2[1305] = "ER_SP_DOES_NOT_EXIST";
    exports2[1306] = "ER_SP_DROP_FAILED";
    exports2[1307] = "ER_SP_STORE_FAILED";
    exports2[1308] = "ER_SP_LILABEL_MISMATCH";
    exports2[1309] = "ER_SP_LABEL_REDEFINE";
    exports2[1310] = "ER_SP_LABEL_MISMATCH";
    exports2[1311] = "ER_SP_UNINIT_VAR";
    exports2[1312] = "ER_SP_BADSELECT";
    exports2[1313] = "ER_SP_BADRETURN";
    exports2[1314] = "ER_SP_BADSTATEMENT";
    exports2[1315] = "ER_UPDATE_LOG_DEPRECATED_IGNORED";
    exports2[1316] = "ER_UPDATE_LOG_DEPRECATED_TRANSLATED";
    exports2[1317] = "ER_QUERY_INTERRUPTED";
    exports2[1318] = "ER_SP_WRONG_NO_OF_ARGS";
    exports2[1319] = "ER_SP_COND_MISMATCH";
    exports2[1320] = "ER_SP_NORETURN";
    exports2[1321] = "ER_SP_NORETURNEND";
    exports2[1322] = "ER_SP_BAD_CURSOR_QUERY";
    exports2[1323] = "ER_SP_BAD_CURSOR_SELECT";
    exports2[1324] = "ER_SP_CURSOR_MISMATCH";
    exports2[1325] = "ER_SP_CURSOR_ALREADY_OPEN";
    exports2[1326] = "ER_SP_CURSOR_NOT_OPEN";
    exports2[1327] = "ER_SP_UNDECLARED_VAR";
    exports2[1328] = "ER_SP_WRONG_NO_OF_FETCH_ARGS";
    exports2[1329] = "ER_SP_FETCH_NO_DATA";
    exports2[1330] = "ER_SP_DUP_PARAM";
    exports2[1331] = "ER_SP_DUP_VAR";
    exports2[1332] = "ER_SP_DUP_COND";
    exports2[1333] = "ER_SP_DUP_CURS";
    exports2[1334] = "ER_SP_CANT_ALTER";
    exports2[1335] = "ER_SP_SUBSELECT_NYI";
    exports2[1336] = "ER_STMT_NOT_ALLOWED_IN_SF_OR_TRG";
    exports2[1337] = "ER_SP_VARCOND_AFTER_CURSHNDLR";
    exports2[1338] = "ER_SP_CURSOR_AFTER_HANDLER";
    exports2[1339] = "ER_SP_CASE_NOT_FOUND";
    exports2[1340] = "ER_FPARSER_TOO_BIG_FILE";
    exports2[1341] = "ER_FPARSER_BAD_HEADER";
    exports2[1342] = "ER_FPARSER_EOF_IN_COMMENT";
    exports2[1343] = "ER_FPARSER_ERROR_IN_PARAMETER";
    exports2[1344] = "ER_FPARSER_EOF_IN_UNKNOWN_PARAMETER";
    exports2[1345] = "ER_VIEW_NO_EXPLAIN";
    exports2[1346] = "ER_FRM_UNKNOWN_TYPE";
    exports2[1347] = "ER_WRONG_OBJECT";
    exports2[1348] = "ER_NONUPDATEABLE_COLUMN";
    exports2[1349] = "ER_VIEW_SELECT_DERIVED";
    exports2[1350] = "ER_VIEW_SELECT_CLAUSE";
    exports2[1351] = "ER_VIEW_SELECT_VARIABLE";
    exports2[1352] = "ER_VIEW_SELECT_TMPTABLE";
    exports2[1353] = "ER_VIEW_WRONG_LIST";
    exports2[1354] = "ER_WARN_VIEW_MERGE";
    exports2[1355] = "ER_WARN_VIEW_WITHOUT_KEY";
    exports2[1356] = "ER_VIEW_INVALID";
    exports2[1357] = "ER_SP_NO_DROP_SP";
    exports2[1358] = "ER_SP_GOTO_IN_HNDLR";
    exports2[1359] = "ER_TRG_ALREADY_EXISTS";
    exports2[1360] = "ER_TRG_DOES_NOT_EXIST";
    exports2[1361] = "ER_TRG_ON_VIEW_OR_TEMP_TABLE";
    exports2[1362] = "ER_TRG_CANT_CHANGE_ROW";
    exports2[1363] = "ER_TRG_NO_SUCH_ROW_IN_TRG";
    exports2[1364] = "ER_NO_DEFAULT_FOR_FIELD";
    exports2[1365] = "ER_DIVISION_BY_ZERO";
    exports2[1366] = "ER_TRUNCATED_WRONG_VALUE_FOR_FIELD";
    exports2[1367] = "ER_ILLEGAL_VALUE_FOR_TYPE";
    exports2[1368] = "ER_VIEW_NONUPD_CHECK";
    exports2[1369] = "ER_VIEW_CHECK_FAILED";
    exports2[1370] = "ER_PROCACCESS_DENIED_ERROR";
    exports2[1371] = "ER_RELAY_LOG_FAIL";
    exports2[1372] = "ER_PASSWD_LENGTH";
    exports2[1373] = "ER_UNKNOWN_TARGET_BINLOG";
    exports2[1374] = "ER_IO_ERR_LOG_INDEX_READ";
    exports2[1375] = "ER_BINLOG_PURGE_PROHIBITED";
    exports2[1376] = "ER_FSEEK_FAIL";
    exports2[1377] = "ER_BINLOG_PURGE_FATAL_ERR";
    exports2[1378] = "ER_LOG_IN_USE";
    exports2[1379] = "ER_LOG_PURGE_UNKNOWN_ERR";
    exports2[1380] = "ER_RELAY_LOG_INIT";
    exports2[1381] = "ER_NO_BINARY_LOGGING";
    exports2[1382] = "ER_RESERVED_SYNTAX";
    exports2[1383] = "ER_WSAS_FAILED";
    exports2[1384] = "ER_DIFF_GROUPS_PROC";
    exports2[1385] = "ER_NO_GROUP_FOR_PROC";
    exports2[1386] = "ER_ORDER_WITH_PROC";
    exports2[1387] = "ER_LOGGING_PROHIBIT_CHANGING_OF";
    exports2[1388] = "ER_NO_FILE_MAPPING";
    exports2[1389] = "ER_WRONG_MAGIC";
    exports2[1390] = "ER_PS_MANY_PARAM";
    exports2[1391] = "ER_KEY_PART_0";
    exports2[1392] = "ER_VIEW_CHECKSUM";
    exports2[1393] = "ER_VIEW_MULTIUPDATE";
    exports2[1394] = "ER_VIEW_NO_INSERT_FIELD_LIST";
    exports2[1395] = "ER_VIEW_DELETE_MERGE_VIEW";
    exports2[1396] = "ER_CANNOT_USER";
    exports2[1397] = "ER_XAER_NOTA";
    exports2[1398] = "ER_XAER_INVAL";
    exports2[1399] = "ER_XAER_RMFAIL";
    exports2[1400] = "ER_XAER_OUTSIDE";
    exports2[1401] = "ER_XAER_RMERR";
    exports2[1402] = "ER_XA_RBROLLBACK";
    exports2[1403] = "ER_NONEXISTING_PROC_GRANT";
    exports2[1404] = "ER_PROC_AUTO_GRANT_FAIL";
    exports2[1405] = "ER_PROC_AUTO_REVOKE_FAIL";
    exports2[1406] = "ER_DATA_TOO_LONG";
    exports2[1407] = "ER_SP_BAD_SQLSTATE";
    exports2[1408] = "ER_STARTUP";
    exports2[1409] = "ER_LOAD_FROM_FIXED_SIZE_ROWS_TO_VAR";
    exports2[1410] = "ER_CANT_CREATE_USER_WITH_GRANT";
    exports2[1411] = "ER_WRONG_VALUE_FOR_TYPE";
    exports2[1412] = "ER_TABLE_DEF_CHANGED";
    exports2[1413] = "ER_SP_DUP_HANDLER";
    exports2[1414] = "ER_SP_NOT_VAR_ARG";
    exports2[1415] = "ER_SP_NO_RETSET";
    exports2[1416] = "ER_CANT_CREATE_GEOMETRY_OBJECT";
    exports2[1417] = "ER_FAILED_ROUTINE_BREAK_BINLOG";
    exports2[1418] = "ER_BINLOG_UNSAFE_ROUTINE";
    exports2[1419] = "ER_BINLOG_CREATE_ROUTINE_NEED_SUPER";
    exports2[1420] = "ER_EXEC_STMT_WITH_OPEN_CURSOR";
    exports2[1421] = "ER_STMT_HAS_NO_OPEN_CURSOR";
    exports2[1422] = "ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG";
    exports2[1423] = "ER_NO_DEFAULT_FOR_VIEW_FIELD";
    exports2[1424] = "ER_SP_NO_RECURSION";
    exports2[1425] = "ER_TOO_BIG_SCALE";
    exports2[1426] = "ER_TOO_BIG_PRECISION";
    exports2[1427] = "ER_M_BIGGER_THAN_D";
    exports2[1428] = "ER_WRONG_LOCK_OF_SYSTEM_TABLE";
    exports2[1429] = "ER_CONNECT_TO_FOREIGN_DATA_SOURCE";
    exports2[1430] = "ER_QUERY_ON_FOREIGN_DATA_SOURCE";
    exports2[1431] = "ER_FOREIGN_DATA_SOURCE_DOESNT_EXIST";
    exports2[1432] = "ER_FOREIGN_DATA_STRING_INVALID_CANT_CREATE";
    exports2[1433] = "ER_FOREIGN_DATA_STRING_INVALID";
    exports2[1434] = "ER_CANT_CREATE_FEDERATED_TABLE";
    exports2[1435] = "ER_TRG_IN_WRONG_SCHEMA";
    exports2[1436] = "ER_STACK_OVERRUN_NEED_MORE";
    exports2[1437] = "ER_TOO_LONG_BODY";
    exports2[1438] = "ER_WARN_CANT_DROP_DEFAULT_KEYCACHE";
    exports2[1439] = "ER_TOO_BIG_DISPLAYWIDTH";
    exports2[1440] = "ER_XAER_DUPID";
    exports2[1441] = "ER_DATETIME_FUNCTION_OVERFLOW";
    exports2[1442] = "ER_CANT_UPDATE_USED_TABLE_IN_SF_OR_TRG";
    exports2[1443] = "ER_VIEW_PREVENT_UPDATE";
    exports2[1444] = "ER_PS_NO_RECURSION";
    exports2[1445] = "ER_SP_CANT_SET_AUTOCOMMIT";
    exports2[1446] = "ER_MALFORMED_DEFINER";
    exports2[1447] = "ER_VIEW_FRM_NO_USER";
    exports2[1448] = "ER_VIEW_OTHER_USER";
    exports2[1449] = "ER_NO_SUCH_USER";
    exports2[1450] = "ER_FORBID_SCHEMA_CHANGE";
    exports2[1451] = "ER_ROW_IS_REFERENCED_2";
    exports2[1452] = "ER_NO_REFERENCED_ROW_2";
    exports2[1453] = "ER_SP_BAD_VAR_SHADOW";
    exports2[1454] = "ER_TRG_NO_DEFINER";
    exports2[1455] = "ER_OLD_FILE_FORMAT";
    exports2[1456] = "ER_SP_RECURSION_LIMIT";
    exports2[1457] = "ER_SP_PROC_TABLE_CORRUPT";
    exports2[1458] = "ER_SP_WRONG_NAME";
    exports2[1459] = "ER_TABLE_NEEDS_UPGRADE";
    exports2[1460] = "ER_SP_NO_AGGREGATE";
    exports2[1461] = "ER_MAX_PREPARED_STMT_COUNT_REACHED";
    exports2[1462] = "ER_VIEW_RECURSIVE";
    exports2[1463] = "ER_NON_GROUPING_FIELD_USED";
    exports2[1464] = "ER_TABLE_CANT_HANDLE_SPKEYS";
    exports2[1465] = "ER_NO_TRIGGERS_ON_SYSTEM_SCHEMA";
    exports2[1466] = "ER_REMOVED_SPACES";
    exports2[1467] = "ER_AUTOINC_READ_FAILED";
    exports2[1468] = "ER_USERNAME";
    exports2[1469] = "ER_HOSTNAME";
    exports2[1470] = "ER_WRONG_STRING_LENGTH";
    exports2[1471] = "ER_NON_INSERTABLE_TABLE";
    exports2[1472] = "ER_ADMIN_WRONG_MRG_TABLE";
    exports2[1473] = "ER_TOO_HIGH_LEVEL_OF_NESTING_FOR_SELECT";
    exports2[1474] = "ER_NAME_BECOMES_EMPTY";
    exports2[1475] = "ER_AMBIGUOUS_FIELD_TERM";
    exports2[1476] = "ER_FOREIGN_SERVER_EXISTS";
    exports2[1477] = "ER_FOREIGN_SERVER_DOESNT_EXIST";
    exports2[1478] = "ER_ILLEGAL_HA_CREATE_OPTION";
    exports2[1479] = "ER_PARTITION_REQUIRES_VALUES_ERROR";
    exports2[1480] = "ER_PARTITION_WRONG_VALUES_ERROR";
    exports2[1481] = "ER_PARTITION_MAXVALUE_ERROR";
    exports2[1482] = "ER_PARTITION_SUBPARTITION_ERROR";
    exports2[1483] = "ER_PARTITION_SUBPART_MIX_ERROR";
    exports2[1484] = "ER_PARTITION_WRONG_NO_PART_ERROR";
    exports2[1485] = "ER_PARTITION_WRONG_NO_SUBPART_ERROR";
    exports2[1486] = "ER_WRONG_EXPR_IN_PARTITION_FUNC_ERROR";
    exports2[1487] = "ER_NO_CONST_EXPR_IN_RANGE_OR_LIST_ERROR";
    exports2[1488] = "ER_FIELD_NOT_FOUND_PART_ERROR";
    exports2[1489] = "ER_LIST_OF_FIELDS_ONLY_IN_HASH_ERROR";
    exports2[1490] = "ER_INCONSISTENT_PARTITION_INFO_ERROR";
    exports2[1491] = "ER_PARTITION_FUNC_NOT_ALLOWED_ERROR";
    exports2[1492] = "ER_PARTITIONS_MUST_BE_DEFINED_ERROR";
    exports2[1493] = "ER_RANGE_NOT_INCREASING_ERROR";
    exports2[1494] = "ER_INCONSISTENT_TYPE_OF_FUNCTIONS_ERROR";
    exports2[1495] = "ER_MULTIPLE_DEF_CONST_IN_LIST_PART_ERROR";
    exports2[1496] = "ER_PARTITION_ENTRY_ERROR";
    exports2[1497] = "ER_MIX_HANDLER_ERROR";
    exports2[1498] = "ER_PARTITION_NOT_DEFINED_ERROR";
    exports2[1499] = "ER_TOO_MANY_PARTITIONS_ERROR";
    exports2[1500] = "ER_SUBPARTITION_ERROR";
    exports2[1501] = "ER_CANT_CREATE_HANDLER_FILE";
    exports2[1502] = "ER_BLOB_FIELD_IN_PART_FUNC_ERROR";
    exports2[1503] = "ER_UNIQUE_KEY_NEED_ALL_FIELDS_IN_PF";
    exports2[1504] = "ER_NO_PARTS_ERROR";
    exports2[1505] = "ER_PARTITION_MGMT_ON_NONPARTITIONED";
    exports2[1506] = "ER_FOREIGN_KEY_ON_PARTITIONED";
    exports2[1507] = "ER_DROP_PARTITION_NON_EXISTENT";
    exports2[1508] = "ER_DROP_LAST_PARTITION";
    exports2[1509] = "ER_COALESCE_ONLY_ON_HASH_PARTITION";
    exports2[1510] = "ER_REORG_HASH_ONLY_ON_SAME_NO";
    exports2[1511] = "ER_REORG_NO_PARAM_ERROR";
    exports2[1512] = "ER_ONLY_ON_RANGE_LIST_PARTITION";
    exports2[1513] = "ER_ADD_PARTITION_SUBPART_ERROR";
    exports2[1514] = "ER_ADD_PARTITION_NO_NEW_PARTITION";
    exports2[1515] = "ER_COALESCE_PARTITION_NO_PARTITION";
    exports2[1516] = "ER_REORG_PARTITION_NOT_EXIST";
    exports2[1517] = "ER_SAME_NAME_PARTITION";
    exports2[1518] = "ER_NO_BINLOG_ERROR";
    exports2[1519] = "ER_CONSECUTIVE_REORG_PARTITIONS";
    exports2[1520] = "ER_REORG_OUTSIDE_RANGE";
    exports2[1521] = "ER_PARTITION_FUNCTION_FAILURE";
    exports2[1522] = "ER_PART_STATE_ERROR";
    exports2[1523] = "ER_LIMITED_PART_RANGE";
    exports2[1524] = "ER_PLUGIN_IS_NOT_LOADED";
    exports2[1525] = "ER_WRONG_VALUE";
    exports2[1526] = "ER_NO_PARTITION_FOR_GIVEN_VALUE";
    exports2[1527] = "ER_FILEGROUP_OPTION_ONLY_ONCE";
    exports2[1528] = "ER_CREATE_FILEGROUP_FAILED";
    exports2[1529] = "ER_DROP_FILEGROUP_FAILED";
    exports2[1530] = "ER_TABLESPACE_AUTO_EXTEND_ERROR";
    exports2[1531] = "ER_WRONG_SIZE_NUMBER";
    exports2[1532] = "ER_SIZE_OVERFLOW_ERROR";
    exports2[1533] = "ER_ALTER_FILEGROUP_FAILED";
    exports2[1534] = "ER_BINLOG_ROW_LOGGING_FAILED";
    exports2[1535] = "ER_BINLOG_ROW_WRONG_TABLE_DEF";
    exports2[1536] = "ER_BINLOG_ROW_RBR_TO_SBR";
    exports2[1537] = "ER_EVENT_ALREADY_EXISTS";
    exports2[1538] = "ER_EVENT_STORE_FAILED";
    exports2[1539] = "ER_EVENT_DOES_NOT_EXIST";
    exports2[1540] = "ER_EVENT_CANT_ALTER";
    exports2[1541] = "ER_EVENT_DROP_FAILED";
    exports2[1542] = "ER_EVENT_INTERVAL_NOT_POSITIVE_OR_TOO_BIG";
    exports2[1543] = "ER_EVENT_ENDS_BEFORE_STARTS";
    exports2[1544] = "ER_EVENT_EXEC_TIME_IN_THE_PAST";
    exports2[1545] = "ER_EVENT_OPEN_TABLE_FAILED";
    exports2[1546] = "ER_EVENT_NEITHER_M_EXPR_NOR_M_AT";
    exports2[1547] = "ER_COL_COUNT_DOESNT_MATCH_CORRUPTED";
    exports2[1548] = "ER_CANNOT_LOAD_FROM_TABLE";
    exports2[1549] = "ER_EVENT_CANNOT_DELETE";
    exports2[1550] = "ER_EVENT_COMPILE_ERROR";
    exports2[1551] = "ER_EVENT_SAME_NAME";
    exports2[1552] = "ER_EVENT_DATA_TOO_LONG";
    exports2[1553] = "ER_DROP_INDEX_FK";
    exports2[1554] = "ER_WARN_DEPRECATED_SYNTAX_WITH_VER";
    exports2[1555] = "ER_CANT_WRITE_LOCK_LOG_TABLE";
    exports2[1556] = "ER_CANT_LOCK_LOG_TABLE";
    exports2[1557] = "ER_FOREIGN_DUPLICATE_KEY";
    exports2[1558] = "ER_COL_COUNT_DOESNT_MATCH_PLEASE_UPDATE";
    exports2[1559] = "ER_TEMP_TABLE_PREVENTS_SWITCH_OUT_OF_RBR";
    exports2[1560] = "ER_STORED_FUNCTION_PREVENTS_SWITCH_BINLOG_FORMAT";
    exports2[1561] = "ER_NDB_CANT_SWITCH_BINLOG_FORMAT";
    exports2[1562] = "ER_PARTITION_NO_TEMPORARY";
    exports2[1563] = "ER_PARTITION_CONST_DOMAIN_ERROR";
    exports2[1564] = "ER_PARTITION_FUNCTION_IS_NOT_ALLOWED";
    exports2[1565] = "ER_DDL_LOG_ERROR";
    exports2[1566] = "ER_NULL_IN_VALUES_LESS_THAN";
    exports2[1567] = "ER_WRONG_PARTITION_NAME";
    exports2[1568] = "ER_CANT_CHANGE_TX_CHARACTERISTICS";
    exports2[1569] = "ER_DUP_ENTRY_AUTOINCREMENT_CASE";
    exports2[1570] = "ER_EVENT_MODIFY_QUEUE_ERROR";
    exports2[1571] = "ER_EVENT_SET_VAR_ERROR";
    exports2[1572] = "ER_PARTITION_MERGE_ERROR";
    exports2[1573] = "ER_CANT_ACTIVATE_LOG";
    exports2[1574] = "ER_RBR_NOT_AVAILABLE";
    exports2[1575] = "ER_BASE64_DECODE_ERROR";
    exports2[1576] = "ER_EVENT_RECURSION_FORBIDDEN";
    exports2[1577] = "ER_EVENTS_DB_ERROR";
    exports2[1578] = "ER_ONLY_INTEGERS_ALLOWED";
    exports2[1579] = "ER_UNSUPORTED_LOG_ENGINE";
    exports2[1580] = "ER_BAD_LOG_STATEMENT";
    exports2[1581] = "ER_CANT_RENAME_LOG_TABLE";
    exports2[1582] = "ER_WRONG_PARAMCOUNT_TO_NATIVE_FCT";
    exports2[1583] = "ER_WRONG_PARAMETERS_TO_NATIVE_FCT";
    exports2[1584] = "ER_WRONG_PARAMETERS_TO_STORED_FCT";
    exports2[1585] = "ER_NATIVE_FCT_NAME_COLLISION";
    exports2[1586] = "ER_DUP_ENTRY_WITH_KEY_NAME";
    exports2[1587] = "ER_BINLOG_PURGE_EMFILE";
    exports2[1588] = "ER_EVENT_CANNOT_CREATE_IN_THE_PAST";
    exports2[1589] = "ER_EVENT_CANNOT_ALTER_IN_THE_PAST";
    exports2[1590] = "ER_SLAVE_INCIDENT";
    exports2[1591] = "ER_NO_PARTITION_FOR_GIVEN_VALUE_SILENT";
    exports2[1592] = "ER_BINLOG_UNSAFE_STATEMENT";
    exports2[1593] = "ER_SLAVE_FATAL_ERROR";
    exports2[1594] = "ER_SLAVE_RELAY_LOG_READ_FAILURE";
    exports2[1595] = "ER_SLAVE_RELAY_LOG_WRITE_FAILURE";
    exports2[1596] = "ER_SLAVE_CREATE_EVENT_FAILURE";
    exports2[1597] = "ER_SLAVE_MASTER_COM_FAILURE";
    exports2[1598] = "ER_BINLOG_LOGGING_IMPOSSIBLE";
    exports2[1599] = "ER_VIEW_NO_CREATION_CTX";
    exports2[1600] = "ER_VIEW_INVALID_CREATION_CTX";
    exports2[1601] = "ER_SR_INVALID_CREATION_CTX";
    exports2[1602] = "ER_TRG_CORRUPTED_FILE";
    exports2[1603] = "ER_TRG_NO_CREATION_CTX";
    exports2[1604] = "ER_TRG_INVALID_CREATION_CTX";
    exports2[1605] = "ER_EVENT_INVALID_CREATION_CTX";
    exports2[1606] = "ER_TRG_CANT_OPEN_TABLE";
    exports2[1607] = "ER_CANT_CREATE_SROUTINE";
    exports2[1608] = "ER_NEVER_USED";
    exports2[1609] = "ER_NO_FORMAT_DESCRIPTION_EVENT_BEFORE_BINLOG_STATEMENT";
    exports2[1610] = "ER_SLAVE_CORRUPT_EVENT";
    exports2[1611] = "ER_LOAD_DATA_INVALID_COLUMN";
    exports2[1612] = "ER_LOG_PURGE_NO_FILE";
    exports2[1613] = "ER_XA_RBTIMEOUT";
    exports2[1614] = "ER_XA_RBDEADLOCK";
    exports2[1615] = "ER_NEED_REPREPARE";
    exports2[1616] = "ER_DELAYED_NOT_SUPPORTED";
    exports2[1617] = "WARN_NO_MASTER_INFO";
    exports2[1618] = "WARN_OPTION_IGNORED";
    exports2[1619] = "ER_PLUGIN_DELETE_BUILTIN";
    exports2[1620] = "WARN_PLUGIN_BUSY";
    exports2[1621] = "ER_VARIABLE_IS_READONLY";
    exports2[1622] = "ER_WARN_ENGINE_TRANSACTION_ROLLBACK";
    exports2[1623] = "ER_SLAVE_HEARTBEAT_FAILURE";
    exports2[1624] = "ER_SLAVE_HEARTBEAT_VALUE_OUT_OF_RANGE";
    exports2[1625] = "ER_NDB_REPLICATION_SCHEMA_ERROR";
    exports2[1626] = "ER_CONFLICT_FN_PARSE_ERROR";
    exports2[1627] = "ER_EXCEPTIONS_WRITE_ERROR";
    exports2[1628] = "ER_TOO_LONG_TABLE_COMMENT";
    exports2[1629] = "ER_TOO_LONG_FIELD_COMMENT";
    exports2[1630] = "ER_FUNC_INEXISTENT_NAME_COLLISION";
    exports2[1631] = "ER_DATABASE_NAME";
    exports2[1632] = "ER_TABLE_NAME";
    exports2[1633] = "ER_PARTITION_NAME";
    exports2[1634] = "ER_SUBPARTITION_NAME";
    exports2[1635] = "ER_TEMPORARY_NAME";
    exports2[1636] = "ER_RENAMED_NAME";
    exports2[1637] = "ER_TOO_MANY_CONCURRENT_TRXS";
    exports2[1638] = "WARN_NON_ASCII_SEPARATOR_NOT_IMPLEMENTED";
    exports2[1639] = "ER_DEBUG_SYNC_TIMEOUT";
    exports2[1640] = "ER_DEBUG_SYNC_HIT_LIMIT";
    exports2[1641] = "ER_DUP_SIGNAL_SET";
    exports2[1642] = "ER_SIGNAL_WARN";
    exports2[1643] = "ER_SIGNAL_NOT_FOUND";
    exports2[1644] = "ER_SIGNAL_EXCEPTION";
    exports2[1645] = "ER_RESIGNAL_WITHOUT_ACTIVE_HANDLER";
    exports2[1646] = "ER_SIGNAL_BAD_CONDITION_TYPE";
    exports2[1647] = "WARN_COND_ITEM_TRUNCATED";
    exports2[1648] = "ER_COND_ITEM_TOO_LONG";
    exports2[1649] = "ER_UNKNOWN_LOCALE";
    exports2[1650] = "ER_SLAVE_IGNORE_SERVER_IDS";
    exports2[1651] = "ER_QUERY_CACHE_DISABLED";
    exports2[1652] = "ER_SAME_NAME_PARTITION_FIELD";
    exports2[1653] = "ER_PARTITION_COLUMN_LIST_ERROR";
    exports2[1654] = "ER_WRONG_TYPE_COLUMN_VALUE_ERROR";
    exports2[1655] = "ER_TOO_MANY_PARTITION_FUNC_FIELDS_ERROR";
    exports2[1656] = "ER_MAXVALUE_IN_VALUES_IN";
    exports2[1657] = "ER_TOO_MANY_VALUES_ERROR";
    exports2[1658] = "ER_ROW_SINGLE_PARTITION_FIELD_ERROR";
    exports2[1659] = "ER_FIELD_TYPE_NOT_ALLOWED_AS_PARTITION_FIELD";
    exports2[1660] = "ER_PARTITION_FIELDS_TOO_LONG";
    exports2[1661] = "ER_BINLOG_ROW_ENGINE_AND_STMT_ENGINE";
    exports2[1662] = "ER_BINLOG_ROW_MODE_AND_STMT_ENGINE";
    exports2[1663] = "ER_BINLOG_UNSAFE_AND_STMT_ENGINE";
    exports2[1664] = "ER_BINLOG_ROW_INJECTION_AND_STMT_ENGINE";
    exports2[1665] = "ER_BINLOG_STMT_MODE_AND_ROW_ENGINE";
    exports2[1666] = "ER_BINLOG_ROW_INJECTION_AND_STMT_MODE";
    exports2[1667] = "ER_BINLOG_MULTIPLE_ENGINES_AND_SELF_LOGGING_ENGINE";
    exports2[1668] = "ER_BINLOG_UNSAFE_LIMIT";
    exports2[1669] = "ER_BINLOG_UNSAFE_INSERT_DELAYED";
    exports2[1670] = "ER_BINLOG_UNSAFE_SYSTEM_TABLE";
    exports2[1671] = "ER_BINLOG_UNSAFE_AUTOINC_COLUMNS";
    exports2[1672] = "ER_BINLOG_UNSAFE_UDF";
    exports2[1673] = "ER_BINLOG_UNSAFE_SYSTEM_VARIABLE";
    exports2[1674] = "ER_BINLOG_UNSAFE_SYSTEM_FUNCTION";
    exports2[1675] = "ER_BINLOG_UNSAFE_NONTRANS_AFTER_TRANS";
    exports2[1676] = "ER_MESSAGE_AND_STATEMENT";
    exports2[1677] = "ER_SLAVE_CONVERSION_FAILED";
    exports2[1678] = "ER_SLAVE_CANT_CREATE_CONVERSION";
    exports2[1679] = "ER_INSIDE_TRANSACTION_PREVENTS_SWITCH_BINLOG_FORMAT";
    exports2[1680] = "ER_PATH_LENGTH";
    exports2[1681] = "ER_WARN_DEPRECATED_SYNTAX_NO_REPLACEMENT";
    exports2[1682] = "ER_WRONG_NATIVE_TABLE_STRUCTURE";
    exports2[1683] = "ER_WRONG_PERFSCHEMA_USAGE";
    exports2[1684] = "ER_WARN_I_S_SKIPPED_TABLE";
    exports2[1685] = "ER_INSIDE_TRANSACTION_PREVENTS_SWITCH_BINLOG_DIRECT";
    exports2[1686] = "ER_STORED_FUNCTION_PREVENTS_SWITCH_BINLOG_DIRECT";
    exports2[1687] = "ER_SPATIAL_MUST_HAVE_GEOM_COL";
    exports2[1688] = "ER_TOO_LONG_INDEX_COMMENT";
    exports2[1689] = "ER_LOCK_ABORTED";
    exports2[1690] = "ER_DATA_OUT_OF_RANGE";
    exports2[1691] = "ER_WRONG_SPVAR_TYPE_IN_LIMIT";
    exports2[1692] = "ER_BINLOG_UNSAFE_MULTIPLE_ENGINES_AND_SELF_LOGGING_ENGINE";
    exports2[1693] = "ER_BINLOG_UNSAFE_MIXED_STATEMENT";
    exports2[1694] = "ER_INSIDE_TRANSACTION_PREVENTS_SWITCH_SQL_LOG_BIN";
    exports2[1695] = "ER_STORED_FUNCTION_PREVENTS_SWITCH_SQL_LOG_BIN";
    exports2[1696] = "ER_FAILED_READ_FROM_PAR_FILE";
    exports2[1697] = "ER_VALUES_IS_NOT_INT_TYPE_ERROR";
    exports2[1698] = "ER_ACCESS_DENIED_NO_PASSWORD_ERROR";
    exports2[1699] = "ER_SET_PASSWORD_AUTH_PLUGIN";
    exports2[1700] = "ER_GRANT_PLUGIN_USER_EXISTS";
    exports2[1701] = "ER_TRUNCATE_ILLEGAL_FK";
    exports2[1702] = "ER_PLUGIN_IS_PERMANENT";
    exports2[1703] = "ER_SLAVE_HEARTBEAT_VALUE_OUT_OF_RANGE_MIN";
    exports2[1704] = "ER_SLAVE_HEARTBEAT_VALUE_OUT_OF_RANGE_MAX";
    exports2[1705] = "ER_STMT_CACHE_FULL";
    exports2[1706] = "ER_MULTI_UPDATE_KEY_CONFLICT";
    exports2[1707] = "ER_TABLE_NEEDS_REBUILD";
    exports2[1708] = "WARN_OPTION_BELOW_LIMIT";
    exports2[1709] = "ER_INDEX_COLUMN_TOO_LONG";
    exports2[1710] = "ER_ERROR_IN_TRIGGER_BODY";
    exports2[1711] = "ER_ERROR_IN_UNKNOWN_TRIGGER_BODY";
    exports2[1712] = "ER_INDEX_CORRUPT";
    exports2[1713] = "ER_UNDO_RECORD_TOO_BIG";
    exports2[1714] = "ER_BINLOG_UNSAFE_INSERT_IGNORE_SELECT";
    exports2[1715] = "ER_BINLOG_UNSAFE_INSERT_SELECT_UPDATE";
    exports2[1716] = "ER_BINLOG_UNSAFE_REPLACE_SELECT";
    exports2[1717] = "ER_BINLOG_UNSAFE_CREATE_IGNORE_SELECT";
    exports2[1718] = "ER_BINLOG_UNSAFE_CREATE_REPLACE_SELECT";
    exports2[1719] = "ER_BINLOG_UNSAFE_UPDATE_IGNORE";
    exports2[1720] = "ER_PLUGIN_NO_UNINSTALL";
    exports2[1721] = "ER_PLUGIN_NO_INSTALL";
    exports2[1722] = "ER_BINLOG_UNSAFE_WRITE_AUTOINC_SELECT";
    exports2[1723] = "ER_BINLOG_UNSAFE_CREATE_SELECT_AUTOINC";
    exports2[1724] = "ER_BINLOG_UNSAFE_INSERT_TWO_KEYS";
    exports2[1725] = "ER_TABLE_IN_FK_CHECK";
    exports2[1726] = "ER_UNSUPPORTED_ENGINE";
    exports2[1727] = "ER_BINLOG_UNSAFE_AUTOINC_NOT_FIRST";
    exports2[1728] = "ER_CANNOT_LOAD_FROM_TABLE_V2";
    exports2[1729] = "ER_MASTER_DELAY_VALUE_OUT_OF_RANGE";
    exports2[1730] = "ER_ONLY_FD_AND_RBR_EVENTS_ALLOWED_IN_BINLOG_STATEMENT";
    exports2[1731] = "ER_PARTITION_EXCHANGE_DIFFERENT_OPTION";
    exports2[1732] = "ER_PARTITION_EXCHANGE_PART_TABLE";
    exports2[1733] = "ER_PARTITION_EXCHANGE_TEMP_TABLE";
    exports2[1734] = "ER_PARTITION_INSTEAD_OF_SUBPARTITION";
    exports2[1735] = "ER_UNKNOWN_PARTITION";
    exports2[1736] = "ER_TABLES_DIFFERENT_METADATA";
    exports2[1737] = "ER_ROW_DOES_NOT_MATCH_PARTITION";
    exports2[1738] = "ER_BINLOG_CACHE_SIZE_GREATER_THAN_MAX";
    exports2[1739] = "ER_WARN_INDEX_NOT_APPLICABLE";
    exports2[1740] = "ER_PARTITION_EXCHANGE_FOREIGN_KEY";
    exports2[1741] = "ER_NO_SUCH_KEY_VALUE";
    exports2[1742] = "ER_RPL_INFO_DATA_TOO_LONG";
    exports2[1743] = "ER_NETWORK_READ_EVENT_CHECKSUM_FAILURE";
    exports2[1744] = "ER_BINLOG_READ_EVENT_CHECKSUM_FAILURE";
    exports2[1745] = "ER_BINLOG_STMT_CACHE_SIZE_GREATER_THAN_MAX";
    exports2[1746] = "ER_CANT_UPDATE_TABLE_IN_CREATE_TABLE_SELECT";
    exports2[1747] = "ER_PARTITION_CLAUSE_ON_NONPARTITIONED";
    exports2[1748] = "ER_ROW_DOES_NOT_MATCH_GIVEN_PARTITION_SET";
    exports2[1749] = "ER_NO_SUCH_PARTITION";
    exports2[1750] = "ER_CHANGE_RPL_INFO_REPOSITORY_FAILURE";
    exports2[1751] = "ER_WARNING_NOT_COMPLETE_ROLLBACK_WITH_CREATED_TEMP_TABLE";
    exports2[1752] = "ER_WARNING_NOT_COMPLETE_ROLLBACK_WITH_DROPPED_TEMP_TABLE";
    exports2[1753] = "ER_MTS_FEATURE_IS_NOT_SUPPORTED";
    exports2[1754] = "ER_MTS_UPDATED_DBS_GREATER_MAX";
    exports2[1755] = "ER_MTS_CANT_PARALLEL";
    exports2[1756] = "ER_MTS_INCONSISTENT_DATA";
    exports2[1757] = "ER_FULLTEXT_NOT_SUPPORTED_WITH_PARTITIONING";
    exports2[1758] = "ER_DA_INVALID_CONDITION_NUMBER";
    exports2[1759] = "ER_INSECURE_PLAIN_TEXT";
    exports2[1760] = "ER_INSECURE_CHANGE_MASTER";
    exports2[1761] = "ER_FOREIGN_DUPLICATE_KEY_WITH_CHILD_INFO";
    exports2[1762] = "ER_FOREIGN_DUPLICATE_KEY_WITHOUT_CHILD_INFO";
    exports2[1763] = "ER_SQLTHREAD_WITH_SECURE_SLAVE";
    exports2[1764] = "ER_TABLE_HAS_NO_FT";
    exports2[1765] = "ER_VARIABLE_NOT_SETTABLE_IN_SF_OR_TRIGGER";
    exports2[1766] = "ER_VARIABLE_NOT_SETTABLE_IN_TRANSACTION";
    exports2[1767] = "ER_GTID_NEXT_IS_NOT_IN_GTID_NEXT_LIST";
    exports2[1768] = "ER_CANT_CHANGE_GTID_NEXT_IN_TRANSACTION";
    exports2[1769] = "ER_SET_STATEMENT_CANNOT_INVOKE_FUNCTION";
    exports2[1770] = "ER_GTID_NEXT_CANT_BE_AUTOMATIC_IF_GTID_NEXT_LIST_IS_NON_NULL";
    exports2[1771] = "ER_SKIPPING_LOGGED_TRANSACTION";
    exports2[1772] = "ER_MALFORMED_GTID_SET_SPECIFICATION";
    exports2[1773] = "ER_MALFORMED_GTID_SET_ENCODING";
    exports2[1774] = "ER_MALFORMED_GTID_SPECIFICATION";
    exports2[1775] = "ER_GNO_EXHAUSTED";
    exports2[1776] = "ER_BAD_SLAVE_AUTO_POSITION";
    exports2[1777] = "ER_AUTO_POSITION_REQUIRES_GTID_MODE_NOT_OFF";
    exports2[1778] = "ER_CANT_DO_IMPLICIT_COMMIT_IN_TRX_WHEN_GTID_NEXT_IS_SET";
    exports2[1779] = "ER_GTID_MODE_ON_REQUIRES_ENFORCE_GTID_CONSISTENCY_ON";
    exports2[1780] = "ER_GTID_MODE_REQUIRES_BINLOG";
    exports2[1781] = "ER_CANT_SET_GTID_NEXT_TO_GTID_WHEN_GTID_MODE_IS_OFF";
    exports2[1782] = "ER_CANT_SET_GTID_NEXT_TO_ANONYMOUS_WHEN_GTID_MODE_IS_ON";
    exports2[1783] = "ER_CANT_SET_GTID_NEXT_LIST_TO_NON_NULL_WHEN_GTID_MODE_IS_OFF";
    exports2[1784] = "ER_FOUND_GTID_EVENT_WHEN_GTID_MODE_IS_OFF";
    exports2[1785] = "ER_GTID_UNSAFE_NON_TRANSACTIONAL_TABLE";
    exports2[1786] = "ER_GTID_UNSAFE_CREATE_SELECT";
    exports2[1787] = "ER_GTID_UNSAFE_CREATE_DROP_TEMPORARY_TABLE_IN_TRANSACTION";
    exports2[1788] = "ER_GTID_MODE_CAN_ONLY_CHANGE_ONE_STEP_AT_A_TIME";
    exports2[1789] = "ER_MASTER_HAS_PURGED_REQUIRED_GTIDS";
    exports2[1790] = "ER_CANT_SET_GTID_NEXT_WHEN_OWNING_GTID";
    exports2[1791] = "ER_UNKNOWN_EXPLAIN_FORMAT";
    exports2[1792] = "ER_CANT_EXECUTE_IN_READ_ONLY_TRANSACTION";
    exports2[1793] = "ER_TOO_LONG_TABLE_PARTITION_COMMENT";
    exports2[1794] = "ER_SLAVE_CONFIGURATION";
    exports2[1795] = "ER_INNODB_FT_LIMIT";
    exports2[1796] = "ER_INNODB_NO_FT_TEMP_TABLE";
    exports2[1797] = "ER_INNODB_FT_WRONG_DOCID_COLUMN";
    exports2[1798] = "ER_INNODB_FT_WRONG_DOCID_INDEX";
    exports2[1799] = "ER_INNODB_ONLINE_LOG_TOO_BIG";
    exports2[1800] = "ER_UNKNOWN_ALTER_ALGORITHM";
    exports2[1801] = "ER_UNKNOWN_ALTER_LOCK";
    exports2[1802] = "ER_MTS_CHANGE_MASTER_CANT_RUN_WITH_GAPS";
    exports2[1803] = "ER_MTS_RECOVERY_FAILURE";
    exports2[1804] = "ER_MTS_RESET_WORKERS";
    exports2[1805] = "ER_COL_COUNT_DOESNT_MATCH_CORRUPTED_V2";
    exports2[1806] = "ER_SLAVE_SILENT_RETRY_TRANSACTION";
    exports2[1807] = "ER_DISCARD_FK_CHECKS_RUNNING";
    exports2[1808] = "ER_TABLE_SCHEMA_MISMATCH";
    exports2[1809] = "ER_TABLE_IN_SYSTEM_TABLESPACE";
    exports2[1810] = "ER_IO_READ_ERROR";
    exports2[1811] = "ER_IO_WRITE_ERROR";
    exports2[1812] = "ER_TABLESPACE_MISSING";
    exports2[1813] = "ER_TABLESPACE_EXISTS";
    exports2[1814] = "ER_TABLESPACE_DISCARDED";
    exports2[1815] = "ER_INTERNAL_ERROR";
    exports2[1816] = "ER_INNODB_IMPORT_ERROR";
    exports2[1817] = "ER_INNODB_INDEX_CORRUPT";
    exports2[1818] = "ER_INVALID_YEAR_COLUMN_LENGTH";
    exports2[1819] = "ER_NOT_VALID_PASSWORD";
    exports2[1820] = "ER_MUST_CHANGE_PASSWORD";
    exports2[1821] = "ER_FK_NO_INDEX_CHILD";
    exports2[1822] = "ER_FK_NO_INDEX_PARENT";
    exports2[1823] = "ER_FK_FAIL_ADD_SYSTEM";
    exports2[1824] = "ER_FK_CANNOT_OPEN_PARENT";
    exports2[1825] = "ER_FK_INCORRECT_OPTION";
    exports2[1826] = "ER_FK_DUP_NAME";
    exports2[1827] = "ER_PASSWORD_FORMAT";
    exports2[1828] = "ER_FK_COLUMN_CANNOT_DROP";
    exports2[1829] = "ER_FK_COLUMN_CANNOT_DROP_CHILD";
    exports2[1830] = "ER_FK_COLUMN_NOT_NULL";
    exports2[1831] = "ER_DUP_INDEX";
    exports2[1832] = "ER_FK_COLUMN_CANNOT_CHANGE";
    exports2[1833] = "ER_FK_COLUMN_CANNOT_CHANGE_CHILD";
    exports2[1834] = "ER_FK_CANNOT_DELETE_PARENT";
    exports2[1835] = "ER_MALFORMED_PACKET";
    exports2[1836] = "ER_READ_ONLY_MODE";
    exports2[1837] = "ER_GTID_NEXT_TYPE_UNDEFINED_GROUP";
    exports2[1838] = "ER_VARIABLE_NOT_SETTABLE_IN_SP";
    exports2[1839] = "ER_CANT_SET_GTID_PURGED_WHEN_GTID_MODE_IS_OFF";
    exports2[1840] = "ER_CANT_SET_GTID_PURGED_WHEN_GTID_EXECUTED_IS_NOT_EMPTY";
    exports2[1841] = "ER_CANT_SET_GTID_PURGED_WHEN_OWNED_GTIDS_IS_NOT_EMPTY";
    exports2[1842] = "ER_GTID_PURGED_WAS_CHANGED";
    exports2[1843] = "ER_GTID_EXECUTED_WAS_CHANGED";
    exports2[1844] = "ER_BINLOG_STMT_MODE_AND_NO_REPL_TABLES";
    exports2[1845] = "ER_ALTER_OPERATION_NOT_SUPPORTED";
    exports2[1846] = "ER_ALTER_OPERATION_NOT_SUPPORTED_REASON";
    exports2[1847] = "ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_COPY";
    exports2[1848] = "ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_PARTITION";
    exports2[1849] = "ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_FK_RENAME";
    exports2[1850] = "ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_COLUMN_TYPE";
    exports2[1851] = "ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_FK_CHECK";
    exports2[1852] = "ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_IGNORE";
    exports2[1853] = "ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_NOPK";
    exports2[1854] = "ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_AUTOINC";
    exports2[1855] = "ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_HIDDEN_FTS";
    exports2[1856] = "ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_CHANGE_FTS";
    exports2[1857] = "ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_FTS";
    exports2[1858] = "ER_SQL_SLAVE_SKIP_COUNTER_NOT_SETTABLE_IN_GTID_MODE";
    exports2[1859] = "ER_DUP_UNKNOWN_IN_INDEX";
    exports2[1860] = "ER_IDENT_CAUSES_TOO_LONG_PATH";
    exports2[1861] = "ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_NOT_NULL";
    exports2[1862] = "ER_MUST_CHANGE_PASSWORD_LOGIN";
    exports2[1863] = "ER_ROW_IN_WRONG_PARTITION";
    exports2[1864] = "ER_MTS_EVENT_BIGGER_PENDING_JOBS_SIZE_MAX";
    exports2[1865] = "ER_INNODB_NO_FT_USES_PARSER";
    exports2[1866] = "ER_BINLOG_LOGICAL_CORRUPTION";
    exports2[1867] = "ER_WARN_PURGE_LOG_IN_USE";
    exports2[1868] = "ER_WARN_PURGE_LOG_IS_ACTIVE";
    exports2[1869] = "ER_AUTO_INCREMENT_CONFLICT";
    exports2[1870] = "WARN_ON_BLOCKHOLE_IN_RBR";
    exports2[1871] = "ER_SLAVE_MI_INIT_REPOSITORY";
    exports2[1872] = "ER_SLAVE_RLI_INIT_REPOSITORY";
    exports2[1873] = "ER_ACCESS_DENIED_CHANGE_USER_ERROR";
    exports2[1874] = "ER_INNODB_READ_ONLY";
    exports2[1875] = "ER_STOP_SLAVE_SQL_THREAD_TIMEOUT";
    exports2[1876] = "ER_STOP_SLAVE_IO_THREAD_TIMEOUT";
    exports2[1877] = "ER_TABLE_CORRUPT";
    exports2[1878] = "ER_TEMP_FILE_WRITE_FAILURE";
    exports2[1879] = "ER_INNODB_FT_AUX_NOT_HEX_ID";
    exports2[1880] = "ER_OLD_TEMPORALS_UPGRADED";
    exports2[1881] = "ER_INNODB_FORCED_RECOVERY";
    exports2[1882] = "ER_AES_INVALID_IV";
    exports2[1883] = "ER_PLUGIN_CANNOT_BE_UNINSTALLED";
    exports2[1884] = "ER_GTID_UNSAFE_BINLOG_SPLITTABLE_STATEMENT_AND_GTID_GROUP";
    exports2[1885] = "ER_SLAVE_HAS_MORE_GTIDS_THAN_MASTER";
    exports2[1886] = "ER_MISSING_KEY";
    exports2[1887] = "WARN_NAMED_PIPE_ACCESS_EVERYONE";
    exports2[1888] = "ER_FOUND_MISSING_GTIDS";
    exports2[3e3] = "ER_FILE_CORRUPT";
    exports2[3001] = "ER_ERROR_ON_MASTER";
    exports2[3002] = "ER_INCONSISTENT_ERROR";
    exports2[3003] = "ER_STORAGE_ENGINE_NOT_LOADED";
    exports2[3004] = "ER_GET_STACKED_DA_WITHOUT_ACTIVE_HANDLER";
    exports2[3005] = "ER_WARN_LEGACY_SYNTAX_CONVERTED";
    exports2[3006] = "ER_BINLOG_UNSAFE_FULLTEXT_PLUGIN";
    exports2[3007] = "ER_CANNOT_DISCARD_TEMPORARY_TABLE";
    exports2[3008] = "ER_FK_DEPTH_EXCEEDED";
    exports2[3009] = "ER_COL_COUNT_DOESNT_MATCH_PLEASE_UPDATE_V2";
    exports2[3010] = "ER_WARN_TRIGGER_DOESNT_HAVE_CREATED";
    exports2[3011] = "ER_REFERENCED_TRG_DOES_NOT_EXIST";
    exports2[3012] = "ER_EXPLAIN_NOT_SUPPORTED";
    exports2[3013] = "ER_INVALID_FIELD_SIZE";
    exports2[3014] = "ER_MISSING_HA_CREATE_OPTION";
    exports2[3015] = "ER_ENGINE_OUT_OF_MEMORY";
    exports2[3016] = "ER_PASSWORD_EXPIRE_ANONYMOUS_USER";
    exports2[3017] = "ER_SLAVE_SQL_THREAD_MUST_STOP";
    exports2[3018] = "ER_NO_FT_MATERIALIZED_SUBQUERY";
    exports2[3019] = "ER_INNODB_UNDO_LOG_FULL";
    exports2[3020] = "ER_INVALID_ARGUMENT_FOR_LOGARITHM";
    exports2[3021] = "ER_SLAVE_CHANNEL_IO_THREAD_MUST_STOP";
    exports2[3022] = "ER_WARN_OPEN_TEMP_TABLES_MUST_BE_ZERO";
    exports2[3023] = "ER_WARN_ONLY_MASTER_LOG_FILE_NO_POS";
    exports2[3024] = "ER_QUERY_TIMEOUT";
    exports2[3025] = "ER_NON_RO_SELECT_DISABLE_TIMER";
    exports2[3026] = "ER_DUP_LIST_ENTRY";
    exports2[3027] = "ER_SQL_MODE_NO_EFFECT";
    exports2[3028] = "ER_AGGREGATE_ORDER_FOR_UNION";
    exports2[3029] = "ER_AGGREGATE_ORDER_NON_AGG_QUERY";
    exports2[3030] = "ER_SLAVE_WORKER_STOPPED_PREVIOUS_THD_ERROR";
    exports2[3031] = "ER_DONT_SUPPORT_SLAVE_PRESERVE_COMMIT_ORDER";
    exports2[3032] = "ER_SERVER_OFFLINE_MODE";
    exports2[3033] = "ER_GIS_DIFFERENT_SRIDS";
    exports2[3034] = "ER_GIS_UNSUPPORTED_ARGUMENT";
    exports2[3035] = "ER_GIS_UNKNOWN_ERROR";
    exports2[3036] = "ER_GIS_UNKNOWN_EXCEPTION";
    exports2[3037] = "ER_GIS_INVALID_DATA";
    exports2[3038] = "ER_BOOST_GEOMETRY_EMPTY_INPUT_EXCEPTION";
    exports2[3039] = "ER_BOOST_GEOMETRY_CENTROID_EXCEPTION";
    exports2[3040] = "ER_BOOST_GEOMETRY_OVERLAY_INVALID_INPUT_EXCEPTION";
    exports2[3041] = "ER_BOOST_GEOMETRY_TURN_INFO_EXCEPTION";
    exports2[3042] = "ER_BOOST_GEOMETRY_SELF_INTERSECTION_POINT_EXCEPTION";
    exports2[3043] = "ER_BOOST_GEOMETRY_UNKNOWN_EXCEPTION";
    exports2[3044] = "ER_STD_BAD_ALLOC_ERROR";
    exports2[3045] = "ER_STD_DOMAIN_ERROR";
    exports2[3046] = "ER_STD_LENGTH_ERROR";
    exports2[3047] = "ER_STD_INVALID_ARGUMENT";
    exports2[3048] = "ER_STD_OUT_OF_RANGE_ERROR";
    exports2[3049] = "ER_STD_OVERFLOW_ERROR";
    exports2[3050] = "ER_STD_RANGE_ERROR";
    exports2[3051] = "ER_STD_UNDERFLOW_ERROR";
    exports2[3052] = "ER_STD_LOGIC_ERROR";
    exports2[3053] = "ER_STD_RUNTIME_ERROR";
    exports2[3054] = "ER_STD_UNKNOWN_EXCEPTION";
    exports2[3055] = "ER_GIS_DATA_WRONG_ENDIANESS";
    exports2[3056] = "ER_CHANGE_MASTER_PASSWORD_LENGTH";
    exports2[3057] = "ER_USER_LOCK_WRONG_NAME";
    exports2[3058] = "ER_USER_LOCK_DEADLOCK";
    exports2[3059] = "ER_REPLACE_INACCESSIBLE_ROWS";
    exports2[3060] = "ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_GIS";
    exports2[3061] = "ER_ILLEGAL_USER_VAR";
    exports2[3062] = "ER_GTID_MODE_OFF";
    exports2[3063] = "ER_UNSUPPORTED_BY_REPLICATION_THREAD";
    exports2[3064] = "ER_INCORRECT_TYPE";
    exports2[3065] = "ER_FIELD_IN_ORDER_NOT_SELECT";
    exports2[3066] = "ER_AGGREGATE_IN_ORDER_NOT_SELECT";
    exports2[3067] = "ER_INVALID_RPL_WILD_TABLE_FILTER_PATTERN";
    exports2[3068] = "ER_NET_OK_PACKET_TOO_LARGE";
    exports2[3069] = "ER_INVALID_JSON_DATA";
    exports2[3070] = "ER_INVALID_GEOJSON_MISSING_MEMBER";
    exports2[3071] = "ER_INVALID_GEOJSON_WRONG_TYPE";
    exports2[3072] = "ER_INVALID_GEOJSON_UNSPECIFIED";
    exports2[3073] = "ER_DIMENSION_UNSUPPORTED";
    exports2[3074] = "ER_SLAVE_CHANNEL_DOES_NOT_EXIST";
    exports2[3075] = "ER_SLAVE_MULTIPLE_CHANNELS_HOST_PORT";
    exports2[3076] = "ER_SLAVE_CHANNEL_NAME_INVALID_OR_TOO_LONG";
    exports2[3077] = "ER_SLAVE_NEW_CHANNEL_WRONG_REPOSITORY";
    exports2[3078] = "ER_SLAVE_CHANNEL_DELETE";
    exports2[3079] = "ER_SLAVE_MULTIPLE_CHANNELS_CMD";
    exports2[3080] = "ER_SLAVE_MAX_CHANNELS_EXCEEDED";
    exports2[3081] = "ER_SLAVE_CHANNEL_MUST_STOP";
    exports2[3082] = "ER_SLAVE_CHANNEL_NOT_RUNNING";
    exports2[3083] = "ER_SLAVE_CHANNEL_WAS_RUNNING";
    exports2[3084] = "ER_SLAVE_CHANNEL_WAS_NOT_RUNNING";
    exports2[3085] = "ER_SLAVE_CHANNEL_SQL_THREAD_MUST_STOP";
    exports2[3086] = "ER_SLAVE_CHANNEL_SQL_SKIP_COUNTER";
    exports2[3087] = "ER_WRONG_FIELD_WITH_GROUP_V2";
    exports2[3088] = "ER_MIX_OF_GROUP_FUNC_AND_FIELDS_V2";
    exports2[3089] = "ER_WARN_DEPRECATED_SYSVAR_UPDATE";
    exports2[3090] = "ER_WARN_DEPRECATED_SQLMODE";
    exports2[3091] = "ER_CANNOT_LOG_PARTIAL_DROP_DATABASE_WITH_GTID";
    exports2[3092] = "ER_GROUP_REPLICATION_CONFIGURATION";
    exports2[3093] = "ER_GROUP_REPLICATION_RUNNING";
    exports2[3094] = "ER_GROUP_REPLICATION_APPLIER_INIT_ERROR";
    exports2[3095] = "ER_GROUP_REPLICATION_STOP_APPLIER_THREAD_TIMEOUT";
    exports2[3096] = "ER_GROUP_REPLICATION_COMMUNICATION_LAYER_SESSION_ERROR";
    exports2[3097] = "ER_GROUP_REPLICATION_COMMUNICATION_LAYER_JOIN_ERROR";
    exports2[3098] = "ER_BEFORE_DML_VALIDATION_ERROR";
    exports2[3099] = "ER_PREVENTS_VARIABLE_WITHOUT_RBR";
    exports2[3100] = "ER_RUN_HOOK_ERROR";
    exports2[3101] = "ER_TRANSACTION_ROLLBACK_DURING_COMMIT";
    exports2[3102] = "ER_GENERATED_COLUMN_FUNCTION_IS_NOT_ALLOWED";
    exports2[3103] = "ER_UNSUPPORTED_ALTER_INPLACE_ON_VIRTUAL_COLUMN";
    exports2[3104] = "ER_WRONG_FK_OPTION_FOR_GENERATED_COLUMN";
    exports2[3105] = "ER_NON_DEFAULT_VALUE_FOR_GENERATED_COLUMN";
    exports2[3106] = "ER_UNSUPPORTED_ACTION_ON_GENERATED_COLUMN";
    exports2[3107] = "ER_GENERATED_COLUMN_NON_PRIOR";
    exports2[3108] = "ER_DEPENDENT_BY_GENERATED_COLUMN";
    exports2[3109] = "ER_GENERATED_COLUMN_REF_AUTO_INC";
    exports2[3110] = "ER_FEATURE_NOT_AVAILABLE";
    exports2[3111] = "ER_CANT_SET_GTID_MODE";
    exports2[3112] = "ER_CANT_USE_AUTO_POSITION_WITH_GTID_MODE_OFF";
    exports2[3113] = "ER_CANT_REPLICATE_ANONYMOUS_WITH_AUTO_POSITION";
    exports2[3114] = "ER_CANT_REPLICATE_ANONYMOUS_WITH_GTID_MODE_ON";
    exports2[3115] = "ER_CANT_REPLICATE_GTID_WITH_GTID_MODE_OFF";
    exports2[3116] = "ER_CANT_SET_ENFORCE_GTID_CONSISTENCY_ON_WITH_ONGOING_GTID_VIOLATING_TRANSACTIONS";
    exports2[3117] = "ER_SET_ENFORCE_GTID_CONSISTENCY_WARN_WITH_ONGOING_GTID_VIOLATING_TRANSACTIONS";
    exports2[3118] = "ER_ACCOUNT_HAS_BEEN_LOCKED";
    exports2[3119] = "ER_WRONG_TABLESPACE_NAME";
    exports2[3120] = "ER_TABLESPACE_IS_NOT_EMPTY";
    exports2[3121] = "ER_WRONG_FILE_NAME";
    exports2[3122] = "ER_BOOST_GEOMETRY_INCONSISTENT_TURNS_EXCEPTION";
    exports2[3123] = "ER_WARN_OPTIMIZER_HINT_SYNTAX_ERROR";
    exports2[3124] = "ER_WARN_BAD_MAX_EXECUTION_TIME";
    exports2[3125] = "ER_WARN_UNSUPPORTED_MAX_EXECUTION_TIME";
    exports2[3126] = "ER_WARN_CONFLICTING_HINT";
    exports2[3127] = "ER_WARN_UNKNOWN_QB_NAME";
    exports2[3128] = "ER_UNRESOLVED_HINT_NAME";
    exports2[3129] = "ER_WARN_ON_MODIFYING_GTID_EXECUTED_TABLE";
    exports2[3130] = "ER_PLUGGABLE_PROTOCOL_COMMAND_NOT_SUPPORTED";
    exports2[3131] = "ER_LOCKING_SERVICE_WRONG_NAME";
    exports2[3132] = "ER_LOCKING_SERVICE_DEADLOCK";
    exports2[3133] = "ER_LOCKING_SERVICE_TIMEOUT";
    exports2[3134] = "ER_GIS_MAX_POINTS_IN_GEOMETRY_OVERFLOWED";
    exports2[3135] = "ER_SQL_MODE_MERGED";
    exports2[3136] = "ER_VTOKEN_PLUGIN_TOKEN_MISMATCH";
    exports2[3137] = "ER_VTOKEN_PLUGIN_TOKEN_NOT_FOUND";
    exports2[3138] = "ER_CANT_SET_VARIABLE_WHEN_OWNING_GTID";
    exports2[3139] = "ER_SLAVE_CHANNEL_OPERATION_NOT_ALLOWED";
    exports2[3140] = "ER_INVALID_JSON_TEXT";
    exports2[3141] = "ER_INVALID_JSON_TEXT_IN_PARAM";
    exports2[3142] = "ER_INVALID_JSON_BINARY_DATA";
    exports2[3143] = "ER_INVALID_JSON_PATH";
    exports2[3144] = "ER_INVALID_JSON_CHARSET";
    exports2[3145] = "ER_INVALID_JSON_CHARSET_IN_FUNCTION";
    exports2[3146] = "ER_INVALID_TYPE_FOR_JSON";
    exports2[3147] = "ER_INVALID_CAST_TO_JSON";
    exports2[3148] = "ER_INVALID_JSON_PATH_CHARSET";
    exports2[3149] = "ER_INVALID_JSON_PATH_WILDCARD";
    exports2[3150] = "ER_JSON_VALUE_TOO_BIG";
    exports2[3151] = "ER_JSON_KEY_TOO_BIG";
    exports2[3152] = "ER_JSON_USED_AS_KEY";
    exports2[3153] = "ER_JSON_VACUOUS_PATH";
    exports2[3154] = "ER_JSON_BAD_ONE_OR_ALL_ARG";
    exports2[3155] = "ER_NUMERIC_JSON_VALUE_OUT_OF_RANGE";
    exports2[3156] = "ER_INVALID_JSON_VALUE_FOR_CAST";
    exports2[3157] = "ER_JSON_DOCUMENT_TOO_DEEP";
    exports2[3158] = "ER_JSON_DOCUMENT_NULL_KEY";
    exports2[3159] = "ER_SECURE_TRANSPORT_REQUIRED";
    exports2[3160] = "ER_NO_SECURE_TRANSPORTS_CONFIGURED";
    exports2[3161] = "ER_DISABLED_STORAGE_ENGINE";
    exports2[3162] = "ER_USER_DOES_NOT_EXIST";
    exports2[3163] = "ER_USER_ALREADY_EXISTS";
    exports2[3164] = "ER_AUDIT_API_ABORT";
    exports2[3165] = "ER_INVALID_JSON_PATH_ARRAY_CELL";
    exports2[3166] = "ER_BUFPOOL_RESIZE_INPROGRESS";
    exports2[3167] = "ER_FEATURE_DISABLED_SEE_DOC";
    exports2[3168] = "ER_SERVER_ISNT_AVAILABLE";
    exports2[3169] = "ER_SESSION_WAS_KILLED";
    exports2[3170] = "ER_CAPACITY_EXCEEDED";
    exports2[3171] = "ER_CAPACITY_EXCEEDED_IN_RANGE_OPTIMIZER";
    exports2[3172] = "ER_TABLE_NEEDS_UPG_PART";
    exports2[3173] = "ER_CANT_WAIT_FOR_EXECUTED_GTID_SET_WHILE_OWNING_A_GTID";
    exports2[3174] = "ER_CANNOT_ADD_FOREIGN_BASE_COL_VIRTUAL";
    exports2[3175] = "ER_CANNOT_CREATE_VIRTUAL_INDEX_CONSTRAINT";
    exports2[3176] = "ER_ERROR_ON_MODIFYING_GTID_EXECUTED_TABLE";
    exports2[3177] = "ER_LOCK_REFUSED_BY_ENGINE";
    exports2[3178] = "ER_UNSUPPORTED_ALTER_ONLINE_ON_VIRTUAL_COLUMN";
    exports2[3179] = "ER_MASTER_KEY_ROTATION_NOT_SUPPORTED_BY_SE";
    exports2[3180] = "ER_MASTER_KEY_ROTATION_ERROR_BY_SE";
    exports2[3181] = "ER_MASTER_KEY_ROTATION_BINLOG_FAILED";
    exports2[3182] = "ER_MASTER_KEY_ROTATION_SE_UNAVAILABLE";
    exports2[3183] = "ER_TABLESPACE_CANNOT_ENCRYPT";
    exports2[3184] = "ER_INVALID_ENCRYPTION_OPTION";
    exports2[3185] = "ER_CANNOT_FIND_KEY_IN_KEYRING";
    exports2[3186] = "ER_CAPACITY_EXCEEDED_IN_PARSER";
    exports2[3187] = "ER_UNSUPPORTED_ALTER_ENCRYPTION_INPLACE";
    exports2[3188] = "ER_KEYRING_UDF_KEYRING_SERVICE_ERROR";
    exports2[3189] = "ER_USER_COLUMN_OLD_LENGTH";
    exports2[3190] = "ER_CANT_RESET_MASTER";
    exports2[3191] = "ER_GROUP_REPLICATION_MAX_GROUP_SIZE";
    exports2[3192] = "ER_CANNOT_ADD_FOREIGN_BASE_COL_STORED";
    exports2[3193] = "ER_TABLE_REFERENCED";
    exports2[3194] = "ER_PARTITION_ENGINE_DEPRECATED_FOR_TABLE";
    exports2[3195] = "ER_WARN_USING_GEOMFROMWKB_TO_SET_SRID_ZERO";
    exports2[3196] = "ER_WARN_USING_GEOMFROMWKB_TO_SET_SRID";
    exports2[3197] = "ER_XA_RETRY";
    exports2[3198] = "ER_KEYRING_AWS_UDF_AWS_KMS_ERROR";
    exports2[3199] = "ER_BINLOG_UNSAFE_XA";
    exports2[3200] = "ER_UDF_ERROR";
    exports2[3201] = "ER_KEYRING_MIGRATION_FAILURE";
    exports2[3202] = "ER_KEYRING_ACCESS_DENIED_ERROR";
    exports2[3203] = "ER_KEYRING_MIGRATION_STATUS";
    exports2[3204] = "ER_PLUGIN_FAILED_TO_OPEN_TABLES";
    exports2[3205] = "ER_PLUGIN_FAILED_TO_OPEN_TABLE";
    exports2[3206] = "ER_AUDIT_LOG_NO_KEYRING_PLUGIN_INSTALLED";
    exports2[3207] = "ER_AUDIT_LOG_ENCRYPTION_PASSWORD_HAS_NOT_BEEN_SET";
    exports2[3208] = "ER_AUDIT_LOG_COULD_NOT_CREATE_AES_KEY";
    exports2[3209] = "ER_AUDIT_LOG_ENCRYPTION_PASSWORD_CANNOT_BE_FETCHED";
    exports2[3210] = "ER_AUDIT_LOG_JSON_FILTERING_NOT_ENABLED";
    exports2[3211] = "ER_AUDIT_LOG_UDF_INSUFFICIENT_PRIVILEGE";
    exports2[3212] = "ER_AUDIT_LOG_SUPER_PRIVILEGE_REQUIRED";
    exports2[3213] = "ER_COULD_NOT_REINITIALIZE_AUDIT_LOG_FILTERS";
    exports2[3214] = "ER_AUDIT_LOG_UDF_INVALID_ARGUMENT_TYPE";
    exports2[3215] = "ER_AUDIT_LOG_UDF_INVALID_ARGUMENT_COUNT";
    exports2[3216] = "ER_AUDIT_LOG_HAS_NOT_BEEN_INSTALLED";
    exports2[3217] = "ER_AUDIT_LOG_UDF_READ_INVALID_MAX_ARRAY_LENGTH_ARG_TYPE";
    exports2[3218] = "ER_AUDIT_LOG_UDF_READ_INVALID_MAX_ARRAY_LENGTH_ARG_VALUE";
    exports2[3219] = "ER_AUDIT_LOG_JSON_FILTER_PARSING_ERROR";
    exports2[3220] = "ER_AUDIT_LOG_JSON_FILTER_NAME_CANNOT_BE_EMPTY";
    exports2[3221] = "ER_AUDIT_LOG_JSON_USER_NAME_CANNOT_BE_EMPTY";
    exports2[3222] = "ER_AUDIT_LOG_JSON_FILTER_DOES_NOT_EXISTS";
    exports2[3223] = "ER_AUDIT_LOG_USER_FIRST_CHARACTER_MUST_BE_ALPHANUMERIC";
    exports2[3224] = "ER_AUDIT_LOG_USER_NAME_INVALID_CHARACTER";
    exports2[3225] = "ER_AUDIT_LOG_HOST_NAME_INVALID_CHARACTER";
    exports2[3226] = "WARN_DEPRECATED_MAXDB_SQL_MODE_FOR_TIMESTAMP";
    exports2[3227] = "ER_XA_REPLICATION_FILTERS";
    exports2[3228] = "ER_CANT_OPEN_ERROR_LOG";
    exports2[3229] = "ER_GROUPING_ON_TIMESTAMP_IN_DST";
    exports2[3230] = "ER_CANT_START_SERVER_NAMED_PIPE";
  }
});

// browser-external:timers
var require_timers = __commonJS({
  "browser-external:timers"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "timers" has been externalized for browser compatibility. Cannot access "timers.${key}" in client code.`);
        }
      }
    }));
  }
});

// node_modules/mysql/lib/protocol/Timer.js
var require_Timer = __commonJS({
  "node_modules/mysql/lib/protocol/Timer.js"(exports2, module2) {
    var Timers = require_timers();
    module2.exports = Timer;
    function Timer(object) {
      this._object = object;
      this._timeout = null;
    }
    Timer.prototype.active = function active() {
      if (this._timeout) {
        if (this._timeout.refresh) {
          this._timeout.refresh();
        } else {
          Timers.active(this._timeout);
        }
      }
    };
    Timer.prototype.start = function start(msecs) {
      this.stop();
      this._timeout = Timers.setTimeout(this._onTimeout.bind(this), msecs);
    };
    Timer.prototype.stop = function stop() {
      if (this._timeout) {
        Timers.clearTimeout(this._timeout);
        this._timeout = null;
      }
    };
    Timer.prototype._onTimeout = function _onTimeout() {
      return this._object._onTimeout();
    };
  }
});

// node_modules/mysql/lib/protocol/sequences/Sequence.js
var require_Sequence = __commonJS({
  "node_modules/mysql/lib/protocol/sequences/Sequence.js"(exports2, module2) {
    var Util = require_util2();
    var EventEmitter = require_events().EventEmitter;
    var Packets = require_packets();
    var ErrorConstants = require_errors();
    var Timer = require_Timer();
    var listenerCount = EventEmitter.listenerCount || function(emitter, type) {
      return emitter.listeners(type).length;
    };
    var LONG_STACK_DELIMITER = "\n    --------------------\n";
    module2.exports = Sequence;
    Util.inherits(Sequence, EventEmitter);
    function Sequence(options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      EventEmitter.call(this);
      options = options || {};
      this._callback = callback;
      this._callSite = null;
      this._ended = false;
      this._timeout = options.timeout;
      this._timer = new Timer(this);
    }
    Sequence.determinePacket = function(byte) {
      switch (byte) {
        case 0:
          return Packets.OkPacket;
        case 254:
          return Packets.EofPacket;
        case 255:
          return Packets.ErrorPacket;
        default:
          return void 0;
      }
    };
    Sequence.prototype.hasErrorHandler = function() {
      return Boolean(this._callback) || listenerCount(this, "error") > 1;
    };
    Sequence.prototype._packetToError = function(packet) {
      var code = ErrorConstants[packet.errno] || "UNKNOWN_CODE_PLEASE_REPORT";
      var err = new Error(code + ": " + packet.message);
      err.code = code;
      err.errno = packet.errno;
      err.sqlMessage = packet.message;
      err.sqlState = packet.sqlState;
      return err;
    };
    Sequence.prototype.end = function(err) {
      if (this._ended) {
        return;
      }
      this._ended = true;
      if (err) {
        this._addLongStackTrace(err);
      }
      this._callSite = null;
      try {
        if (err) {
          this.emit("error", err);
        }
      } finally {
        try {
          if (this._callback) {
            this._callback.apply(this, arguments);
          }
        } finally {
          this.emit("end");
        }
      }
    };
    Sequence.prototype["OkPacket"] = function(packet) {
      this.end(null, packet);
    };
    Sequence.prototype["ErrorPacket"] = function(packet) {
      this.end(this._packetToError(packet));
    };
    Sequence.prototype.start = function() {
    };
    Sequence.prototype._addLongStackTrace = function _addLongStackTrace(err) {
      var callSiteStack = this._callSite && this._callSite.stack;
      if (!callSiteStack || typeof callSiteStack !== "string") {
        return;
      }
      if (err.stack.indexOf(LONG_STACK_DELIMITER) !== -1) {
        return;
      }
      var index = callSiteStack.indexOf("\n");
      if (index !== -1) {
        err.stack += LONG_STACK_DELIMITER + callSiteStack.substr(index + 1);
      }
    };
    Sequence.prototype._onTimeout = function _onTimeout() {
      this.emit("timeout");
    };
  }
});

// node_modules/mysql/lib/protocol/Auth.js
var require_Auth = __commonJS({
  "node_modules/mysql/lib/protocol/Auth.js"(exports2) {
    var Buffer2 = require_safe_buffer().Buffer;
    var Crypto = require_crypto();
    var Auth = exports2;
    function auth(name, data, options) {
      options = options || {};
      switch (name) {
        case "mysql_native_password":
          return Auth.token(options.password, data.slice(0, 20));
        default:
          return void 0;
      }
    }
    Auth.auth = auth;
    function sha1(msg) {
      var hash = Crypto.createHash("sha1");
      hash.update(msg, "binary");
      return hash.digest("binary");
    }
    Auth.sha1 = sha1;
    function xor(a, b) {
      a = Buffer2.from(a, "binary");
      b = Buffer2.from(b, "binary");
      var result = Buffer2.allocUnsafe(a.length);
      for (var i = 0; i < a.length; i++) {
        result[i] = a[i] ^ b[i];
      }
      return result;
    }
    Auth.xor = xor;
    Auth.token = function(password, scramble) {
      if (!password) {
        return Buffer2.alloc(0);
      }
      var stage1 = sha1(Buffer2.from(password, "utf8").toString("binary"));
      var stage2 = sha1(stage1);
      var stage3 = sha1(scramble.toString("binary") + stage2);
      return xor(stage3, stage1);
    };
    Auth.hashPassword = function(password) {
      var nr = [20528, 22325];
      var add = 7;
      var nr2 = [4660, 22129];
      var result = Buffer2.alloc(8);
      if (typeof password === "string") {
        password = Buffer2.from(password);
      }
      for (var i = 0; i < password.length; i++) {
        var c = password[i];
        if (c === 32 || c === 9) {
          continue;
        }
        nr = this.xor32(nr, this.add32(this.mul32(this.add32(this.and32(nr, [0, 63]), [0, add]), [0, c]), this.shl32(nr, 8)));
        nr2 = this.add32(nr2, this.xor32(this.shl32(nr2, 8), nr));
        add += c;
      }
      this.int31Write(result, nr, 0);
      this.int31Write(result, nr2, 4);
      return result;
    };
    Auth.randomInit = function(seed1, seed2) {
      return {
        max_value: 1073741823,
        max_value_dbl: 1073741823,
        seed1: seed1 % 1073741823,
        seed2: seed2 % 1073741823
      };
    };
    Auth.myRnd = function(r) {
      r.seed1 = (r.seed1 * 3 + r.seed2) % r.max_value;
      r.seed2 = (r.seed1 + r.seed2 + 33) % r.max_value;
      return r.seed1 / r.max_value_dbl;
    };
    Auth.scramble323 = function(message, password) {
      if (!password) {
        return Buffer2.alloc(0);
      }
      var to = Buffer2.allocUnsafe(8);
      var hashPass = this.hashPassword(password);
      var hashMessage = this.hashPassword(message.slice(0, 8));
      var seed1 = this.int32Read(hashPass, 0) ^ this.int32Read(hashMessage, 0);
      var seed2 = this.int32Read(hashPass, 4) ^ this.int32Read(hashMessage, 4);
      var r = this.randomInit(seed1, seed2);
      for (var i = 0; i < 8; i++) {
        to[i] = Math.floor(this.myRnd(r) * 31) + 64;
      }
      var extra = Math.floor(this.myRnd(r) * 31);
      for (var i = 0; i < 8; i++) {
        to[i] ^= extra;
      }
      return to;
    };
    Auth.xor32 = function(a, b) {
      return [a[0] ^ b[0], a[1] ^ b[1]];
    };
    Auth.add32 = function(a, b) {
      var w1 = a[1] + b[1];
      var w2 = a[0] + b[0] + ((w1 & 4294901760) >> 16);
      return [w2 & 65535, w1 & 65535];
    };
    Auth.mul32 = function(a, b) {
      var w1 = a[1] * b[1];
      var w2 = (a[1] * b[1] >> 16 & 65535) + (a[0] * b[1] & 65535) + (a[1] * b[0] & 65535);
      return [w2 & 65535, w1 & 65535];
    };
    Auth.and32 = function(a, b) {
      return [a[0] & b[0], a[1] & b[1]];
    };
    Auth.shl32 = function(a, b) {
      var w1 = a[1] << b;
      var w2 = a[0] << b | (w1 & 4294901760) >> 16;
      return [w2 & 65535, w1 & 65535];
    };
    Auth.int31Write = function(buffer, number, offset) {
      buffer[offset] = number[0] >> 8 & 127;
      buffer[offset + 1] = number[0] & 255;
      buffer[offset + 2] = number[1] >> 8 & 255;
      buffer[offset + 3] = number[1] & 255;
    };
    Auth.int32Read = function(buffer, offset) {
      return (buffer[offset] << 24) + (buffer[offset + 1] << 16) + (buffer[offset + 2] << 8) + buffer[offset + 3];
    };
  }
});

// node_modules/mysql/lib/protocol/sequences/ChangeUser.js
var require_ChangeUser = __commonJS({
  "node_modules/mysql/lib/protocol/sequences/ChangeUser.js"(exports2, module2) {
    var Sequence = require_Sequence();
    var Util = require_util2();
    var Packets = require_packets();
    var Auth = require_Auth();
    module2.exports = ChangeUser;
    Util.inherits(ChangeUser, Sequence);
    function ChangeUser(options, callback) {
      Sequence.call(this, options, callback);
      this._user = options.user;
      this._password = options.password;
      this._database = options.database;
      this._charsetNumber = options.charsetNumber;
      this._currentConfig = options.currentConfig;
    }
    ChangeUser.prototype.determinePacket = function determinePacket(firstByte) {
      switch (firstByte) {
        case 254:
          return Packets.AuthSwitchRequestPacket;
        case 255:
          return Packets.ErrorPacket;
        default:
          return void 0;
      }
    };
    ChangeUser.prototype.start = function(handshakeInitializationPacket) {
      var scrambleBuff = handshakeInitializationPacket.scrambleBuff();
      scrambleBuff = Auth.token(this._password, scrambleBuff);
      var packet = new Packets.ComChangeUserPacket({
        user: this._user,
        scrambleBuff,
        database: this._database,
        charsetNumber: this._charsetNumber
      });
      this._currentConfig.user = this._user;
      this._currentConfig.password = this._password;
      this._currentConfig.database = this._database;
      this._currentConfig.charsetNumber = this._charsetNumber;
      this.emit("packet", packet);
    };
    ChangeUser.prototype["AuthSwitchRequestPacket"] = function(packet) {
      var name = packet.authMethodName;
      var data = Auth.auth(name, packet.authMethodData, {
        password: this._password
      });
      if (data !== void 0) {
        this.emit("packet", new Packets.AuthSwitchResponsePacket({
          data
        }));
      } else {
        var err = new Error("MySQL is requesting the " + name + " authentication method, which is not supported.");
        err.code = "UNSUPPORTED_AUTH_METHOD";
        err.fatal = true;
        this.end(err);
      }
    };
    ChangeUser.prototype["ErrorPacket"] = function(packet) {
      var err = this._packetToError(packet);
      err.fatal = true;
      this.end(err);
    };
  }
});

// node_modules/mysql/lib/protocol/sequences/Handshake.js
var require_Handshake = __commonJS({
  "node_modules/mysql/lib/protocol/sequences/Handshake.js"(exports2, module2) {
    var Sequence = require_Sequence();
    var Util = require_util2();
    var Packets = require_packets();
    var Auth = require_Auth();
    var ClientConstants = require_client();
    module2.exports = Handshake;
    Util.inherits(Handshake, Sequence);
    function Handshake(options, callback) {
      Sequence.call(this, options, callback);
      options = options || {};
      this._config = options.config;
      this._handshakeInitializationPacket = null;
    }
    Handshake.prototype.determinePacket = function determinePacket(firstByte, parser) {
      if (firstByte === 255) {
        return Packets.ErrorPacket;
      }
      if (!this._handshakeInitializationPacket) {
        return Packets.HandshakeInitializationPacket;
      }
      if (firstByte === 254) {
        return parser.packetLength() === 1 ? Packets.UseOldPasswordPacket : Packets.AuthSwitchRequestPacket;
      }
      return void 0;
    };
    Handshake.prototype["AuthSwitchRequestPacket"] = function(packet) {
      var name = packet.authMethodName;
      var data = Auth.auth(name, packet.authMethodData, {
        password: this._config.password
      });
      if (data !== void 0) {
        this.emit("packet", new Packets.AuthSwitchResponsePacket({
          data
        }));
      } else {
        var err = new Error("MySQL is requesting the " + name + " authentication method, which is not supported.");
        err.code = "UNSUPPORTED_AUTH_METHOD";
        err.fatal = true;
        this.end(err);
      }
    };
    Handshake.prototype["HandshakeInitializationPacket"] = function(packet) {
      this._handshakeInitializationPacket = packet;
      this._config.protocol41 = packet.protocol41;
      var serverSSLSupport = packet.serverCapabilities1 & ClientConstants.CLIENT_SSL;
      if (this._config.ssl) {
        if (!serverSSLSupport) {
          var err = new Error("Server does not support secure connection");
          err.code = "HANDSHAKE_NO_SSL_SUPPORT";
          err.fatal = true;
          this.end(err);
          return;
        }
        this._config.clientFlags |= ClientConstants.CLIENT_SSL;
        this.emit("packet", new Packets.SSLRequestPacket({
          clientFlags: this._config.clientFlags,
          maxPacketSize: this._config.maxPacketSize,
          charsetNumber: this._config.charsetNumber
        }));
        this.emit("start-tls");
      } else {
        this._sendCredentials();
      }
    };
    Handshake.prototype._tlsUpgradeCompleteHandler = function() {
      this._sendCredentials();
    };
    Handshake.prototype._sendCredentials = function() {
      var packet = this._handshakeInitializationPacket;
      this.emit("packet", new Packets.ClientAuthenticationPacket({
        clientFlags: this._config.clientFlags,
        maxPacketSize: this._config.maxPacketSize,
        charsetNumber: this._config.charsetNumber,
        user: this._config.user,
        database: this._config.database,
        protocol41: packet.protocol41,
        scrambleBuff: packet.protocol41 ? Auth.token(this._config.password, packet.scrambleBuff()) : Auth.scramble323(packet.scrambleBuff(), this._config.password)
      }));
    };
    Handshake.prototype["UseOldPasswordPacket"] = function() {
      if (!this._config.insecureAuth) {
        var err = new Error(
          "MySQL server is requesting the old and insecure pre-4.1 auth mechanism. Upgrade the user password or use the {insecureAuth: true} option."
        );
        err.code = "HANDSHAKE_INSECURE_AUTH";
        err.fatal = true;
        this.end(err);
        return;
      }
      this.emit("packet", new Packets.OldPasswordPacket({
        scrambleBuff: Auth.scramble323(this._handshakeInitializationPacket.scrambleBuff(), this._config.password)
      }));
    };
    Handshake.prototype["ErrorPacket"] = function(packet) {
      var err = this._packetToError(packet, true);
      err.fatal = true;
      this.end(err);
    };
  }
});

// node_modules/mysql/lib/protocol/sequences/Ping.js
var require_Ping = __commonJS({
  "node_modules/mysql/lib/protocol/sequences/Ping.js"(exports2, module2) {
    var Sequence = require_Sequence();
    var Util = require_util2();
    var Packets = require_packets();
    module2.exports = Ping;
    Util.inherits(Ping, Sequence);
    function Ping(options, callback) {
      if (!callback && typeof options === "function") {
        callback = options;
        options = {};
      }
      Sequence.call(this, options, callback);
    }
    Ping.prototype.start = function() {
      this.emit("packet", new Packets.ComPingPacket());
    };
  }
});

// node_modules/mysql/lib/protocol/ResultSet.js
var require_ResultSet = __commonJS({
  "node_modules/mysql/lib/protocol/ResultSet.js"(exports2, module2) {
    module2.exports = ResultSet;
    function ResultSet(resultSetHeaderPacket) {
      this.resultSetHeaderPacket = resultSetHeaderPacket;
      this.fieldPackets = [];
      this.eofPackets = [];
      this.rows = [];
    }
  }
});

// node_modules/mysql/lib/protocol/constants/server_status.js
var require_server_status = __commonJS({
  "node_modules/mysql/lib/protocol/constants/server_status.js"(exports2) {
    exports2.SERVER_STATUS_IN_TRANS = 1;
    exports2.SERVER_STATUS_AUTOCOMMIT = 2;
    exports2.SERVER_MORE_RESULTS_EXISTS = 8;
    exports2.SERVER_QUERY_NO_GOOD_INDEX_USED = 16;
    exports2.SERVER_QUERY_NO_INDEX_USED = 32;
    exports2.SERVER_STATUS_CURSOR_EXISTS = 64;
    exports2.SERVER_STATUS_LAST_ROW_SENT = 128;
    exports2.SERVER_STATUS_DB_DROPPED = 256;
    exports2.SERVER_STATUS_NO_BACKSLASH_ESCAPES = 512;
    exports2.SERVER_STATUS_METADATA_CHANGED = 1024;
    exports2.SERVER_QUERY_WAS_SLOW = 2048;
    exports2.SERVER_PS_OUT_PARAMS = 4096;
  }
});

// node_modules/process-nextick-args/index.js
var require_process_nextick_args = __commonJS({
  "node_modules/process-nextick-args/index.js"(exports2, module2) {
    "use strict";
    if (typeof process === "undefined" || !process.version || process.version.indexOf("v0.") === 0 || process.version.indexOf("v1.") === 0 && process.version.indexOf("v1.8.") !== 0) {
      module2.exports = { nextTick };
    } else {
      module2.exports = process;
    }
    function nextTick(fn, arg1, arg2, arg3) {
      if (typeof fn !== "function") {
        throw new TypeError('"callback" argument must be a function');
      }
      var len = arguments.length;
      var args, i;
      switch (len) {
        case 0:
        case 1:
          return process.nextTick(fn);
        case 2:
          return process.nextTick(function afterTickOne() {
            fn.call(null, arg1);
          });
        case 3:
          return process.nextTick(function afterTickTwo() {
            fn.call(null, arg1, arg2);
          });
        case 4:
          return process.nextTick(function afterTickThree() {
            fn.call(null, arg1, arg2, arg3);
          });
        default:
          args = new Array(len - 1);
          i = 0;
          while (i < args.length) {
            args[i++] = arguments[i];
          }
          return process.nextTick(function afterTick() {
            fn.apply(null, args);
          });
      }
    }
  }
});

// node_modules/isarray/index.js
var require_isarray = __commonJS({
  "node_modules/isarray/index.js"(exports2, module2) {
    var toString = {}.toString;
    module2.exports = Array.isArray || function(arr) {
      return toString.call(arr) == "[object Array]";
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/stream-browser.js
var require_stream_browser = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/stream-browser.js"(exports2, module2) {
    module2.exports = require_events().EventEmitter;
  }
});

// node_modules/core-util-is/lib/util.js
var require_util3 = __commonJS({
  "node_modules/core-util-is/lib/util.js"(exports2) {
    function isArray(arg) {
      if (Array.isArray) {
        return Array.isArray(arg);
      }
      return objectToString(arg) === "[object Array]";
    }
    exports2.isArray = isArray;
    function isBoolean(arg) {
      return typeof arg === "boolean";
    }
    exports2.isBoolean = isBoolean;
    function isNull(arg) {
      return arg === null;
    }
    exports2.isNull = isNull;
    function isNullOrUndefined(arg) {
      return arg == null;
    }
    exports2.isNullOrUndefined = isNullOrUndefined;
    function isNumber(arg) {
      return typeof arg === "number";
    }
    exports2.isNumber = isNumber;
    function isString(arg) {
      return typeof arg === "string";
    }
    exports2.isString = isString;
    function isSymbol(arg) {
      return typeof arg === "symbol";
    }
    exports2.isSymbol = isSymbol;
    function isUndefined(arg) {
      return arg === void 0;
    }
    exports2.isUndefined = isUndefined;
    function isRegExp(re) {
      return objectToString(re) === "[object RegExp]";
    }
    exports2.isRegExp = isRegExp;
    function isObject2(arg) {
      return typeof arg === "object" && arg !== null;
    }
    exports2.isObject = isObject2;
    function isDate(d) {
      return objectToString(d) === "[object Date]";
    }
    exports2.isDate = isDate;
    function isError2(e) {
      return objectToString(e) === "[object Error]" || e instanceof Error;
    }
    exports2.isError = isError2;
    function isFunction(arg) {
      return typeof arg === "function";
    }
    exports2.isFunction = isFunction;
    function isPrimitive2(arg) {
      return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
      typeof arg === "undefined";
    }
    exports2.isPrimitive = isPrimitive2;
    exports2.isBuffer = require_buffer().Buffer.isBuffer;
    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }
  }
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "node_modules/inherits/inherits_browser.js"(exports2, module2) {
    if (typeof Object.create === "function") {
      module2.exports = function inherits2(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module2.exports = function inherits2(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// node_modules/readable-stream/lib/internal/streams/BufferList.js
var require_BufferList2 = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/BufferList.js"(exports2, module2) {
    "use strict";
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var Buffer2 = require_safe_buffer().Buffer;
    var util = require_util2();
    function copyBuffer(src, target, offset) {
      src.copy(target, offset);
    }
    module2.exports = function() {
      function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      BufferList.prototype.push = function push(v) {
        var entry = { data: v, next: null };
        if (this.length > 0)
          this.tail.next = entry;
        else
          this.head = entry;
        this.tail = entry;
        ++this.length;
      };
      BufferList.prototype.unshift = function unshift(v) {
        var entry = { data: v, next: this.head };
        if (this.length === 0)
          this.tail = entry;
        this.head = entry;
        ++this.length;
      };
      BufferList.prototype.shift = function shift() {
        if (this.length === 0)
          return;
        var ret2 = this.head.data;
        if (this.length === 1)
          this.head = this.tail = null;
        else
          this.head = this.head.next;
        --this.length;
        return ret2;
      };
      BufferList.prototype.clear = function clear() {
        this.head = this.tail = null;
        this.length = 0;
      };
      BufferList.prototype.join = function join(s) {
        if (this.length === 0)
          return "";
        var p = this.head;
        var ret2 = "" + p.data;
        while (p = p.next) {
          ret2 += s + p.data;
        }
        return ret2;
      };
      BufferList.prototype.concat = function concat(n) {
        if (this.length === 0)
          return Buffer2.alloc(0);
        if (this.length === 1)
          return this.head.data;
        var ret2 = Buffer2.allocUnsafe(n >>> 0);
        var p = this.head;
        var i = 0;
        while (p) {
          copyBuffer(p.data, ret2, i);
          i += p.data.length;
          p = p.next;
        }
        return ret2;
      };
      return BufferList;
    }();
    if (util && util.inspect && util.inspect.custom) {
      module2.exports.prototype[util.inspect.custom] = function() {
        var obj2 = util.inspect({ length: this.length });
        return this.constructor.name + " " + obj2;
      };
    }
  }
});

// node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/destroy.js"(exports2, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    function destroy(err, cb) {
      var _this = this;
      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
          pna.nextTick(emitErrorNT, this, err);
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, function(err2) {
        if (!cb && err2) {
          pna.nextTick(emitErrorNT, _this, err2);
          if (_this._writableState) {
            _this._writableState.errorEmitted = true;
          }
        } else if (cb) {
          cb(err2);
        }
      });
      return this;
    }
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    function emitErrorNT(self2, err) {
      self2.emit("error", err);
    }
    module2.exports = {
      destroy,
      undestroy
    };
  }
});

// node_modules/util-deprecate/browser.js
var require_browser = __commonJS({
  "node_modules/util-deprecate/browser.js"(exports2, module2) {
    module2.exports = deprecate;
    function deprecate(fn, msg) {
      if (config("noDeprecation")) {
        return fn;
      }
      var warned = false;
      function deprecated() {
        if (!warned) {
          if (config("throwDeprecation")) {
            throw new Error(msg);
          } else if (config("traceDeprecation")) {
            console.trace(msg);
          } else {
            console.warn(msg);
          }
          warned = true;
        }
        return fn.apply(this, arguments);
      }
      return deprecated;
    }
    function config(name) {
      try {
        if (!global.localStorage)
          return false;
      } catch (_) {
        return false;
      }
      var val = global.localStorage[name];
      if (null == val)
        return false;
      return String(val).toLowerCase() === "true";
    }
  }
});

// node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable = __commonJS({
  "node_modules/readable-stream/lib/_stream_writable.js"(exports2, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    module2.exports = Writable;
    function CorkedRequest(state) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function() {
        onCorkedFinish(_this, state);
      };
    }
    var asyncWrite = !process.browser && ["v0.10", "v0.9."].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
    var Duplex;
    Writable.WritableState = WritableState;
    var util = Object.create(require_util3());
    util.inherits = require_inherits_browser();
    var internalUtil = {
      deprecate: require_browser()
    };
    var Stream = require_stream_browser();
    var Buffer2 = require_safe_buffer().Buffer;
    var OurUint8Array = global.Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj2) {
      return Buffer2.isBuffer(obj2) || obj2 instanceof OurUint8Array;
    }
    var destroyImpl = require_destroy();
    util.inherits(Writable, Stream);
    function nop() {
    }
    function WritableState(options, stream) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      var isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.writableObjectMode;
      var hwm = options.highWaterMark;
      var writableHwm = options.writableHighWaterMark;
      var defaultHwm = this.objectMode ? 16 : 16 * 1024;
      if (hwm || hwm === 0)
        this.highWaterMark = hwm;
      else if (isDuplex && (writableHwm || writableHwm === 0))
        this.highWaterMark = writableHwm;
      else
        this.highWaterMark = defaultHwm;
      this.highWaterMark = Math.floor(this.highWaterMark);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", {
          get: internalUtil.deprecate(function() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function(object) {
          if (realHasInstance.call(this, object))
            return true;
          if (this !== Writable)
            return false;
          return object && object._writableState instanceof WritableState;
        }
      });
    } else {
      realHasInstance = function(object) {
        return object instanceof this;
      };
    }
    function Writable(options) {
      Duplex = Duplex || require_stream_duplex();
      if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
        return new Writable(options);
      }
      this._writableState = new WritableState(options, this);
      this.writable = true;
      if (options) {
        if (typeof options.write === "function")
          this._write = options.write;
        if (typeof options.writev === "function")
          this._writev = options.writev;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
        if (typeof options.final === "function")
          this._final = options.final;
      }
      Stream.call(this);
    }
    Writable.prototype.pipe = function() {
      this.emit("error", new Error("Cannot pipe, not readable"));
    };
    function writeAfterEnd(stream, cb) {
      var er = new Error("write after end");
      stream.emit("error", er);
      pna.nextTick(cb, er);
    }
    function validChunk(stream, state, chunk, cb) {
      var valid = true;
      var er = false;
      if (chunk === null) {
        er = new TypeError("May not write null values to stream");
      } else if (typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new TypeError("Invalid non-string/buffer chunk");
      }
      if (er) {
        stream.emit("error", er);
        pna.nextTick(cb, er);
        valid = false;
      }
      return valid;
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret2 = false;
      var isBuf = !state.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer2.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (isBuf)
        encoding = "buffer";
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (typeof cb !== "function")
        cb = nop;
      if (state.ended)
        writeAfterEnd(this, cb);
      else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret2 = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
      }
      return ret2;
    };
    Writable.prototype.cork = function() {
      var state = this._writableState;
      state.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest)
          clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
        throw new TypeError("Unknown encoding: " + encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer2.from(chunk, encoding);
      }
      return chunk;
    }
    Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._writableState.highWaterMark;
      }
    });
    function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding = "buffer";
          chunk = newChunk;
        }
      }
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret2 = state.length < state.highWaterMark;
      if (!ret2)
        state.needDrain = true;
      if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk,
          encoding,
          isBuf,
          callback: cb,
          next: null
        };
        if (last) {
          last.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream, state, false, len, chunk, encoding, cb);
      }
      return ret2;
    }
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (writev)
        stream._writev(chunk, state.onwrite);
      else
        stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, sync, er, cb) {
      --state.pendingcb;
      if (sync) {
        pna.nextTick(cb, er);
        pna.nextTick(finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        stream.emit("error", er);
      } else {
        cb(er);
        stream._writableState.errorEmitted = true;
        stream.emit("error", er);
        finishMaybe(stream, state);
      }
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      onwriteStateUpdate(state);
      if (er)
        onwriteError(stream, state, sync, er, cb);
      else {
        var finished = needFinish(state);
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream, state);
        }
        if (sync) {
          asyncWrite(afterWrite, stream, state, finished, cb);
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }
    function afterWrite(stream, state, finished, cb) {
      if (!finished)
        onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    }
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
    }
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream._writev && entry && entry.next) {
        var l = state.bufferedRequestCount;
        var buffer = new Array(l);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while (entry) {
          buffer[count] = entry;
          if (!entry.isBuf)
            allBuffers = false;
          entry = entry.next;
          count += 1;
        }
        buffer.allBuffers = allBuffers;
        doWrite(stream, state, true, state.length, buffer, "", holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          state.bufferedRequestCount--;
          if (state.writing) {
            break;
          }
        }
        if (entry === null)
          state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new Error("_write() is not implemented"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0)
        this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending && !state.finished)
        endWritable(this, state, cb);
    };
    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    function callFinal(stream, state) {
      stream._final(function(err) {
        state.pendingcb--;
        if (err) {
          stream.emit("error", err);
        }
        state.prefinished = true;
        stream.emit("prefinish");
        finishMaybe(stream, state);
      });
    }
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function") {
          state.pendingcb++;
          state.finalCalled = true;
          pna.nextTick(callFinal, stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state) {
      var need = needFinish(state);
      if (need) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
          state.finished = true;
          stream.emit("finish");
        }
      }
      return need;
    }
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished)
          pna.nextTick(cb);
        else
          stream.once("finish", cb);
      }
      state.ended = true;
      stream.writable = false;
    }
    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      if (state.corkedRequestsFree) {
        state.corkedRequestsFree.next = corkReq;
      } else {
        state.corkedRequestsFree = corkReq;
      }
    }
    Object.defineProperty(Writable.prototype, "destroyed", {
      get: function() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      },
      set: function(value) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value;
      }
    });
    Writable.prototype.destroy = destroyImpl.destroy;
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      this.end();
      cb(err);
    };
  }
});

// node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex = __commonJS({
  "node_modules/readable-stream/lib/_stream_duplex.js"(exports2, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    var objectKeys = Object.keys || function(obj2) {
      var keys2 = [];
      for (var key in obj2) {
        keys2.push(key);
      }
      return keys2;
    };
    module2.exports = Duplex;
    var util = Object.create(require_util3());
    util.inherits = require_inherits_browser();
    var Readable = require_stream_readable();
    var Writable = require_stream_writable();
    util.inherits(Duplex, Readable);
    {
      keys = objectKeys(Writable.prototype);
      for (v = 0; v < keys.length; v++) {
        method = keys[v];
        if (!Duplex.prototype[method])
          Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    var keys;
    var method;
    var v;
    function Duplex(options) {
      if (!(this instanceof Duplex))
        return new Duplex(options);
      Readable.call(this, options);
      Writable.call(this, options);
      if (options && options.readable === false)
        this.readable = false;
      if (options && options.writable === false)
        this.writable = false;
      this.allowHalfOpen = true;
      if (options && options.allowHalfOpen === false)
        this.allowHalfOpen = false;
      this.once("end", onend);
    }
    Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._writableState.highWaterMark;
      }
    });
    function onend() {
      if (this.allowHalfOpen || this._writableState.ended)
        return;
      pna.nextTick(onEndNT, this);
    }
    function onEndNT(self2) {
      self2.end();
    }
    Object.defineProperty(Duplex.prototype, "destroyed", {
      get: function() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function(value) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    });
    Duplex.prototype._destroy = function(err, cb) {
      this.push(null);
      this.end();
      pna.nextTick(cb, err);
    };
  }
});

// node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder = __commonJS({
  "node_modules/string_decoder/lib/string_decoder.js"(exports2) {
    "use strict";
    var Buffer2 = require_safe_buffer().Buffer;
    var isEncoding = Buffer2.isEncoding || function(encoding) {
      encoding = "" + encoding;
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc)
        return "utf8";
      var retried;
      while (true) {
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried)
              return;
            enc = ("" + enc).toLowerCase();
            retried = true;
        }
      }
    }
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc)))
        throw new Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    exports2.StringDecoder = StringDecoder;
    function StringDecoder(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text;
          this.end = utf16End;
          nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast;
          nb = 4;
          break;
        case "base64":
          this.text = base64Text;
          this.end = base64End;
          nb = 3;
          break;
        default:
          this.write = simpleWrite;
          this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = Buffer2.allocUnsafe(nb);
    }
    StringDecoder.prototype.write = function(buf) {
      if (buf.length === 0)
        return "";
      var r;
      var i;
      if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === void 0)
          return "";
        i = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i = 0;
      }
      if (i < buf.length)
        return r ? r + this.text(buf, i) : this.text(buf, i);
      return r || "";
    };
    StringDecoder.prototype.end = utf8End;
    StringDecoder.prototype.text = utf8Text;
    StringDecoder.prototype.fillLast = function(buf) {
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
      this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127)
        return 0;
      else if (byte >> 5 === 6)
        return 2;
      else if (byte >> 4 === 14)
        return 3;
      else if (byte >> 3 === 30)
        return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    function utf8CheckIncomplete(self2, buf, i) {
      var j = buf.length - 1;
      if (j < i)
        return 0;
      var nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 1;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 2;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2)
            nb = 0;
          else
            self2.lastNeed = nb - 3;
        }
        return nb;
      }
      return 0;
    }
    function utf8CheckExtraBytes(self2, buf, p) {
      if ((buf[0] & 192) !== 128) {
        self2.lastNeed = 0;
        return "�";
      }
      if (self2.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128) {
          self2.lastNeed = 1;
          return "�";
        }
        if (self2.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 192) !== 128) {
            self2.lastNeed = 2;
            return "�";
          }
        }
      }
    }
    function utf8FillLast(buf) {
      var p = this.lastTotal - this.lastNeed;
      var r = utf8CheckExtraBytes(this, buf, p);
      if (r !== void 0)
        return r;
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, p, 0, buf.length);
      this.lastNeed -= buf.length;
    }
    function utf8Text(buf, i) {
      var total = utf8CheckIncomplete(this, buf, i);
      if (!this.lastNeed)
        return buf.toString("utf8", i);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      buf.copy(this.lastChar, 0, end);
      return buf.toString("utf8", i, end);
    }
    function utf8End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + "�";
      return r;
    }
    function utf16Text(buf, i) {
      if ((buf.length - i) % 2 === 0) {
        var r = buf.toString("utf16le", i);
        if (r) {
          var c = r.charCodeAt(r.length - 1);
          if (c >= 55296 && c <= 56319) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
            return r.slice(0, -1);
          }
        }
        return r;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = buf[buf.length - 1];
      return buf.toString("utf16le", i, buf.length - 1);
    }
    function utf16End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString("utf16le", 0, end);
      }
      return r;
    }
    function base64Text(buf, i) {
      var n = (buf.length - i) % 3;
      if (n === 0)
        return buf.toString("base64", i);
      this.lastNeed = 3 - n;
      this.lastTotal = 3;
      if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
      } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
      }
      return buf.toString("base64", i, buf.length - n);
    }
    function base64End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return r;
    }
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }
    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : "";
    }
  }
});

// node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable = __commonJS({
  "node_modules/readable-stream/lib/_stream_readable.js"(exports2, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    module2.exports = Readable;
    var isArray = require_isarray();
    var Duplex;
    Readable.ReadableState = ReadableState;
    var EE = require_events().EventEmitter;
    var EElistenerCount = function(emitter, type) {
      return emitter.listeners(type).length;
    };
    var Stream = require_stream_browser();
    var Buffer2 = require_safe_buffer().Buffer;
    var OurUint8Array = global.Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj2) {
      return Buffer2.isBuffer(obj2) || obj2 instanceof OurUint8Array;
    }
    var util = Object.create(require_util3());
    util.inherits = require_inherits_browser();
    var debugUtil = require_util2();
    var debug = void 0;
    if (debugUtil && debugUtil.debuglog) {
      debug = debugUtil.debuglog("stream");
    } else {
      debug = function() {
      };
    }
    var BufferList = require_BufferList2();
    var destroyImpl = require_destroy();
    var StringDecoder;
    util.inherits(Readable, Stream);
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function")
        return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn);
      else if (isArray(emitter._events[event]))
        emitter._events[event].unshift(fn);
      else
        emitter._events[event] = [fn, emitter._events[event]];
    }
    function ReadableState(options, stream) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      var isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.readableObjectMode;
      var hwm = options.highWaterMark;
      var readableHwm = options.readableHighWaterMark;
      var defaultHwm = this.objectMode ? 16 : 16 * 1024;
      if (hwm || hwm === 0)
        this.highWaterMark = hwm;
      else if (isDuplex && (readableHwm || readableHwm === 0))
        this.highWaterMark = readableHwm;
      else
        this.highWaterMark = defaultHwm;
      this.highWaterMark = Math.floor(this.highWaterMark);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.destroyed = false;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder)
          StringDecoder = require_string_decoder().StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable(options) {
      Duplex = Duplex || require_stream_duplex();
      if (!(this instanceof Readable))
        return new Readable(options);
      this._readableState = new ReadableState(options, this);
      this.readable = true;
      if (options) {
        if (typeof options.read === "function")
          this._read = options.read;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
      }
      Stream.call(this);
    }
    Object.defineProperty(Readable.prototype, "destroyed", {
      get: function() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      },
      set: function(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      }
    });
    Readable.prototype.destroy = destroyImpl.destroy;
    Readable.prototype._undestroy = destroyImpl.undestroy;
    Readable.prototype._destroy = function(err, cb) {
      this.push(null);
      cb(err);
    };
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      var skipChunkCheck;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer2.from(chunk, encoding);
            encoding = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
    };
    Readable.prototype.unshift = function(chunk) {
      return readableAddChunk(this, chunk, null, true, false);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
      var state = stream._readableState;
      if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else {
        var er;
        if (!skipChunkCheck)
          er = chunkInvalid(state, chunk);
        if (er) {
          stream.emit("error", er);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state.endEmitted)
              stream.emit("error", new Error("stream.unshift() after end event"));
            else
              addChunk(stream, state, chunk, true);
          } else if (state.ended) {
            stream.emit("error", new Error("stream.push() after EOF"));
          } else {
            state.reading = false;
            if (state.decoder && !encoding) {
              chunk = state.decoder.write(chunk);
              if (state.objectMode || chunk.length !== 0)
                addChunk(stream, state, chunk, false);
              else
                maybeReadMore(stream, state);
            } else {
              addChunk(stream, state, chunk, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
        }
      }
      return needMoreData(state);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync) {
        stream.emit("data", chunk);
        stream.read(0);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);
        if (state.needReadable)
          emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    function chunkInvalid(state, chunk) {
      var er;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new TypeError("Invalid non-string/buffer chunk");
      }
      return er;
    }
    function needMoreData(state) {
      return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
    }
    Readable.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable.prototype.setEncoding = function(enc) {
      if (!StringDecoder)
        StringDecoder = require_string_decoder().StringDecoder;
      this._readableState.decoder = new StringDecoder(enc);
      this._readableState.encoding = enc;
      return this;
    };
    var MAX_HWM = 8388608;
    function computeNewHighWaterMark(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (n <= 0 || state.length === 0 && state.ended)
        return 0;
      if (state.objectMode)
        return 1;
      if (n !== n) {
        if (state.flowing && state.length)
          return state.buffer.head.data.length;
        else
          return state.length;
      }
      if (n > state.highWaterMark)
        state.highWaterMark = computeNewHighWaterMark(n);
      if (n <= state.length)
        return n;
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }
    Readable.prototype.read = function(n) {
      debug("read", n);
      n = parseInt(n, 10);
      var state = this._readableState;
      var nOrig = n;
      if (n !== 0)
        state.emittedReadable = false;
      if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading)
          n = howMuchToRead(nOrig, state);
      }
      var ret2;
      if (n > 0)
        ret2 = fromList(n, state);
      else
        ret2 = null;
      if (ret2 === null) {
        state.needReadable = true;
        n = 0;
      } else {
        state.length -= n;
      }
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n && state.ended)
          endReadable(this);
      }
      if (ret2 !== null)
        this.emit("data", ret2);
      return ret2;
    };
    function onEofChunk(stream, state) {
      if (state.ended)
        return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      emitReadable(stream);
    }
    function emitReadable(stream) {
      var state = stream._readableState;
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        if (state.sync)
          pna.nextTick(emitReadable_, stream);
        else
          emitReadable_(stream);
      }
    }
    function emitReadable_(stream) {
      debug("emit readable");
      stream.emit("readable");
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        pna.nextTick(maybeReadMore_, stream, state);
      }
    }
    function maybeReadMore_(stream, state) {
      var len = state.length;
      while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
        else
          len = state.length;
      }
      state.readingMore = false;
    }
    Readable.prototype._read = function(n) {
      this.emit("error", new Error("_read() is not implemented"));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : unpipe;
      if (state.endEmitted)
        pna.nextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      var increasedAwaitDrain = false;
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        increasedAwaitDrain = false;
        var ret2 = dest.write(chunk);
        if (false === ret2 && !increasedAwaitDrain) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
            debug("false write response, pause", src._readableState.awaitDrain);
            src._readableState.awaitDrain++;
            increasedAwaitDrain = true;
          }
          src.pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0)
          dest.emit("error", er);
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return function() {
        var state = src._readableState;
        debug("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain)
          state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
          state.flowing = true;
          flow(src);
        }
      };
    }
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
      var unpipeInfo = { hasUnpiped: false };
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
          dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i = 0; i < len; i++) {
          dests[i].emit("unpipe", this, unpipeInfo);
        }
        return this;
      }
      var index = indexOf(state.pipes, dest);
      if (index === -1)
        return this;
      state.pipes.splice(index, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable.prototype.on = function(ev, fn) {
      var res = Stream.prototype.on.call(this, ev, fn);
      if (ev === "data") {
        if (this._readableState.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        var state = this._readableState;
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.emittedReadable = false;
          if (!state.reading) {
            pna.nextTick(nReadingNextTick, this);
          } else if (state.length) {
            emitReadable(this);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    Readable.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = true;
        resume(this, state);
      }
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        pna.nextTick(resume_, stream, state);
      }
    }
    function resume_(stream, state) {
      if (!state.reading) {
        debug("resume read 0");
        stream.read(0);
      }
      state.resumeScheduled = false;
      state.awaitDrain = 0;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading)
        stream.read(0);
    }
    Readable.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (false !== this._readableState.flowing) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      return this;
    };
    function flow(stream) {
      var state = stream._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream.read() !== null) {
      }
    }
    Readable.prototype.wrap = function(stream) {
      var _this = this;
      var state = this._readableState;
      var paused = false;
      stream.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            _this.push(chunk);
        }
        _this.push(null);
      });
      stream.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
        var ret2 = _this.push(chunk);
        if (!ret2) {
          paused = true;
          stream.pause();
        }
      });
      for (var i in stream) {
        if (this[i] === void 0 && typeof stream[i] === "function") {
          this[i] = function(method) {
            return function() {
              return stream[method].apply(stream, arguments);
            };
          }(i);
        }
      }
      for (var n = 0; n < kProxyEvents.length; n++) {
        stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
      }
      this._read = function(n2) {
        debug("wrapped _read", n2);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return this;
    };
    Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._readableState.highWaterMark;
      }
    });
    Readable._fromList = fromList;
    function fromList(n, state) {
      if (state.length === 0)
        return null;
      var ret2;
      if (state.objectMode)
        ret2 = state.buffer.shift();
      else if (!n || n >= state.length) {
        if (state.decoder)
          ret2 = state.buffer.join("");
        else if (state.buffer.length === 1)
          ret2 = state.buffer.head.data;
        else
          ret2 = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret2 = fromListPartial(n, state.buffer, state.decoder);
      }
      return ret2;
    }
    function fromListPartial(n, list, hasStrings) {
      var ret2;
      if (n < list.head.data.length) {
        ret2 = list.head.data.slice(0, n);
        list.head.data = list.head.data.slice(n);
      } else if (n === list.head.data.length) {
        ret2 = list.shift();
      } else {
        ret2 = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
      }
      return ret2;
    }
    function copyFromBufferString(n, list) {
      var p = list.head;
      var c = 1;
      var ret2 = p.data;
      n -= ret2.length;
      while (p = p.next) {
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length)
          ret2 += str;
        else
          ret2 += str.slice(0, n);
        n -= nb;
        if (n === 0) {
          if (nb === str.length) {
            ++c;
            if (p.next)
              list.head = p.next;
            else
              list.head = list.tail = null;
          } else {
            list.head = p;
            p.data = str.slice(nb);
          }
          break;
        }
        ++c;
      }
      list.length -= c;
      return ret2;
    }
    function copyFromBuffer(n, list) {
      var ret2 = Buffer2.allocUnsafe(n);
      var p = list.head;
      var c = 1;
      p.data.copy(ret2);
      n -= p.data.length;
      while (p = p.next) {
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret2, ret2.length - n, 0, nb);
        n -= nb;
        if (n === 0) {
          if (nb === buf.length) {
            ++c;
            if (p.next)
              list.head = p.next;
            else
              list.head = list.tail = null;
          } else {
            list.head = p;
            p.data = buf.slice(nb);
          }
          break;
        }
        ++c;
      }
      list.length -= c;
      return ret2;
    }
    function endReadable(stream) {
      var state = stream._readableState;
      if (state.length > 0)
        throw new Error('"endReadable()" called on non-empty stream');
      if (!state.endEmitted) {
        state.ended = true;
        pna.nextTick(endReadableNT, state, stream);
      }
    }
    function endReadableNT(state, stream) {
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
      }
    }
    function indexOf(xs, x) {
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x)
          return i;
      }
      return -1;
    }
  }
});

// node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform = __commonJS({
  "node_modules/readable-stream/lib/_stream_transform.js"(exports2, module2) {
    "use strict";
    module2.exports = Transform;
    var Duplex = require_stream_duplex();
    var util = Object.create(require_util3());
    util.inherits = require_inherits_browser();
    util.inherits(Transform, Duplex);
    function afterTransform(er, data) {
      var ts = this._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (!cb) {
        return this.emit("error", new Error("write callback called multiple times"));
      }
      ts.writechunk = null;
      ts.writecb = null;
      if (data != null)
        this.push(data);
      cb(er);
      var rs = this._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
      }
    }
    function Transform(options) {
      if (!(this instanceof Transform))
        return new Transform(options);
      Duplex.call(this, options);
      this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      };
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options) {
        if (typeof options.transform === "function")
          this._transform = options.transform;
        if (typeof options.flush === "function")
          this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    function prefinish() {
      var _this = this;
      if (typeof this._flush === "function") {
        this._flush(function(er, data) {
          done(_this, er, data);
        });
      } else {
        done(this, null, null);
      }
    }
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      throw new Error("_transform() is not implemented");
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
      if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    Transform.prototype._destroy = function(err, cb) {
      var _this2 = this;
      Duplex.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
        _this2.emit("close");
      });
    };
    function done(stream, er, data) {
      if (er)
        return stream.emit("error", er);
      if (data != null)
        stream.push(data);
      if (stream._writableState.length)
        throw new Error("Calling transform done when ws.length != 0");
      if (stream._transformState.transforming)
        throw new Error("Calling transform done when still transforming");
      return stream.push(null);
    }
  }
});

// node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough = __commonJS({
  "node_modules/readable-stream/lib/_stream_passthrough.js"(exports2, module2) {
    "use strict";
    module2.exports = PassThrough;
    var Transform = require_stream_transform();
    var util = Object.create(require_util3());
    util.inherits = require_inherits_browser();
    util.inherits(PassThrough, Transform);
    function PassThrough(options) {
      if (!(this instanceof PassThrough))
        return new PassThrough(options);
      Transform.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// node_modules/readable-stream/readable-browser.js
var require_readable_browser = __commonJS({
  "node_modules/readable-stream/readable-browser.js"(exports2, module2) {
    exports2 = module2.exports = require_stream_readable();
    exports2.Stream = exports2;
    exports2.Readable = exports2;
    exports2.Writable = require_stream_writable();
    exports2.Duplex = require_stream_duplex();
    exports2.Transform = require_stream_transform();
    exports2.PassThrough = require_stream_passthrough();
  }
});

// node_modules/mysql/lib/protocol/sequences/Query.js
var require_Query = __commonJS({
  "node_modules/mysql/lib/protocol/sequences/Query.js"(exports2, module2) {
    var ClientConstants = require_client();
    var fs = require_fs();
    var Packets = require_packets();
    var ResultSet = require_ResultSet();
    var Sequence = require_Sequence();
    var ServerStatus = require_server_status();
    var Readable = require_readable_browser();
    var Util = require_util2();
    module2.exports = Query;
    Util.inherits(Query, Sequence);
    function Query(options, callback) {
      Sequence.call(this, options, callback);
      this.sql = options.sql;
      this.values = options.values;
      this.typeCast = options.typeCast === void 0 ? true : options.typeCast;
      this.nestTables = options.nestTables || false;
      this._resultSet = null;
      this._results = [];
      this._fields = [];
      this._index = 0;
      this._loadError = null;
    }
    Query.prototype.start = function() {
      this.emit("packet", new Packets.ComQueryPacket(this.sql));
    };
    Query.prototype.determinePacket = function determinePacket(byte, parser) {
      var resultSet = this._resultSet;
      if (!resultSet) {
        switch (byte) {
          case 0:
            return Packets.OkPacket;
          case 251:
            return Packets.LocalInfileRequestPacket;
          case 255:
            return Packets.ErrorPacket;
          default:
            return Packets.ResultSetHeaderPacket;
        }
      }
      if (resultSet.eofPackets.length === 0) {
        return resultSet.fieldPackets.length < resultSet.resultSetHeaderPacket.fieldCount ? Packets.FieldPacket : Packets.EofPacket;
      }
      if (byte === 255) {
        return Packets.ErrorPacket;
      }
      if (byte === 254 && parser.packetLength() < 9) {
        return Packets.EofPacket;
      }
      return Packets.RowDataPacket;
    };
    Query.prototype["OkPacket"] = function(packet) {
      try {
        if (!this._callback) {
          this.emit("result", packet, this._index);
        } else {
          this._results.push(packet);
          this._fields.push(void 0);
        }
      } finally {
        this._index++;
        this._resultSet = null;
        this._handleFinalResultPacket(packet);
      }
    };
    Query.prototype["ErrorPacket"] = function(packet) {
      var err = this._packetToError(packet);
      var results = this._results.length > 0 ? this._results : void 0;
      var fields = this._fields.length > 0 ? this._fields : void 0;
      err.index = this._index;
      err.sql = this.sql;
      this.end(err, results, fields);
    };
    Query.prototype["LocalInfileRequestPacket"] = function(packet) {
      if (this._connection.config.clientFlags & ClientConstants.CLIENT_LOCAL_FILES) {
        this._sendLocalDataFile(packet.filename);
      } else {
        this._loadError = new Error("Load local files command is disabled");
        this._loadError.code = "LOCAL_FILES_DISABLED";
        this._loadError.fatal = false;
        this.emit("packet", new Packets.EmptyPacket());
      }
    };
    Query.prototype["ResultSetHeaderPacket"] = function(packet) {
      this._resultSet = new ResultSet(packet);
    };
    Query.prototype["FieldPacket"] = function(packet) {
      this._resultSet.fieldPackets.push(packet);
    };
    Query.prototype["EofPacket"] = function(packet) {
      this._resultSet.eofPackets.push(packet);
      if (this._resultSet.eofPackets.length === 1 && !this._callback) {
        this.emit("fields", this._resultSet.fieldPackets, this._index);
      }
      if (this._resultSet.eofPackets.length !== 2) {
        return;
      }
      if (this._callback) {
        this._results.push(this._resultSet.rows);
        this._fields.push(this._resultSet.fieldPackets);
      }
      this._index++;
      this._resultSet = null;
      this._handleFinalResultPacket(packet);
    };
    Query.prototype._handleFinalResultPacket = function(packet) {
      if (packet.serverStatus & ServerStatus.SERVER_MORE_RESULTS_EXISTS) {
        return;
      }
      var results = this._results.length > 1 ? this._results : this._results[0];
      var fields = this._fields.length > 1 ? this._fields : this._fields[0];
      this.end(this._loadError, results, fields);
    };
    Query.prototype["RowDataPacket"] = function(packet, parser, connection) {
      packet.parse(parser, this._resultSet.fieldPackets, this.typeCast, this.nestTables, connection);
      if (this._callback) {
        this._resultSet.rows.push(packet);
      } else {
        this.emit("result", packet, this._index);
      }
    };
    Query.prototype._sendLocalDataFile = function(path) {
      var self2 = this;
      var localStream = fs.createReadStream(path, {
        flag: "r",
        encoding: null,
        autoClose: true
      });
      this.on("pause", function() {
        localStream.pause();
      });
      this.on("resume", function() {
        localStream.resume();
      });
      localStream.on("data", function(data) {
        self2.emit("packet", new Packets.LocalDataFilePacket(data));
      });
      localStream.on("error", function(err) {
        self2._loadError = err;
        localStream.emit("end");
      });
      localStream.on("end", function() {
        self2.emit("packet", new Packets.EmptyPacket());
      });
    };
    Query.prototype.stream = function(options) {
      var self2 = this;
      options = options || {};
      options.objectMode = true;
      var stream = new Readable(options);
      stream._read = function() {
        self2._connection && self2._connection.resume();
      };
      stream.once("end", function() {
        process.nextTick(function() {
          stream.emit("close");
        });
      });
      this.on("result", function(row, i) {
        if (!stream.push(row))
          self2._connection.pause();
        stream.emit("result", row, i);
      });
      this.on("error", function(err) {
        stream.emit("error", err);
      });
      this.on("end", function() {
        stream.push(null);
      });
      this.on("fields", function(fields, i) {
        stream.emit("fields", fields, i);
      });
      return stream;
    };
  }
});

// node_modules/mysql/lib/protocol/sequences/Quit.js
var require_Quit = __commonJS({
  "node_modules/mysql/lib/protocol/sequences/Quit.js"(exports2, module2) {
    var Sequence = require_Sequence();
    var Util = require_util2();
    var Packets = require_packets();
    module2.exports = Quit;
    Util.inherits(Quit, Sequence);
    function Quit(options, callback) {
      if (!callback && typeof options === "function") {
        callback = options;
        options = {};
      }
      Sequence.call(this, options, callback);
      this._started = false;
    }
    Quit.prototype.end = function end(err) {
      if (this._ended) {
        return;
      }
      if (!this._started) {
        Sequence.prototype.end.call(this, err);
        return;
      }
      if (err && err.code === "ECONNRESET" && err.syscall === "read") {
        Sequence.prototype.end.call(this);
        return;
      }
      Sequence.prototype.end.call(this, err);
    };
    Quit.prototype.start = function() {
      this._started = true;
      this.emit("packet", new Packets.ComQuitPacket());
    };
  }
});

// node_modules/mysql/lib/protocol/sequences/Statistics.js
var require_Statistics = __commonJS({
  "node_modules/mysql/lib/protocol/sequences/Statistics.js"(exports2, module2) {
    var Sequence = require_Sequence();
    var Util = require_util2();
    var Packets = require_packets();
    module2.exports = Statistics;
    Util.inherits(Statistics, Sequence);
    function Statistics(options, callback) {
      if (!callback && typeof options === "function") {
        callback = options;
        options = {};
      }
      Sequence.call(this, options, callback);
    }
    Statistics.prototype.start = function() {
      this.emit("packet", new Packets.ComStatisticsPacket());
    };
    Statistics.prototype["StatisticsPacket"] = function(packet) {
      this.end(null, packet);
    };
    Statistics.prototype.determinePacket = function determinePacket(firstByte) {
      if (firstByte === 85) {
        return Packets.StatisticsPacket;
      }
      return void 0;
    };
  }
});

// node_modules/mysql/lib/protocol/sequences/index.js
var require_sequences = __commonJS({
  "node_modules/mysql/lib/protocol/sequences/index.js"(exports2) {
    exports2.ChangeUser = require_ChangeUser();
    exports2.Handshake = require_Handshake();
    exports2.Ping = require_Ping();
    exports2.Query = require_Query();
    exports2.Quit = require_Quit();
    exports2.Sequence = require_Sequence();
    exports2.Statistics = require_Statistics();
  }
});

// browser-external:stream
var require_stream = __commonJS({
  "browser-external:stream"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "stream" has been externalized for browser compatibility. Cannot access "stream.${key}" in client code.`);
        }
      }
    }));
  }
});

// node_modules/mysql/lib/protocol/PacketWriter.js
var require_PacketWriter = __commonJS({
  "node_modules/mysql/lib/protocol/PacketWriter.js"(exports2, module2) {
    var BIT_16 = Math.pow(2, 16);
    var BIT_24 = Math.pow(2, 24);
    var BUFFER_ALLOC_SIZE = Math.pow(2, 8);
    var IEEE_754_BINARY_64_PRECISION = Math.pow(2, 53);
    var MAX_PACKET_LENGTH = Math.pow(2, 24) - 1;
    var Buffer2 = require_safe_buffer().Buffer;
    module2.exports = PacketWriter;
    function PacketWriter() {
      this._buffer = null;
      this._offset = 0;
    }
    PacketWriter.prototype.toBuffer = function toBuffer(parser) {
      if (!this._buffer) {
        this._buffer = Buffer2.alloc(0);
        this._offset = 0;
      }
      var buffer = this._buffer;
      var length = this._offset;
      var packets = Math.floor(length / MAX_PACKET_LENGTH) + 1;
      this._buffer = Buffer2.allocUnsafe(length + packets * 4);
      this._offset = 0;
      for (var packet = 0; packet < packets; packet++) {
        var isLast = packet + 1 === packets;
        var packetLength = isLast ? length % MAX_PACKET_LENGTH : MAX_PACKET_LENGTH;
        var packetNumber = parser.incrementPacketNumber();
        this.writeUnsignedNumber(3, packetLength);
        this.writeUnsignedNumber(1, packetNumber);
        var start = packet * MAX_PACKET_LENGTH;
        var end = start + packetLength;
        this.writeBuffer(buffer.slice(start, end));
      }
      return this._buffer;
    };
    PacketWriter.prototype.writeUnsignedNumber = function(bytes, value) {
      this._allocate(bytes);
      for (var i = 0; i < bytes; i++) {
        this._buffer[this._offset++] = value >> i * 8 & 255;
      }
    };
    PacketWriter.prototype.writeFiller = function(bytes) {
      this._allocate(bytes);
      for (var i = 0; i < bytes; i++) {
        this._buffer[this._offset++] = 0;
      }
    };
    PacketWriter.prototype.writeNullTerminatedString = function(value, encoding) {
      value = value || "";
      value = value + "";
      var bytes = Buffer2.byteLength(value, encoding || "utf-8") + 1;
      this._allocate(bytes);
      this._buffer.write(value, this._offset, encoding);
      this._buffer[this._offset + bytes - 1] = 0;
      this._offset += bytes;
    };
    PacketWriter.prototype.writeString = function(value) {
      value = value || "";
      value = value + "";
      var bytes = Buffer2.byteLength(value, "utf-8");
      this._allocate(bytes);
      this._buffer.write(value, this._offset, "utf-8");
      this._offset += bytes;
    };
    PacketWriter.prototype.writeBuffer = function(value) {
      var bytes = value.length;
      this._allocate(bytes);
      value.copy(this._buffer, this._offset);
      this._offset += bytes;
    };
    PacketWriter.prototype.writeLengthCodedNumber = function(value) {
      if (value === null) {
        this._allocate(1);
        this._buffer[this._offset++] = 251;
        return;
      }
      if (value <= 250) {
        this._allocate(1);
        this._buffer[this._offset++] = value;
        return;
      }
      if (value > IEEE_754_BINARY_64_PRECISION) {
        throw new Error(
          'writeLengthCodedNumber: JS precision range exceeded, your number is > 53 bit: "' + value + '"'
        );
      }
      if (value < BIT_16) {
        this._allocate(3);
        this._buffer[this._offset++] = 252;
      } else if (value < BIT_24) {
        this._allocate(4);
        this._buffer[this._offset++] = 253;
      } else {
        this._allocate(9);
        this._buffer[this._offset++] = 254;
      }
      this._buffer[this._offset++] = value & 255;
      this._buffer[this._offset++] = value >> 8 & 255;
      if (value < BIT_16) {
        return;
      }
      this._buffer[this._offset++] = value >> 16 & 255;
      if (value < BIT_24) {
        return;
      }
      this._buffer[this._offset++] = value >> 24 & 255;
      value = value.toString(2);
      value = value.substr(0, value.length - 32);
      value = parseInt(value, 2);
      this._buffer[this._offset++] = value & 255;
      this._buffer[this._offset++] = value >> 8 & 255;
      this._buffer[this._offset++] = value >> 16 & 255;
      this._buffer[this._offset++] = 0;
    };
    PacketWriter.prototype.writeLengthCodedBuffer = function(value) {
      var bytes = value.length;
      this.writeLengthCodedNumber(bytes);
      this.writeBuffer(value);
    };
    PacketWriter.prototype.writeNullTerminatedBuffer = function(value) {
      this.writeBuffer(value);
      this.writeFiller(1);
    };
    PacketWriter.prototype.writeLengthCodedString = function(value) {
      if (value === null) {
        this.writeLengthCodedNumber(null);
        return;
      }
      value = value === void 0 ? "" : String(value);
      var bytes = Buffer2.byteLength(value, "utf-8");
      this.writeLengthCodedNumber(bytes);
      if (!bytes) {
        return;
      }
      this._allocate(bytes);
      this._buffer.write(value, this._offset, "utf-8");
      this._offset += bytes;
    };
    PacketWriter.prototype._allocate = function _allocate(bytes) {
      if (!this._buffer) {
        this._buffer = Buffer2.alloc(Math.max(BUFFER_ALLOC_SIZE, bytes));
        this._offset = 0;
        return;
      }
      var bytesRemaining = this._buffer.length - this._offset;
      if (bytesRemaining >= bytes) {
        return;
      }
      var newSize = this._buffer.length + Math.max(BUFFER_ALLOC_SIZE, bytes);
      var oldBuffer = this._buffer;
      this._buffer = Buffer2.alloc(newSize);
      oldBuffer.copy(this._buffer);
    };
  }
});

// node_modules/mysql/lib/protocol/Protocol.js
var require_Protocol = __commonJS({
  "node_modules/mysql/lib/protocol/Protocol.js"(exports2, module2) {
    var Parser = require_Parser();
    var Sequences = require_sequences();
    var Packets = require_packets();
    var Stream = require_stream().Stream;
    var Util = require_util2();
    var PacketWriter = require_PacketWriter();
    module2.exports = Protocol;
    Util.inherits(Protocol, Stream);
    function Protocol(options) {
      Stream.call(this);
      options = options || {};
      this.readable = true;
      this.writable = true;
      this._config = options.config || {};
      this._connection = options.connection;
      this._callback = null;
      this._fatalError = null;
      this._quitSequence = null;
      this._handshake = false;
      this._handshaked = false;
      this._ended = false;
      this._destroyed = false;
      this._queue = [];
      this._handshakeInitializationPacket = null;
      this._parser = new Parser({
        onError: this.handleParserError.bind(this),
        onPacket: this._parsePacket.bind(this),
        config: this._config
      });
    }
    Protocol.prototype.write = function(buffer) {
      this._parser.write(buffer);
      return true;
    };
    Protocol.prototype.handshake = function handshake(options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      options = options || {};
      options.config = this._config;
      var sequence = this._enqueue(new Sequences.Handshake(options, callback));
      this._handshake = true;
      return sequence;
    };
    Protocol.prototype.query = function query(options, callback) {
      return this._enqueue(new Sequences.Query(options, callback));
    };
    Protocol.prototype.changeUser = function changeUser(options, callback) {
      return this._enqueue(new Sequences.ChangeUser(options, callback));
    };
    Protocol.prototype.ping = function ping(options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      return this._enqueue(new Sequences.Ping(options, callback));
    };
    Protocol.prototype.stats = function stats(options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      return this._enqueue(new Sequences.Statistics(options, callback));
    };
    Protocol.prototype.quit = function quit(options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      var self2 = this;
      var sequence = this._enqueue(new Sequences.Quit(options, callback));
      sequence.on("end", function() {
        self2.end();
      });
      return this._quitSequence = sequence;
    };
    Protocol.prototype.end = function() {
      if (this._ended) {
        return;
      }
      this._ended = true;
      if (this._quitSequence && (this._quitSequence._ended || this._queue[0] === this._quitSequence)) {
        this._quitSequence.end();
        this.emit("end");
        return;
      }
      var err = new Error("Connection lost: The server closed the connection.");
      err.fatal = true;
      err.code = "PROTOCOL_CONNECTION_LOST";
      this._delegateError(err);
    };
    Protocol.prototype.pause = function() {
      this._parser.pause();
      var seq = this._queue[0];
      if (seq && seq.emit) {
        seq.emit("pause");
      }
    };
    Protocol.prototype.resume = function() {
      this._parser.resume();
      var seq = this._queue[0];
      if (seq && seq.emit) {
        seq.emit("resume");
      }
    };
    Protocol.prototype._enqueue = function(sequence) {
      if (!this._validateEnqueue(sequence)) {
        return sequence;
      }
      if (this._config.trace) {
        sequence._callSite = sequence._callSite || new Error();
      }
      this._queue.push(sequence);
      this.emit("enqueue", sequence);
      var self2 = this;
      sequence.on("error", function(err) {
        self2._delegateError(err, sequence);
      }).on("packet", function(packet) {
        sequence._timer.active();
        self2._emitPacket(packet);
      }).on("timeout", function() {
        var err = new Error(sequence.constructor.name + " inactivity timeout");
        err.code = "PROTOCOL_SEQUENCE_TIMEOUT";
        err.fatal = true;
        err.timeout = sequence._timeout;
        self2._delegateError(err, sequence);
      });
      if (sequence.constructor === Sequences.Handshake) {
        sequence.on("start-tls", function() {
          sequence._timer.active();
          self2._connection._startTLS(function(err) {
            if (err) {
              err.code = "HANDSHAKE_SSL_ERROR";
              err.fatal = true;
              sequence.end(err);
              return;
            }
            sequence._timer.active();
            sequence._tlsUpgradeCompleteHandler();
          });
        });
        sequence.on("end", function() {
          self2._handshaked = true;
          if (!self2._fatalError) {
            self2.emit("handshake", self2._handshakeInitializationPacket);
          }
        });
      }
      sequence.on("end", function() {
        self2._dequeue(sequence);
      });
      if (this._queue.length === 1) {
        this._parser.resetPacketNumber();
        this._startSequence(sequence);
      }
      return sequence;
    };
    Protocol.prototype._validateEnqueue = function _validateEnqueue(sequence) {
      var err;
      var prefix = "Cannot enqueue " + sequence.constructor.name;
      if (this._fatalError) {
        err = new Error(prefix + " after fatal error.");
        err.code = "PROTOCOL_ENQUEUE_AFTER_FATAL_ERROR";
      } else if (this._quitSequence) {
        err = new Error(prefix + " after invoking quit.");
        err.code = "PROTOCOL_ENQUEUE_AFTER_QUIT";
      } else if (this._destroyed) {
        err = new Error(prefix + " after being destroyed.");
        err.code = "PROTOCOL_ENQUEUE_AFTER_DESTROY";
      } else if ((this._handshake || this._handshaked) && sequence.constructor === Sequences.Handshake) {
        err = new Error(prefix + " after already enqueuing a Handshake.");
        err.code = "PROTOCOL_ENQUEUE_HANDSHAKE_TWICE";
      } else {
        return true;
      }
      var self2 = this;
      err.fatal = false;
      sequence.on("error", function(err2) {
        self2._delegateError(err2, sequence);
      });
      process.nextTick(function() {
        sequence.end(err);
      });
      return false;
    };
    Protocol.prototype._parsePacket = function() {
      var sequence = this._queue[0];
      if (!sequence) {
        var err = new Error("Received packet with no active sequence.");
        err.code = "PROTOCOL_STRAY_PACKET";
        err.fatal = true;
        this._delegateError(err);
        return;
      }
      var Packet = this._determinePacket(sequence);
      var packet = new Packet({ protocol41: this._config.protocol41 });
      var packetName = Packet.name;
      if (Packet === Packets.RowDataPacket) {
        sequence.RowDataPacket(packet, this._parser, this._connection);
        if (this._config.debug) {
          this._debugPacket(true, packet);
        }
        return;
      }
      if (this._config.debug) {
        this._parsePacketDebug(packet);
      } else {
        packet.parse(this._parser);
      }
      if (Packet === Packets.HandshakeInitializationPacket) {
        this._handshakeInitializationPacket = packet;
        this.emit("initialize", packet);
      }
      sequence._timer.active();
      if (!sequence[packetName]) {
        var err = new Error("Received packet in the wrong sequence.");
        err.code = "PROTOCOL_INCORRECT_PACKET_SEQUENCE";
        err.fatal = true;
        this._delegateError(err);
        return;
      }
      sequence[packetName](packet);
    };
    Protocol.prototype._parsePacketDebug = function _parsePacketDebug(packet) {
      try {
        packet.parse(this._parser);
      } finally {
        this._debugPacket(true, packet);
      }
    };
    Protocol.prototype._emitPacket = function(packet) {
      var packetWriter = new PacketWriter();
      packet.write(packetWriter);
      this.emit("data", packetWriter.toBuffer(this._parser));
      if (this._config.debug) {
        this._debugPacket(false, packet);
      }
    };
    Protocol.prototype._determinePacket = function(sequence) {
      var firstByte = this._parser.peak();
      if (sequence.determinePacket) {
        var Packet = sequence.determinePacket(firstByte, this._parser);
        if (Packet) {
          return Packet;
        }
      }
      switch (firstByte) {
        case 0:
          return Packets.OkPacket;
        case 254:
          return Packets.EofPacket;
        case 255:
          return Packets.ErrorPacket;
      }
      throw new Error("Could not determine packet, firstByte = " + firstByte);
    };
    Protocol.prototype._dequeue = function(sequence) {
      sequence._timer.stop();
      if (this._fatalError) {
        return;
      }
      this._queue.shift();
      var sequence = this._queue[0];
      if (!sequence) {
        this.emit("drain");
        return;
      }
      this._parser.resetPacketNumber();
      this._startSequence(sequence);
    };
    Protocol.prototype._startSequence = function(sequence) {
      if (sequence._timeout > 0 && isFinite(sequence._timeout)) {
        sequence._timer.start(sequence._timeout);
      }
      if (sequence.constructor === Sequences.ChangeUser) {
        sequence.start(this._handshakeInitializationPacket);
      } else {
        sequence.start();
      }
    };
    Protocol.prototype.handleNetworkError = function(err) {
      err.fatal = true;
      var sequence = this._queue[0];
      if (sequence) {
        sequence.end(err);
      } else {
        this._delegateError(err);
      }
    };
    Protocol.prototype.handleParserError = function handleParserError(err) {
      var sequence = this._queue[0];
      if (sequence) {
        sequence.end(err);
      } else {
        this._delegateError(err);
      }
    };
    Protocol.prototype._delegateError = function(err, sequence) {
      if (this._fatalError) {
        return;
      }
      if (err.fatal) {
        this._fatalError = err;
      }
      if (this._shouldErrorBubbleUp(err, sequence)) {
        this.emit("unhandledError", err);
      } else if (err.fatal) {
        var queue = this._queue;
        process.nextTick(function() {
          queue.forEach(function(sequence2) {
            sequence2.end(err);
          });
          queue.length = 0;
        });
      }
      if (err.fatal) {
        this.emit("end", err);
      }
    };
    Protocol.prototype._shouldErrorBubbleUp = function(err, sequence) {
      if (sequence) {
        if (sequence.hasErrorHandler()) {
          return false;
        } else if (!err.fatal) {
          return true;
        }
      }
      return err.fatal && !this._hasPendingErrorHandlers();
    };
    Protocol.prototype._hasPendingErrorHandlers = function() {
      return this._queue.some(function(sequence) {
        return sequence.hasErrorHandler();
      });
    };
    Protocol.prototype.destroy = function() {
      this._destroyed = true;
      this._parser.pause();
      if (this._connection.state !== "disconnected") {
        if (!this._ended) {
          this.end();
        }
      }
    };
    Protocol.prototype._debugPacket = function(incoming, packet) {
      var connection = this._connection;
      var direction = incoming ? "<--" : "-->";
      var packetName = packet.constructor.name;
      var threadId = connection && connection.threadId !== null ? " (" + connection.threadId + ")" : "";
      if (Array.isArray(this._config.debug) && this._config.debug.indexOf(packetName) === -1) {
        return;
      }
      var packetPayload = Util.inspect(packet).replace(/^[^{]+/, "");
      console.log("%s%s %s %s\n", direction, threadId, packetName, packetPayload);
    };
  }
});

// node_modules/sqlstring/lib/SqlString.js
var require_SqlString = __commonJS({
  "node_modules/sqlstring/lib/SqlString.js"(exports2) {
    var SqlString = exports2;
    var ID_GLOBAL_REGEXP = /`/g;
    var QUAL_GLOBAL_REGEXP = /\./g;
    var CHARS_GLOBAL_REGEXP = /[\0\b\t\n\r\x1a\"\'\\]/g;
    var CHARS_ESCAPE_MAP = {
      "\0": "\\0",
      "\b": "\\b",
      "	": "\\t",
      "\n": "\\n",
      "\r": "\\r",
      "": "\\Z",
      '"': '\\"',
      "'": "\\'",
      "\\": "\\\\"
    };
    SqlString.escapeId = function escapeId(val, forbidQualified) {
      if (Array.isArray(val)) {
        var sql = "";
        for (var i = 0; i < val.length; i++) {
          sql += (i === 0 ? "" : ", ") + SqlString.escapeId(val[i], forbidQualified);
        }
        return sql;
      } else if (forbidQualified) {
        return "`" + String(val).replace(ID_GLOBAL_REGEXP, "``") + "`";
      } else {
        return "`" + String(val).replace(ID_GLOBAL_REGEXP, "``").replace(QUAL_GLOBAL_REGEXP, "`.`") + "`";
      }
    };
    SqlString.escape = function escape(val, stringifyObjects, timeZone) {
      if (val === void 0 || val === null) {
        return "NULL";
      }
      switch (typeof val) {
        case "boolean":
          return val ? "true" : "false";
        case "number":
          return val + "";
        case "object":
          if (val instanceof Date) {
            return SqlString.dateToString(val, timeZone || "local");
          } else if (Array.isArray(val)) {
            return SqlString.arrayToList(val, timeZone);
          } else if (Buffer.isBuffer(val)) {
            return SqlString.bufferToString(val);
          } else if (typeof val.toSqlString === "function") {
            return String(val.toSqlString());
          } else if (stringifyObjects) {
            return escapeString(val.toString());
          } else {
            return SqlString.objectToValues(val, timeZone);
          }
        default:
          return escapeString(val);
      }
    };
    SqlString.arrayToList = function arrayToList(array, timeZone) {
      var sql = "";
      for (var i = 0; i < array.length; i++) {
        var val = array[i];
        if (Array.isArray(val)) {
          sql += (i === 0 ? "" : ", ") + "(" + SqlString.arrayToList(val, timeZone) + ")";
        } else {
          sql += (i === 0 ? "" : ", ") + SqlString.escape(val, true, timeZone);
        }
      }
      return sql;
    };
    SqlString.format = function format(sql, values, stringifyObjects, timeZone) {
      if (values == null) {
        return sql;
      }
      if (!(values instanceof Array || Array.isArray(values))) {
        values = [values];
      }
      var chunkIndex = 0;
      var placeholdersRegex = /\?+/g;
      var result = "";
      var valuesIndex = 0;
      var match;
      while (valuesIndex < values.length && (match = placeholdersRegex.exec(sql))) {
        var len = match[0].length;
        if (len > 2) {
          continue;
        }
        var value = len === 2 ? SqlString.escapeId(values[valuesIndex]) : SqlString.escape(values[valuesIndex], stringifyObjects, timeZone);
        result += sql.slice(chunkIndex, match.index) + value;
        chunkIndex = placeholdersRegex.lastIndex;
        valuesIndex++;
      }
      if (chunkIndex === 0) {
        return sql;
      }
      if (chunkIndex < sql.length) {
        return result + sql.slice(chunkIndex);
      }
      return result;
    };
    SqlString.dateToString = function dateToString(date, timeZone) {
      var dt = new Date(date);
      if (isNaN(dt.getTime())) {
        return "NULL";
      }
      var year;
      var month;
      var day;
      var hour;
      var minute;
      var second;
      var millisecond;
      if (timeZone === "local") {
        year = dt.getFullYear();
        month = dt.getMonth() + 1;
        day = dt.getDate();
        hour = dt.getHours();
        minute = dt.getMinutes();
        second = dt.getSeconds();
        millisecond = dt.getMilliseconds();
      } else {
        var tz = convertTimezone(timeZone);
        if (tz !== false && tz !== 0) {
          dt.setTime(dt.getTime() + tz * 6e4);
        }
        year = dt.getUTCFullYear();
        month = dt.getUTCMonth() + 1;
        day = dt.getUTCDate();
        hour = dt.getUTCHours();
        minute = dt.getUTCMinutes();
        second = dt.getUTCSeconds();
        millisecond = dt.getUTCMilliseconds();
      }
      var str = zeroPad(year, 4) + "-" + zeroPad(month, 2) + "-" + zeroPad(day, 2) + " " + zeroPad(hour, 2) + ":" + zeroPad(minute, 2) + ":" + zeroPad(second, 2) + "." + zeroPad(millisecond, 3);
      return escapeString(str);
    };
    SqlString.bufferToString = function bufferToString(buffer) {
      return "X" + escapeString(buffer.toString("hex"));
    };
    SqlString.objectToValues = function objectToValues(object, timeZone) {
      var sql = "";
      for (var key in object) {
        var val = object[key];
        if (typeof val === "function") {
          continue;
        }
        sql += (sql.length === 0 ? "" : ", ") + SqlString.escapeId(key) + " = " + SqlString.escape(val, true, timeZone);
      }
      return sql;
    };
    SqlString.raw = function raw(sql) {
      if (typeof sql !== "string") {
        throw new TypeError("argument sql must be a string");
      }
      return {
        toSqlString: function toSqlString() {
          return sql;
        }
      };
    };
    function escapeString(val) {
      var chunkIndex = CHARS_GLOBAL_REGEXP.lastIndex = 0;
      var escapedVal = "";
      var match;
      while (match = CHARS_GLOBAL_REGEXP.exec(val)) {
        escapedVal += val.slice(chunkIndex, match.index) + CHARS_ESCAPE_MAP[match[0]];
        chunkIndex = CHARS_GLOBAL_REGEXP.lastIndex;
      }
      if (chunkIndex === 0) {
        return "'" + val + "'";
      }
      if (chunkIndex < val.length) {
        return "'" + escapedVal + val.slice(chunkIndex) + "'";
      }
      return "'" + escapedVal + "'";
    }
    function zeroPad(number, length) {
      number = number.toString();
      while (number.length < length) {
        number = "0" + number;
      }
      return number;
    }
    function convertTimezone(tz) {
      if (tz === "Z") {
        return 0;
      }
      var m = tz.match(/([\+\-\s])(\d\d):?(\d\d)?/);
      if (m) {
        return (m[1] === "-" ? -1 : 1) * (parseInt(m[2], 10) + (m[3] ? parseInt(m[3], 10) : 0) / 60) * 60;
      }
      return false;
    }
  }
});

// node_modules/sqlstring/index.js
var require_sqlstring = __commonJS({
  "node_modules/sqlstring/index.js"(exports2, module2) {
    module2.exports = require_SqlString();
  }
});

// node_modules/mysql/lib/protocol/SqlString.js
var require_SqlString2 = __commonJS({
  "node_modules/mysql/lib/protocol/SqlString.js"(exports2, module2) {
    module2.exports = require_sqlstring();
  }
});

// node_modules/mysql/lib/Connection.js
var require_Connection = __commonJS({
  "node_modules/mysql/lib/Connection.js"(exports2, module2) {
    var Crypto = require_crypto();
    var Events = require_events();
    var Net = require_net();
    var tls = require_tls();
    var ConnectionConfig = require_ConnectionConfig();
    var Protocol = require_Protocol();
    var SqlString = require_SqlString2();
    var Query = require_Query();
    var Util = require_util2();
    module2.exports = Connection;
    Util.inherits(Connection, Events.EventEmitter);
    function Connection(options) {
      Events.EventEmitter.call(this);
      this.config = options.config;
      this._socket = options.socket;
      this._protocol = new Protocol({ config: this.config, connection: this });
      this._connectCalled = false;
      this.state = "disconnected";
      this.threadId = null;
    }
    Connection.createQuery = function createQuery(sql, values, callback) {
      if (sql instanceof Query) {
        return sql;
      }
      var cb = callback;
      var options = {};
      if (typeof sql === "function") {
        cb = sql;
      } else if (typeof sql === "object") {
        options = Object.create(sql);
        if (typeof values === "function") {
          cb = values;
        } else if (values !== void 0) {
          Object.defineProperty(options, "values", { value: values });
        }
      } else {
        options.sql = sql;
        if (typeof values === "function") {
          cb = values;
        } else if (values !== void 0) {
          options.values = values;
        }
      }
      if (cb !== void 0) {
        cb = wrapCallbackInDomain(null, cb);
        if (cb === void 0) {
          throw new TypeError("argument callback must be a function when provided");
        }
      }
      return new Query(options, cb);
    };
    Connection.prototype.connect = function connect(options, callback) {
      if (!callback && typeof options === "function") {
        callback = options;
        options = {};
      }
      if (!this._connectCalled) {
        this._connectCalled = true;
        this._socket = this.config.socketPath ? Net.createConnection(this.config.socketPath) : Net.createConnection(this.config.port, this.config.host);
        if (Events.usingDomains) {
          this._socket.domain = this.domain;
        }
        var connection = this;
        this._protocol.on("data", function(data) {
          connection._socket.write(data);
        });
        this._socket.on("data", wrapToDomain(connection, function(data) {
          connection._protocol.write(data);
        }));
        this._protocol.on("end", function() {
          connection._socket.end();
        });
        this._socket.on("end", wrapToDomain(connection, function() {
          connection._protocol.end();
        }));
        this._socket.on("error", this._handleNetworkError.bind(this));
        this._socket.on("connect", this._handleProtocolConnect.bind(this));
        this._protocol.on("handshake", this._handleProtocolHandshake.bind(this));
        this._protocol.on("initialize", this._handleProtocolInitialize.bind(this));
        this._protocol.on("unhandledError", this._handleProtocolError.bind(this));
        this._protocol.on("drain", this._handleProtocolDrain.bind(this));
        this._protocol.on("end", this._handleProtocolEnd.bind(this));
        this._protocol.on("enqueue", this._handleProtocolEnqueue.bind(this));
        if (this.config.connectTimeout) {
          var handleConnectTimeout = this._handleConnectTimeout.bind(this);
          this._socket.setTimeout(this.config.connectTimeout, handleConnectTimeout);
          this._socket.once("connect", function() {
            this.setTimeout(0, handleConnectTimeout);
          });
        }
      }
      this._protocol.handshake(options, wrapCallbackInDomain(this, callback));
    };
    Connection.prototype.changeUser = function changeUser(options, callback) {
      if (!callback && typeof options === "function") {
        callback = options;
        options = {};
      }
      this._implyConnect();
      var charsetNumber = options.charset ? ConnectionConfig.getCharsetNumber(options.charset) : this.config.charsetNumber;
      return this._protocol.changeUser({
        user: options.user || this.config.user,
        password: options.password || this.config.password,
        database: options.database || this.config.database,
        timeout: options.timeout,
        charsetNumber,
        currentConfig: this.config
      }, wrapCallbackInDomain(this, callback));
    };
    Connection.prototype.beginTransaction = function beginTransaction(options, callback) {
      if (!callback && typeof options === "function") {
        callback = options;
        options = {};
      }
      options = options || {};
      options.sql = "START TRANSACTION";
      options.values = null;
      return this.query(options, callback);
    };
    Connection.prototype.commit = function commit(options, callback) {
      if (!callback && typeof options === "function") {
        callback = options;
        options = {};
      }
      options = options || {};
      options.sql = "COMMIT";
      options.values = null;
      return this.query(options, callback);
    };
    Connection.prototype.rollback = function rollback(options, callback) {
      if (!callback && typeof options === "function") {
        callback = options;
        options = {};
      }
      options = options || {};
      options.sql = "ROLLBACK";
      options.values = null;
      return this.query(options, callback);
    };
    Connection.prototype.query = function query(sql, values, cb) {
      var query2 = Connection.createQuery(sql, values, cb);
      query2._connection = this;
      if (!(typeof sql === "object" && "typeCast" in sql)) {
        query2.typeCast = this.config.typeCast;
      }
      if (query2.sql) {
        query2.sql = this.format(query2.sql, query2.values);
      }
      if (query2._callback) {
        query2._callback = wrapCallbackInDomain(this, query2._callback);
      }
      this._implyConnect();
      return this._protocol._enqueue(query2);
    };
    Connection.prototype.ping = function ping(options, callback) {
      if (!callback && typeof options === "function") {
        callback = options;
        options = {};
      }
      this._implyConnect();
      this._protocol.ping(options, wrapCallbackInDomain(this, callback));
    };
    Connection.prototype.statistics = function statistics(options, callback) {
      if (!callback && typeof options === "function") {
        callback = options;
        options = {};
      }
      this._implyConnect();
      this._protocol.stats(options, wrapCallbackInDomain(this, callback));
    };
    Connection.prototype.end = function end(options, callback) {
      var cb = callback;
      var opts = options;
      if (!callback && typeof options === "function") {
        cb = options;
        opts = null;
      }
      opts = Object.create(opts || null);
      if (opts.timeout === void 0) {
        opts.timeout = 3e4;
      }
      this._implyConnect();
      this._protocol.quit(opts, wrapCallbackInDomain(this, cb));
    };
    Connection.prototype.destroy = function() {
      this.state = "disconnected";
      this._implyConnect();
      this._socket.destroy();
      this._protocol.destroy();
    };
    Connection.prototype.pause = function() {
      this._socket.pause();
      this._protocol.pause();
    };
    Connection.prototype.resume = function() {
      this._socket.resume();
      this._protocol.resume();
    };
    Connection.prototype.escape = function(value) {
      return SqlString.escape(value, false, this.config.timezone);
    };
    Connection.prototype.escapeId = function escapeId(value) {
      return SqlString.escapeId(value, false);
    };
    Connection.prototype.format = function(sql, values) {
      if (typeof this.config.queryFormat === "function") {
        return this.config.queryFormat.call(this, sql, values, this.config.timezone);
      }
      return SqlString.format(sql, values, this.config.stringifyObjects, this.config.timezone);
    };
    if (tls.TLSSocket) {
      Connection.prototype._startTLS = function _startTLS(onSecure) {
        var connection = this;
        createSecureContext(this.config, function(err, secureContext) {
          if (err) {
            onSecure(err);
            return;
          }
          connection._socket.removeAllListeners("data");
          connection._protocol.removeAllListeners("data");
          var rejectUnauthorized = connection.config.ssl.rejectUnauthorized;
          var secureEstablished = false;
          var secureSocket = new tls.TLSSocket(connection._socket, {
            rejectUnauthorized,
            requestCert: true,
            secureContext,
            isServer: false
          });
          secureSocket.on("_tlsError", function(err2) {
            if (secureEstablished) {
              connection._handleNetworkError(err2);
            } else {
              onSecure(err2);
            }
          });
          secureSocket.pipe(connection._protocol);
          connection._protocol.on("data", function(data) {
            secureSocket.write(data);
          });
          secureSocket.on("secure", function() {
            secureEstablished = true;
            onSecure(rejectUnauthorized ? this.ssl.verifyError() : null);
          });
          secureSocket._start();
        });
      };
    } else {
      Connection.prototype._startTLS = function _startTLS(onSecure) {
        var connection = this;
        var credentials = Crypto.createCredentials({
          ca: this.config.ssl.ca,
          cert: this.config.ssl.cert,
          ciphers: this.config.ssl.ciphers,
          key: this.config.ssl.key,
          passphrase: this.config.ssl.passphrase
        });
        var rejectUnauthorized = this.config.ssl.rejectUnauthorized;
        var secureEstablished = false;
        var securePair = tls.createSecurePair(credentials, false, true, rejectUnauthorized);
        securePair.on("error", function(err) {
          if (secureEstablished) {
            connection._handleNetworkError(err);
          } else {
            onSecure(err);
          }
        });
        this._socket.removeAllListeners("data");
        this._protocol.removeAllListeners("data");
        securePair.encrypted.pipe(this._socket);
        this._socket.on("data", function(data) {
          securePair.encrypted.write(data);
        });
        securePair.cleartext.pipe(this._protocol);
        this._protocol.on("data", function(data) {
          securePair.cleartext.write(data);
        });
        securePair.on("secure", function() {
          secureEstablished = true;
          if (!rejectUnauthorized) {
            onSecure();
            return;
          }
          var verifyError = this.ssl.verifyError();
          var err = verifyError;
          if (typeof err === "string") {
            err = new Error(verifyError);
            err.code = verifyError;
          }
          onSecure(err);
        });
        securePair._cycle = securePair.cycle;
        securePair.cycle = function cycle() {
          if (this.ssl && this.ssl.error) {
            this.error();
          }
          return this._cycle.apply(this, arguments);
        };
      };
    }
    Connection.prototype._handleConnectTimeout = function() {
      if (this._socket) {
        this._socket.setTimeout(0);
        this._socket.destroy();
      }
      var err = new Error("connect ETIMEDOUT");
      err.errorno = "ETIMEDOUT";
      err.code = "ETIMEDOUT";
      err.syscall = "connect";
      this._handleNetworkError(err);
    };
    Connection.prototype._handleNetworkError = function(err) {
      this._protocol.handleNetworkError(err);
    };
    Connection.prototype._handleProtocolError = function(err) {
      this.state = "protocol_error";
      this.emit("error", err);
    };
    Connection.prototype._handleProtocolDrain = function() {
      this.emit("drain");
    };
    Connection.prototype._handleProtocolConnect = function() {
      this.state = "connected";
      this.emit("connect");
    };
    Connection.prototype._handleProtocolHandshake = function _handleProtocolHandshake() {
      this.state = "authenticated";
    };
    Connection.prototype._handleProtocolInitialize = function _handleProtocolInitialize(packet) {
      this.threadId = packet.threadId;
    };
    Connection.prototype._handleProtocolEnd = function(err) {
      this.state = "disconnected";
      this.emit("end", err);
    };
    Connection.prototype._handleProtocolEnqueue = function _handleProtocolEnqueue(sequence) {
      this.emit("enqueue", sequence);
    };
    Connection.prototype._implyConnect = function() {
      if (!this._connectCalled) {
        this.connect();
      }
    };
    function createSecureContext(config, cb) {
      var context = null;
      var error = null;
      try {
        context = tls.createSecureContext({
          ca: config.ssl.ca,
          cert: config.ssl.cert,
          ciphers: config.ssl.ciphers,
          key: config.ssl.key,
          passphrase: config.ssl.passphrase
        });
      } catch (err) {
        error = err;
      }
      cb(error, context);
    }
    function unwrapFromDomain(fn) {
      return function() {
        var domains = [];
        var ret2;
        while (process.domain) {
          domains.shift(process.domain);
          process.domain.exit();
        }
        try {
          ret2 = fn.apply(this, arguments);
        } finally {
          for (var i = 0; i < domains.length; i++) {
            domains[i].enter();
          }
        }
        return ret2;
      };
    }
    function wrapCallbackInDomain(ee, fn) {
      if (typeof fn !== "function") {
        return void 0;
      }
      if (fn.domain) {
        return fn;
      }
      var domain = process.domain;
      if (domain) {
        return domain.bind(fn);
      } else if (ee) {
        return unwrapFromDomain(wrapToDomain(ee, fn));
      } else {
        return fn;
      }
    }
    function wrapToDomain(ee, fn) {
      return function() {
        if (Events.usingDomains && ee.domain) {
          ee.domain.enter();
          fn.apply(this, arguments);
          ee.domain.exit();
        } else {
          fn.apply(this, arguments);
        }
      };
    }
  }
});

// node_modules/mysql/lib/PoolConnection.js
var require_PoolConnection = __commonJS({
  "node_modules/mysql/lib/PoolConnection.js"(exports2, module2) {
    var inherits2 = require_util2().inherits;
    var Connection = require_Connection();
    var Events = require_events();
    module2.exports = PoolConnection;
    inherits2(PoolConnection, Connection);
    function PoolConnection(pool, options) {
      Connection.call(this, options);
      this._pool = pool;
      if (Events.usingDomains) {
        this.domain = pool.domain;
      }
      this.on("end", this._removeFromPool);
      this.on("error", function(err) {
        if (err.fatal) {
          this._removeFromPool();
        }
      });
    }
    PoolConnection.prototype.release = function release() {
      var pool = this._pool;
      if (!pool || pool._closed) {
        return void 0;
      }
      return pool.releaseConnection(this);
    };
    PoolConnection.prototype._realEnd = Connection.prototype.end;
    PoolConnection.prototype.end = function() {
      console.warn(
        "Calling conn.end() to release a pooled connection is deprecated. In next version calling conn.end() will be restored to default conn.end() behavior. Use conn.release() instead."
      );
      this.release();
    };
    PoolConnection.prototype.destroy = function() {
      Connection.prototype.destroy.apply(this, arguments);
      this._removeFromPool(this);
    };
    PoolConnection.prototype._removeFromPool = function _removeFromPool() {
      if (!this._pool || this._pool._closed) {
        return;
      }
      var pool = this._pool;
      this._pool = null;
      pool._purgeConnection(this);
    };
  }
});

// node_modules/mysql/lib/Pool.js
var require_Pool = __commonJS({
  "node_modules/mysql/lib/Pool.js"(exports2, module2) {
    var mysql = require_mysql();
    var Connection = require_Connection();
    var EventEmitter = require_events().EventEmitter;
    var Util = require_util2();
    var PoolConnection = require_PoolConnection();
    module2.exports = Pool;
    Util.inherits(Pool, EventEmitter);
    function Pool(options) {
      EventEmitter.call(this);
      this.config = options.config;
      this.config.connectionConfig.pool = this;
      this._acquiringConnections = [];
      this._allConnections = [];
      this._freeConnections = [];
      this._connectionQueue = [];
      this._closed = false;
    }
    Pool.prototype.getConnection = function(cb) {
      if (this._closed) {
        var err = new Error("Pool is closed.");
        err.code = "POOL_CLOSED";
        process.nextTick(function() {
          cb(err);
        });
        return;
      }
      var connection;
      var pool = this;
      if (this._freeConnections.length > 0) {
        connection = this._freeConnections.shift();
        this.acquireConnection(connection, cb);
        return;
      }
      if (this.config.connectionLimit === 0 || this._allConnections.length < this.config.connectionLimit) {
        connection = new PoolConnection(this, { config: this.config.newConnectionConfig() });
        this._acquiringConnections.push(connection);
        this._allConnections.push(connection);
        connection.connect({ timeout: this.config.acquireTimeout }, function onConnect(err2) {
          spliceConnection(pool._acquiringConnections, connection);
          if (pool._closed) {
            err2 = new Error("Pool is closed.");
            err2.code = "POOL_CLOSED";
          }
          if (err2) {
            pool._purgeConnection(connection);
            cb(err2);
            return;
          }
          pool.emit("connection", connection);
          pool.emit("acquire", connection);
          cb(null, connection);
        });
        return;
      }
      if (!this.config.waitForConnections) {
        process.nextTick(function() {
          var err2 = new Error("No connections available.");
          err2.code = "POOL_CONNLIMIT";
          cb(err2);
        });
        return;
      }
      this._enqueueCallback(cb);
    };
    Pool.prototype.acquireConnection = function acquireConnection(connection, cb) {
      if (connection._pool !== this) {
        throw new Error("Connection acquired from wrong pool.");
      }
      var changeUser = this._needsChangeUser(connection);
      var pool = this;
      this._acquiringConnections.push(connection);
      function onOperationComplete(err) {
        spliceConnection(pool._acquiringConnections, connection);
        if (pool._closed) {
          err = new Error("Pool is closed.");
          err.code = "POOL_CLOSED";
        }
        if (err) {
          pool._connectionQueue.unshift(cb);
          pool._purgeConnection(connection);
          return;
        }
        if (changeUser) {
          pool.emit("connection", connection);
        }
        pool.emit("acquire", connection);
        cb(null, connection);
      }
      if (changeUser) {
        connection.config = this.config.newConnectionConfig();
        connection.changeUser({ timeout: this.config.acquireTimeout }, onOperationComplete);
      } else {
        connection.ping({ timeout: this.config.acquireTimeout }, onOperationComplete);
      }
    };
    Pool.prototype.releaseConnection = function releaseConnection(connection) {
      if (this._acquiringConnections.indexOf(connection) !== -1) {
        return;
      }
      if (connection._pool) {
        if (connection._pool !== this) {
          throw new Error("Connection released to wrong pool");
        }
        if (this._freeConnections.indexOf(connection) !== -1) {
          throw new Error("Connection already released");
        } else {
          this._freeConnections.push(connection);
          this.emit("release", connection);
        }
      }
      if (this._closed) {
        this._connectionQueue.splice(0).forEach(function(cb) {
          var err = new Error("Pool is closed.");
          err.code = "POOL_CLOSED";
          process.nextTick(function() {
            cb(err);
          });
        });
      } else if (this._connectionQueue.length) {
        this.getConnection(this._connectionQueue.shift());
      }
    };
    Pool.prototype.end = function(cb) {
      this._closed = true;
      if (typeof cb !== "function") {
        cb = function(err) {
          if (err)
            throw err;
        };
      }
      var calledBack = false;
      var waitingClose = 0;
      function onEnd(err) {
        if (!calledBack && (err || --waitingClose <= 0)) {
          calledBack = true;
          cb(err);
        }
      }
      while (this._allConnections.length !== 0) {
        waitingClose++;
        this._purgeConnection(this._allConnections[0], onEnd);
      }
      if (waitingClose === 0) {
        process.nextTick(onEnd);
      }
    };
    Pool.prototype.query = function(sql, values, cb) {
      var query = Connection.createQuery(sql, values, cb);
      if (!(typeof sql === "object" && "typeCast" in sql)) {
        query.typeCast = this.config.connectionConfig.typeCast;
      }
      if (this.config.connectionConfig.trace) {
        query._callSite = new Error();
      }
      this.getConnection(function(err, conn) {
        if (err) {
          query.on("error", function() {
          });
          query.end(err);
          return;
        }
        query.once("end", function() {
          conn.release();
        });
        conn.query(query);
      });
      return query;
    };
    Pool.prototype._enqueueCallback = function _enqueueCallback(callback) {
      if (this.config.queueLimit && this._connectionQueue.length >= this.config.queueLimit) {
        process.nextTick(function() {
          var err = new Error("Queue limit reached.");
          err.code = "POOL_ENQUEUELIMIT";
          callback(err);
        });
        return;
      }
      var cb = process.domain ? process.domain.bind(callback) : callback;
      this._connectionQueue.push(cb);
      this.emit("enqueue");
    };
    Pool.prototype._needsChangeUser = function _needsChangeUser(connection) {
      var connConfig = connection.config;
      var poolConfig = this.config.connectionConfig;
      return connConfig.user !== poolConfig.user || connConfig.database !== poolConfig.database || connConfig.password !== poolConfig.password || connConfig.charsetNumber !== poolConfig.charsetNumber;
    };
    Pool.prototype._purgeConnection = function _purgeConnection(connection, callback) {
      var cb = callback || function() {
      };
      if (connection.state === "disconnected") {
        connection.destroy();
      }
      this._removeConnection(connection);
      if (connection.state !== "disconnected" && !connection._protocol._quitSequence) {
        connection._realEnd(cb);
        return;
      }
      process.nextTick(cb);
    };
    Pool.prototype._removeConnection = function(connection) {
      connection._pool = null;
      spliceConnection(this._allConnections, connection);
      spliceConnection(this._freeConnections, connection);
      this.releaseConnection(connection);
    };
    Pool.prototype.escape = function(value) {
      return mysql.escape(value, this.config.connectionConfig.stringifyObjects, this.config.connectionConfig.timezone);
    };
    Pool.prototype.escapeId = function escapeId(value) {
      return mysql.escapeId(value, false);
    };
    function spliceConnection(array, connection) {
      var index;
      if ((index = array.indexOf(connection)) !== -1) {
        array.splice(index, 1);
      }
    }
  }
});

// node_modules/mysql/lib/PoolConfig.js
var require_PoolConfig = __commonJS({
  "node_modules/mysql/lib/PoolConfig.js"(exports2, module2) {
    var ConnectionConfig = require_ConnectionConfig();
    module2.exports = PoolConfig;
    function PoolConfig(options) {
      if (typeof options === "string") {
        options = ConnectionConfig.parseUrl(options);
      }
      this.acquireTimeout = options.acquireTimeout === void 0 ? 10 * 1e3 : Number(options.acquireTimeout);
      this.connectionConfig = new ConnectionConfig(options);
      this.waitForConnections = options.waitForConnections === void 0 ? true : Boolean(options.waitForConnections);
      this.connectionLimit = options.connectionLimit === void 0 ? 10 : Number(options.connectionLimit);
      this.queueLimit = options.queueLimit === void 0 ? 0 : Number(options.queueLimit);
    }
    PoolConfig.prototype.newConnectionConfig = function newConnectionConfig() {
      var connectionConfig = new ConnectionConfig(this.connectionConfig);
      connectionConfig.clientFlags = this.connectionConfig.clientFlags;
      connectionConfig.maxPacketSize = this.connectionConfig.maxPacketSize;
      return connectionConfig;
    };
  }
});

// node_modules/mysql/lib/PoolSelector.js
var require_PoolSelector = __commonJS({
  "node_modules/mysql/lib/PoolSelector.js"(exports2, module2) {
    var PoolSelector = module2.exports = {};
    PoolSelector.RR = function PoolSelectorRoundRobin() {
      var index = 0;
      return function(clusterIds) {
        if (index >= clusterIds.length) {
          index = 0;
        }
        var clusterId = clusterIds[index++];
        return clusterId;
      };
    };
    PoolSelector.RANDOM = function PoolSelectorRandom() {
      return function(clusterIds) {
        return clusterIds[Math.floor(Math.random() * clusterIds.length)];
      };
    };
    PoolSelector.ORDER = function PoolSelectorOrder() {
      return function(clusterIds) {
        return clusterIds[0];
      };
    };
  }
});

// node_modules/mysql/lib/PoolNamespace.js
var require_PoolNamespace = __commonJS({
  "node_modules/mysql/lib/PoolNamespace.js"(exports2, module2) {
    var Connection = require_Connection();
    var PoolSelector = require_PoolSelector();
    module2.exports = PoolNamespace;
    function PoolNamespace(cluster, pattern, selector) {
      this._cluster = cluster;
      this._pattern = pattern;
      this._selector = new PoolSelector[selector]();
    }
    PoolNamespace.prototype.getConnection = function(cb) {
      var clusterNode = this._getClusterNode();
      var cluster = this._cluster;
      var namespace = this;
      if (clusterNode === null) {
        var err = null;
        if (this._cluster._findNodeIds(this._pattern, true).length !== 0) {
          err = new Error("Pool does not have online node.");
          err.code = "POOL_NONEONLINE";
        } else {
          err = new Error("Pool does not exist.");
          err.code = "POOL_NOEXIST";
        }
        cb(err);
        return;
      }
      cluster._getConnection(clusterNode, function(err2, connection) {
        var retry = err2 && cluster._canRetry && cluster._findNodeIds(namespace._pattern).length !== 0;
        if (retry) {
          namespace.getConnection(cb);
          return;
        }
        if (err2) {
          cb(err2);
          return;
        }
        cb(null, connection);
      });
    };
    PoolNamespace.prototype.query = function(sql, values, cb) {
      var cluster = this._cluster;
      var clusterNode = this._getClusterNode();
      var query = Connection.createQuery(sql, values, cb);
      var namespace = this;
      if (clusterNode === null) {
        var err = null;
        if (this._cluster._findNodeIds(this._pattern, true).length !== 0) {
          err = new Error("Pool does not have online node.");
          err.code = "POOL_NONEONLINE";
        } else {
          err = new Error("Pool does not exist.");
          err.code = "POOL_NOEXIST";
        }
        process.nextTick(function() {
          query.on("error", function() {
          });
          query.end(err);
        });
        return query;
      }
      if (!(typeof sql === "object" && "typeCast" in sql)) {
        query.typeCast = clusterNode.pool.config.connectionConfig.typeCast;
      }
      if (clusterNode.pool.config.connectionConfig.trace) {
        query._callSite = new Error();
      }
      cluster._getConnection(clusterNode, function(err2, conn) {
        var retry = err2 && cluster._canRetry && cluster._findNodeIds(namespace._pattern).length !== 0;
        if (retry) {
          namespace.query(query);
          return;
        }
        if (err2) {
          query.on("error", function() {
          });
          query.end(err2);
          return;
        }
        query.once("end", function() {
          conn.release();
        });
        conn.query(query);
      });
      return query;
    };
    PoolNamespace.prototype._getClusterNode = function _getClusterNode() {
      var foundNodeIds = this._cluster._findNodeIds(this._pattern);
      var nodeId;
      switch (foundNodeIds.length) {
        case 0:
          nodeId = null;
          break;
        case 1:
          nodeId = foundNodeIds[0];
          break;
        default:
          nodeId = this._selector(foundNodeIds);
          break;
      }
      return nodeId !== null ? this._cluster._getNode(nodeId) : null;
    };
  }
});

// node_modules/mysql/lib/PoolCluster.js
var require_PoolCluster = __commonJS({
  "node_modules/mysql/lib/PoolCluster.js"(exports2, module2) {
    var Pool = require_Pool();
    var PoolConfig = require_PoolConfig();
    var PoolNamespace = require_PoolNamespace();
    var PoolSelector = require_PoolSelector();
    var Util = require_util2();
    var EventEmitter = require_events().EventEmitter;
    module2.exports = PoolCluster;
    function PoolCluster(config) {
      EventEmitter.call(this);
      config = config || {};
      this._canRetry = typeof config.canRetry === "undefined" ? true : config.canRetry;
      this._defaultSelector = config.defaultSelector || "RR";
      this._removeNodeErrorCount = config.removeNodeErrorCount || 5;
      this._restoreNodeTimeout = config.restoreNodeTimeout || 0;
      this._closed = false;
      this._findCaches = /* @__PURE__ */ Object.create(null);
      this._lastId = 0;
      this._namespaces = /* @__PURE__ */ Object.create(null);
      this._nodes = /* @__PURE__ */ Object.create(null);
    }
    Util.inherits(PoolCluster, EventEmitter);
    PoolCluster.prototype.add = function add(id, config) {
      if (this._closed) {
        throw new Error("PoolCluster is closed.");
      }
      var nodeId = typeof id === "object" ? "CLUSTER::" + ++this._lastId : String(id);
      if (this._nodes[nodeId] !== void 0) {
        throw new Error('Node ID "' + nodeId + '" is already defined in PoolCluster.');
      }
      var poolConfig = typeof id !== "object" ? new PoolConfig(config) : new PoolConfig(id);
      this._nodes[nodeId] = {
        id: nodeId,
        errorCount: 0,
        pool: new Pool({ config: poolConfig }),
        _offlineUntil: 0
      };
      this._clearFindCaches();
    };
    PoolCluster.prototype.end = function end(callback) {
      var cb = callback !== void 0 ? callback : _cb;
      if (typeof cb !== "function") {
        throw TypeError("callback argument must be a function");
      }
      if (this._closed) {
        process.nextTick(cb);
        return;
      }
      this._closed = true;
      var calledBack = false;
      var nodeIds = Object.keys(this._nodes);
      var waitingClose = 0;
      function onEnd(err) {
        if (!calledBack && (err || --waitingClose <= 0)) {
          calledBack = true;
          cb(err);
        }
      }
      for (var i = 0; i < nodeIds.length; i++) {
        var nodeId = nodeIds[i];
        var node = this._nodes[nodeId];
        waitingClose++;
        node.pool.end(onEnd);
      }
      if (waitingClose === 0) {
        process.nextTick(onEnd);
      }
    };
    PoolCluster.prototype.of = function(pattern, selector) {
      pattern = pattern || "*";
      selector = selector || this._defaultSelector;
      selector = selector.toUpperCase();
      if (typeof PoolSelector[selector] === "undefined") {
        selector = this._defaultSelector;
      }
      var key = pattern + selector;
      if (typeof this._namespaces[key] === "undefined") {
        this._namespaces[key] = new PoolNamespace(this, pattern, selector);
      }
      return this._namespaces[key];
    };
    PoolCluster.prototype.remove = function remove(pattern) {
      var foundNodeIds = this._findNodeIds(pattern, true);
      for (var i = 0; i < foundNodeIds.length; i++) {
        var node = this._getNode(foundNodeIds[i]);
        if (node) {
          this._removeNode(node);
        }
      }
    };
    PoolCluster.prototype.getConnection = function(pattern, selector, cb) {
      var namespace;
      if (typeof pattern === "function") {
        cb = pattern;
        namespace = this.of();
      } else {
        if (typeof selector === "function") {
          cb = selector;
          selector = this._defaultSelector;
        }
        namespace = this.of(pattern, selector);
      }
      namespace.getConnection(cb);
    };
    PoolCluster.prototype._clearFindCaches = function _clearFindCaches() {
      this._findCaches = /* @__PURE__ */ Object.create(null);
    };
    PoolCluster.prototype._decreaseErrorCount = function _decreaseErrorCount(node) {
      var errorCount = node.errorCount;
      if (errorCount > this._removeNodeErrorCount) {
        errorCount = this._removeNodeErrorCount;
      }
      if (errorCount < 1) {
        errorCount = 1;
      }
      node.errorCount = errorCount - 1;
      if (node._offlineUntil) {
        node._offlineUntil = 0;
        this.emit("online", node.id);
      }
    };
    PoolCluster.prototype._findNodeIds = function _findNodeIds(pattern, includeOffline) {
      var currentTime = 0;
      var foundNodeIds = this._findCaches[pattern];
      if (foundNodeIds === void 0) {
        var expression = patternRegExp(pattern);
        var nodeIds = Object.keys(this._nodes);
        foundNodeIds = nodeIds.filter(function(id) {
          return id.match(expression);
        });
        this._findCaches[pattern] = foundNodeIds;
      }
      if (includeOffline) {
        return foundNodeIds;
      }
      return foundNodeIds.filter(function(nodeId) {
        var node = this._getNode(nodeId);
        if (!node._offlineUntil) {
          return true;
        }
        if (!currentTime) {
          currentTime = getMonotonicMilliseconds();
        }
        return node._offlineUntil <= currentTime;
      }, this);
    };
    PoolCluster.prototype._getNode = function _getNode(id) {
      return this._nodes[id] || null;
    };
    PoolCluster.prototype._increaseErrorCount = function _increaseErrorCount(node) {
      var errorCount = ++node.errorCount;
      if (this._removeNodeErrorCount > errorCount) {
        return;
      }
      if (this._restoreNodeTimeout > 0) {
        node._offlineUntil = getMonotonicMilliseconds() + this._restoreNodeTimeout;
        this.emit("offline", node.id);
        return;
      }
      this._removeNode(node);
      this.emit("remove", node.id);
    };
    PoolCluster.prototype._getConnection = function(node, cb) {
      var self2 = this;
      node.pool.getConnection(function(err, connection) {
        if (err) {
          self2._increaseErrorCount(node);
          cb(err);
          return;
        } else {
          self2._decreaseErrorCount(node);
        }
        connection._clusterId = node.id;
        cb(null, connection);
      });
    };
    PoolCluster.prototype._removeNode = function _removeNode(node) {
      delete this._nodes[node.id];
      this._clearFindCaches();
      node.pool.end(_noop);
    };
    function getMonotonicMilliseconds() {
      var ms;
      if (typeof process.hrtime === "function") {
        ms = process.hrtime();
        ms = ms[0] * 1e3 + ms[1] * 1e-6;
      } else {
        ms = process.uptime() * 1e3;
      }
      return Math.floor(ms);
    }
    function isRegExp(val) {
      return typeof val === "object" && Object.prototype.toString.call(val) === "[object RegExp]";
    }
    function patternRegExp(pattern) {
      if (isRegExp(pattern)) {
        return pattern;
      }
      var source = pattern.replace(/([.+?^=!:${}()|\[\]\/\\])/g, "\\$1").replace(/\*/g, ".*");
      return new RegExp("^" + source + "$");
    }
    function _cb(err) {
      if (err) {
        throw err;
      }
    }
    function _noop() {
    }
  }
});

// node_modules/mysql/index.js
var require_mysql = __commonJS({
  "node_modules/mysql/index.js"(exports2) {
    var Classes = /* @__PURE__ */ Object.create(null);
    exports2.createConnection = function createConnection(config) {
      var Connection = loadClass("Connection");
      var ConnectionConfig = loadClass("ConnectionConfig");
      return new Connection({ config: new ConnectionConfig(config) });
    };
    exports2.createPool = function createPool(config) {
      var Pool = loadClass("Pool");
      var PoolConfig = loadClass("PoolConfig");
      return new Pool({ config: new PoolConfig(config) });
    };
    exports2.createPoolCluster = function createPoolCluster(config) {
      var PoolCluster = loadClass("PoolCluster");
      return new PoolCluster(config);
    };
    exports2.createQuery = function createQuery(sql, values, callback) {
      var Connection = loadClass("Connection");
      return Connection.createQuery(sql, values, callback);
    };
    exports2.escape = function escape(value, stringifyObjects, timeZone) {
      var SqlString = loadClass("SqlString");
      return SqlString.escape(value, stringifyObjects, timeZone);
    };
    exports2.escapeId = function escapeId(value, forbidQualified) {
      var SqlString = loadClass("SqlString");
      return SqlString.escapeId(value, forbidQualified);
    };
    exports2.format = function format(sql, values, stringifyObjects, timeZone) {
      var SqlString = loadClass("SqlString");
      return SqlString.format(sql, values, stringifyObjects, timeZone);
    };
    exports2.raw = function raw(sql) {
      var SqlString = loadClass("SqlString");
      return SqlString.raw(sql);
    };
    Object.defineProperty(exports2, "Types", {
      get: loadClass.bind(null, "Types")
    });
    function loadClass(className) {
      var Class = Classes[className];
      if (Class !== void 0) {
        return Class;
      }
      switch (className) {
        case "Connection":
          Class = require_Connection();
          break;
        case "ConnectionConfig":
          Class = require_ConnectionConfig();
          break;
        case "Pool":
          Class = require_Pool();
          break;
        case "PoolCluster":
          Class = require_PoolCluster();
          break;
        case "PoolConfig":
          Class = require_PoolConfig();
          break;
        case "SqlString":
          Class = require_SqlString2();
          break;
        case "Types":
          Class = require_types();
          break;
        default:
          throw new Error("Cannot find class '" + className + "'");
      }
      Classes[className] = Class;
      return Class;
    }
  }
});

// node_modules/promise-mysql/lib/helper.js
var require_helper = __commonJS({
  "node_modules/promise-mysql/lib/helper.js"(exports2, module2) {
    "use strict";
    var Promise2 = require_bluebird();
    module2.exports = {
      promiseCallback: function(functionName, params, returnArgumentsArray = false) {
        params = Array.prototype.slice.call(params, 0);
        return new Promise2((resolve, reject) => {
          params.push(function(err) {
            const args = Array.prototype.slice.call(arguments, 1);
            if (err) {
              return reject(err);
            }
            process.nextTick(() => {
              if (returnArgumentsArray) {
                args.push(call);
                return resolve(args);
              }
              return resolve(args[0]);
            });
          });
          const call = this[functionName].apply(this, params);
        });
      }
    };
  }
});

// node_modules/promise-mysql/lib/connection.js
var require_connection = __commonJS({
  "node_modules/promise-mysql/lib/connection.js"(exports2, module2) {
    "use strict";
    var Promise2 = require_bluebird();
    var mysql = require_mysql();
    var promiseCallback = require_helper().promiseCallback;
    var connection = class {
      constructor(config = {}, _connection2) {
        let mysqlValue = mysql;
        let mysqlWrapperCallbackPromise;
        if (typeof config !== "string") {
          if (config.mysqlWrapper) {
            let callback;
            mysqlWrapperCallbackPromise = new Promise2((resolve, reject) => {
              callback = (err, mysql2) => {
                if (err) {
                  return reject(err);
                }
                return resolve(mysql2);
              };
            });
            mysqlValue = config.mysqlWrapper(mysql, callback);
            config.mysqlWrapper = void 0;
          }
          if (config.returnArgumentsArray) {
            this.returnArgumentsArray = config.returnArgumentsArray;
            config.returnArgumentsArray = void 0;
          }
          if (config.reconnect === true || config.reconnect === void 0) {
            this.reconnect = true;
            config.reconnect = void 0;
          }
        }
        this.config = config;
        return Promise2.resolve(mysqlValue || mysqlWrapperCallbackPromise).then((mysql2) => {
          if (_connection2 && this.reconnect) {
            addReconnectHandler(_connection2, mysql2, this.config, this.reconnect);
          } else if (!_connection2) {
            _connection2 = connect(mysql2, this.config, this.reconnect);
          }
          return _connection2;
        }).then((connection2) => {
          this.connection = connection2;
          return this;
        });
      }
      query() {
        return promiseCallback.apply(this.connection, [`query`, arguments, this.returnArgumentsArray]);
      }
      queryStream(sql, values) {
        return this.connection.query(sql, values);
      }
      beginTransaction() {
        return promiseCallback.apply(this.connection, [`beginTransaction`, arguments, this.returnArgumentsArray]);
      }
      commit() {
        return promiseCallback.apply(this.connection, [`commit`, arguments, this.returnArgumentsArray]);
      }
      rollback() {
        return promiseCallback.apply(this.connection, [`rollback`, arguments, this.returnArgumentsArray]);
      }
      changeUser() {
        return promiseCallback.apply(this.connection, [`changeUser`, arguments, this.returnArgumentsArray]);
      }
      ping() {
        return promiseCallback.apply(this.connection, [`ping`, arguments, this.returnArgumentsArray]);
      }
      statistics() {
        return promiseCallback.apply(this.connection, [`statistics`, arguments, this.returnArgumentsArray]);
      }
      end() {
        return promiseCallback.apply(this.connection, [`end`, arguments, this.returnArgumentsArray]);
      }
      destroy() {
        this.connection.destroy();
      }
      pause() {
        this.connection.pause();
      }
      resume() {
        this.connection.resume();
      }
      escape(value) {
        return this.connection.escape(value);
      }
      escapeId(value) {
        return this.connection.escapeId(value);
      }
      format(sql, values) {
        return this.connection.format(sql, values);
      }
      on(event, fn) {
        this.connection.on(event, fn);
      }
    };
    var connect = (mysql2, config, reconnect) => {
      const connection2 = mysql2.createConnection(config);
      return new Promise2((resolve, reject) => {
        connection2.connect((err) => {
          if (err) {
            return reject(err);
          } else {
            if (reconnect) {
              addReconnectHandler(connection2, mysql2, config, reconnect);
            }
            return resolve(connection2);
          }
        });
      });
    };
    var addReconnectHandler = (connection2, mysql2, config, reconnect) => {
      connection2.once(`error`, (err) => {
        if (err.code === `PROTOCOL_CONNECTION_LOST` || err.code === `ECONNRESET` || err.code === `PROTOCOL_ENQUEUE_AFTER_FATAL_ERROR`) {
          connect(mysql2, config, reconnect);
        }
      });
    };
    module2.exports = connection;
  }
});

// node_modules/promise-mysql/lib/poolConnection.js
var require_poolConnection = __commonJS({
  "node_modules/promise-mysql/lib/poolConnection.js"(exports2, module2) {
    var Connection = require_connection();
    var poolConnection = class extends Connection {
      constructor(config, _connection) {
        super(config, _connection);
      }
      release() {
        this.connection.release();
      }
    };
    module2.exports = poolConnection;
  }
});

// node_modules/promise-mysql/lib/pool.js
var require_pool = __commonJS({
  "node_modules/promise-mysql/lib/pool.js"(exports2, module2) {
    "use strict";
    var Promise2 = require_bluebird();
    var mysql = require_mysql();
    var PoolConnection = require_poolConnection();
    var promiseCallback = require_helper().promiseCallback;
    var pool = class {
      constructor(config = {}, _pool2) {
        if (_pool2) {
          this.pool = _pool2;
          return this;
        }
        let mysqlValue = mysql;
        let mysqlWrapperCallbackPromise;
        if (config.mysqlWrapper) {
          let callback;
          mysqlWrapperCallbackPromise = new Promise2((resolve, reject) => {
            callback = (err, mysql2) => {
              if (err) {
                return reject(err);
              }
              return resolve(mysql2);
            };
          });
          mysqlValue = config.mysqlWrapper(mysql, callback);
          delete config.mysqlWrapper;
        }
        if (config.returnArgumentsArray) {
          this.returnArgumentsArray = config.returnArgumentsArray;
          config.returnArgumentsArray = void 0;
        }
        return Promise2.resolve(mysqlValue || mysqlWrapperCallbackPromise).then((mysql2) => {
          this.pool = mysql2.createPool(config);
          return Promise2.resolve(this);
        });
      }
      getConnection() {
        return promiseCallback.apply(this.pool, ["getConnection", arguments]).then((_connection) => {
          const config = {
            returnArgumentsArray: this.returnArgumentsArray,
            reconnect: false
          };
          return new PoolConnection(config, _connection);
        });
      }
      query() {
        return promiseCallback.apply(this.pool, ["query", arguments, this.returnArgumentsArray]);
      }
      end() {
        return promiseCallback.apply(this.pool, ["end", arguments, this.returnArgumentsArray]);
      }
      escape(value) {
        return this.pool.escape(value);
      }
      escapeId(value) {
        return this.pool.escapeId(value);
      }
      on(event, fn) {
        this.pool.on(event, fn);
      }
    };
    module2.exports = pool;
  }
});

// node_modules/promise-mysql/lib/poolCluster.js
var require_poolCluster = __commonJS({
  "node_modules/promise-mysql/lib/poolCluster.js"(exports2, module2) {
    "use strict";
    var Promise2 = require_bluebird();
    var mysql = require_mysql();
    var Pool = require_pool();
    var PoolConnection = require_poolConnection();
    var promiseCallback = require_helper().promiseCallback;
    var poolCluster = class {
      constructor(config = {}) {
        if (config.returnArgumentsArray) {
          this.returnArgumentsArray = config.returnArgumentsArray;
          config.returnArgumentsArray = void 0;
        }
        return Promise2.resolve(mysql).then((mysql2) => {
          this.poolCluster = mysql2.createPoolCluster(config);
          return Promise2.resolve(this);
        });
      }
      add(id, config) {
        return this.poolCluster.add(id, config);
      }
      end() {
        return promiseCallback.apply(this.poolCluster, ["end", arguments, this.returnArgumentsArray]);
      }
      of(pattern, selector) {
        const pool = this.poolCluster.of(pattern, selector);
        return new Pool(void 0, pool);
      }
      remove(pattern) {
        return this.poolCluster.remove(pattern);
      }
      getConnection() {
        return promiseCallback.apply(this.poolCluster, ["getConnection", arguments, this.returnArgumentsArray]).then((_connection) => {
          const config = {
            reconnect: false
          };
          return new PoolConnection(config, _connection);
        });
      }
      on(event, fn) {
        return this.poolCluster.on(event, fn);
      }
    };
    module2.exports = poolCluster;
  }
});

// node_modules/promise-mysql/index.js
var require_promise_mysql = __commonJS({
  "node_modules/promise-mysql/index.js"(exports2) {
    var Connection = require_connection();
    var Pool = require_pool();
    var PoolCluster = require_poolCluster();
    var mysql = require_mysql();
    exports2.createConnection = function(config) {
      return new Connection(config);
    };
    exports2.createPool = function(config) {
      return new Pool(config);
    };
    exports2.createPoolCluster = function(config) {
      return new PoolCluster(config);
    };
    exports2.Types = mysql.Types;
    exports2.escape = mysql.escape;
    exports2.escapeId = mysql.escapeId;
    exports2.format = mysql.format;
    exports2.raw = mysql.raw;
    exports2.PoolCluster = PoolCluster;
    exports2.Pool = Pool;
    exports2.Connection = Connection;
  }
});

// node_modules/quick.db/out/drivers/MySQLDriver.js
var require_MySQLDriver = __commonJS({
  "node_modules/quick.db/out/drivers/MySQLDriver.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MySQLDriver = void 0;
    var MySQLDriver = class {
      constructor(config) {
        __publicField(this, "mysql");
        __publicField(this, "conn");
        __publicField(this, "config");
        this.config = config;
        this.mysql = require_promise_mysql();
      }
      checkConnection() {
        if (this.conn == null)
          throw new Error("MySQL not connected to the database");
      }
      async connect() {
        this.conn = await this.mysql.createPool(this.config);
      }
      async prepare(table) {
        var _a;
        this.checkConnection();
        await ((_a = this.conn) == null ? void 0 : _a.query(`CREATE TABLE IF NOT EXISTS ${table} (ID TEXT, json TEXT)`));
      }
      async getAllRows(table) {
        var _a;
        this.checkConnection();
        const results = await ((_a = this.conn) == null ? void 0 : _a.query(`SELECT * FROM ${table}`));
        return results.map((row) => ({
          id: row.ID,
          value: JSON.parse(row.json)
        }));
      }
      async getRowByKey(table, key) {
        var _a;
        this.checkConnection();
        const results = await ((_a = this.conn) == null ? void 0 : _a.query(`SELECT json FROM ${table} WHERE ID = ?`, [key]));
        if (results.length == 0)
          return [null, false];
        return [JSON.parse(results[0].json), true];
      }
      async setRowByKey(table, key, value, update) {
        var _a, _b;
        const stringifiedJson = JSON.stringify(value);
        if (update) {
          await ((_a = this.conn) == null ? void 0 : _a.query(`UPDATE ${table} SET json = (?) WHERE ID = (?)`, [stringifiedJson, key]));
        } else {
          await ((_b = this.conn) == null ? void 0 : _b.query(`INSERT INTO ${table} (ID,json) VALUES (?,?)`, [key, stringifiedJson]));
        }
        return value;
      }
      async deleteAllRows(table) {
        var _a;
        this.checkConnection();
        const result = await ((_a = this.conn) == null ? void 0 : _a.query(`DELETE FROM ${table}`));
        return result.affectedRows;
      }
      async deleteRowByKey(table, key) {
        var _a;
        this.checkConnection();
        const result = await ((_a = this.conn) == null ? void 0 : _a.query(`DELETE FROM ${table} WHERE ID=?`, [key]));
        return result.affectedRows;
      }
    };
    exports2.MySQLDriver = MySQLDriver;
  }
});

// node_modules/quick.db/out/index.js
var require_out = __commonJS({
  "node_modules/quick.db/out/index.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.QuickDB = exports2.SqliteDriver = exports2.MySQLDriver = void 0;
    var lodash_1 = require_lodash();
    var SqliteDriver_1 = require_SqliteDriver();
    var MySQLDriver_1 = require_MySQLDriver();
    Object.defineProperty(exports2, "MySQLDriver", { enumerable: true, get: function() {
      return MySQLDriver_1.MySQLDriver;
    } });
    var SqliteDriver_2 = require_SqliteDriver();
    Object.defineProperty(exports2, "SqliteDriver", { enumerable: true, get: function() {
      return SqliteDriver_2.SqliteDriver;
    } });
    var QuickDB = class {
      constructor(options = {}) {
        __publicField(this, "driver");
        __publicField(this, "tableName");
        __publicField(this, "options");
        options.table ?? (options.table = "json");
        options.filePath ?? (options.filePath = "json.sqlite");
        options.driver ?? (options.driver = new SqliteDriver_1.SqliteDriver(options.filePath));
        this.options = options;
        this.driver = options.driver;
        this.tableName = options.table;
        this.driver.prepare(this.tableName);
      }
      async addSubtract(key, value, sub = false) {
        if (typeof key != "string")
          throw new Error("First argument (key) needs to be a string");
        if (value == null)
          throw new Error("Missing second argument (value)");
        let currentNumber = await this.get(key);
        if (currentNumber == null)
          currentNumber = 0;
        if (typeof currentNumber != "number") {
          try {
            currentNumber = parseFloat(currentNumber);
          } catch (_) {
            throw new Error(`Current value with key: (${key}) is not a number and couldn't be parsed to a number`);
          }
        }
        sub ? currentNumber -= value : currentNumber += value;
        return this.set(key, currentNumber);
      }
      async getArray(key) {
        const currentArr = await this.get(key) ?? [];
        if (!Array.isArray(currentArr))
          throw new Error(`Current value with key: (${key}) is not an array`);
        return currentArr;
      }
      async all() {
        return this.driver.getAllRows(this.tableName);
      }
      async get(key) {
        if (typeof key != "string")
          throw new Error("First argument (key) needs to be a string");
        if (key.includes(".")) {
          const keySplit = key.split(".");
          const [result2] = await this.driver.getRowByKey(this.tableName, keySplit[0]);
          return (0, lodash_1.get)(result2, keySplit.slice(1).join("."));
        }
        const [result] = await this.driver.getRowByKey(this.tableName, key);
        return result;
      }
      async set(key, value) {
        if (typeof key != "string")
          throw new Error("First argument (key) needs to be a string");
        if (value == null)
          throw new Error("Missing second argument (value)");
        if (key.includes(".")) {
          const keySplit = key.split(".");
          const [result, exist2] = await this.driver.getRowByKey(this.tableName, keySplit[0]);
          let obj2;
          if (result instanceof Object == false) {
            obj2 = {};
          } else {
            obj2 = result;
          }
          const valueSet = (0, lodash_1.set)(obj2 ?? {}, keySplit.slice(1).join("."), value);
          return this.driver.setRowByKey(this.tableName, keySplit[0], valueSet, exist2);
        }
        const exist = (await this.driver.getRowByKey(this.tableName, key))[1];
        return this.driver.setRowByKey(this.tableName, key, value, exist);
      }
      async has(key) {
        return await this.get(key) != null;
      }
      async delete(key) {
        if (typeof key != "string")
          throw new Error("First argument (key) needs to be a string");
        if (key.includes(".")) {
          const keySplit = key.split(".");
          const obj2 = await this.get(keySplit[0]) ?? {};
          (0, lodash_1.unset)(obj2, keySplit.slice(1).join("."));
          return this.set(keySplit[0], obj2);
        }
        return this.driver.deleteRowByKey(this.tableName, key);
      }
      async deleteAll() {
        return this.driver.deleteAllRows(this.tableName);
      }
      async add(key, value) {
        return this.addSubtract(key, value);
      }
      async sub(key, value) {
        return this.addSubtract(key, value, true);
      }
      async push(key, value) {
        if (typeof key != "string")
          throw new Error("First argument (key) needs to be a string");
        if (value == null)
          throw new Error("Missing second argument (value)");
        let currentArr = await this.getArray(key);
        if (Array.isArray(value))
          currentArr = currentArr.concat(value);
        else
          currentArr.push(value);
        return this.set(key, currentArr);
      }
      async pull(key, value) {
        if (typeof key != "string")
          throw new Error("First argument (key) needs to be a string");
        if (value == null)
          throw new Error("Missing second argument (value)");
        let currentArr = await this.getArray(key);
        if (!Array.isArray(value) && typeof value != "function")
          value = [value];
        currentArr = currentArr.filter((...params) => Array.isArray(value) ? !value.includes(params[0]) : !value(...params));
        return this.set(key, currentArr);
      }
      table(table) {
        if (typeof table != "string")
          throw new Error("First argument (table) needs to be a string");
        const options = { ...this.options };
        options.table = table;
        options.driver = this.options.driver;
        return new QuickDB(options);
      }
    };
    exports2.QuickDB = QuickDB;
  }
});
export default require_out();
/*! Bundled license information:

lodash/lodash.js:
  (**
   * @license
   * Lodash <https://lodash.com/>
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   *)

bluebird/js/browser/bluebird.js:
  (* @preserve
   * The MIT License (MIT)
   * 
   * Copyright (c) 2013-2018 Petka Antonov
   * 
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   * 
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   * 
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   * 
   *)

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)
*/
//# sourceMappingURL=quick__db.js.map
